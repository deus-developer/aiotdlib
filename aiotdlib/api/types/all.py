# =============================================================================== #
#                                                                                 #
#    This file has been generated automatically!! Do not change this manually!    #
#                                                                                 #
# =============================================================================== #
from __future__ import annotations

import typing
from dataclasses import MISSING, dataclass, field

from .base import *


@dataclass(slots=True, kw_only=True)
class AccentColor(BaseObject):
    """
    Contains information about supported accent color for user/chat name, background of empty chat photo, replies to messages and link previews

    :param id: Accent color identifier
    :type id: :class:`Int32`
    :param built_in_accent_color_id: Identifier of a built-in color to use in places, where only one color is needed; 0-6
    :type built_in_accent_color_id: :class:`Int32`
    :param light_theme_colors: The list of 1-3 colors in RGB format, describing the accent color, as expected to be shown in light themes
    :type light_theme_colors: :class:`Vector[Int32]`
    :param dark_theme_colors: The list of 1-3 colors in RGB format, describing the accent color, as expected to be shown in dark themes
    :type dark_theme_colors: :class:`Vector[Int32]`
    :param min_channel_chat_boost_level: The minimum chat boost level required to use the color in a channel chat
    :type min_channel_chat_boost_level: :class:`Int32`
    """

    ID: typing.Literal["accentColor"] = field(default="accentColor", metadata={"alias": "@type"})
    id: Int32
    built_in_accent_color_id: Int32
    light_theme_colors: Vector[Int32]
    dark_theme_colors: Vector[Int32]
    min_channel_chat_boost_level: Int32


@dataclass(slots=True, kw_only=True)
class AccountTtl(BaseObject):
    """
    Contains information about the period of inactivity after which the current user's account will automatically be deleted

    :param days: Number of days of inactivity before the account will be flagged for deletion; 30-730 days
    :type days: :class:`Int32`
    """

    ID: typing.Literal["accountTtl"] = field(default="accountTtl", metadata={"alias": "@type"})
    days: Int32


@dataclass(slots=True, kw_only=True)
class AddedReaction(BaseObject):
    """
    Represents a reaction applied to a message

    :param type_: Type of the reaction
    :type type_: :class:`ReactionType`
    :param sender_id: Identifier of the chat member, applied the reaction
    :type sender_id: :class:`MessageSender`
    :param date: Point in time (Unix timestamp) when the reaction was added
    :type date: :class:`Int32`
    :param is_outgoing: True, if the reaction was added by the current user
    :type is_outgoing: :class:`Bool`
    """

    ID: typing.Literal["addedReaction"] = field(default="addedReaction", metadata={"alias": "@type"})
    type_: ReactionType = field(default=MISSING, metadata={"alias": "type"})
    sender_id: MessageSender
    date: Int32
    is_outgoing: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class AddedReactions(BaseObject):
    """
    Represents a list of reactions added to a message

    :param total_count: The total number of found reactions
    :type total_count: :class:`Int32`
    :param reactions: The list of added reactions
    :type reactions: :class:`Vector[AddedReaction]`
    :param next_offset: The offset for the next request. If empty, then there are no more results
    :type next_offset: :class:`String`
    """

    ID: typing.Literal["addedReactions"] = field(default="addedReactions", metadata={"alias": "@type"})
    total_count: Int32
    reactions: Vector[AddedReaction]
    next_offset: String = field(default="")


@dataclass(slots=True, kw_only=True)
class Address(BaseObject):
    """
    Describes an address

    :param country_code: A two-letter ISO 3166-1 alpha-2 country code
    :type country_code: :class:`String`
    :param state: State, if applicable
    :type state: :class:`String`
    :param city: City
    :type city: :class:`String`
    :param street_line1: First line of the address
    :type street_line1: :class:`String`
    :param street_line2: Second line of the address
    :type street_line2: :class:`String`
    :param postal_code: Address postal code
    :type postal_code: :class:`String`
    """

    ID: typing.Literal["address"] = field(default="address", metadata={"alias": "@type"})
    country_code: String
    state: String
    city: String
    street_line1: String
    street_line2: String
    postal_code: String


@dataclass(slots=True, kw_only=True)
class AffiliateInfo(BaseObject):
    """
    Contains information about an affiliate that received commission from a Telegram Star transaction

    :param commission_per_mille: The number of Telegram Stars received by the affiliate for each 1000 Telegram Stars received by the program owner
    :type commission_per_mille: :class:`Int32`
    :param affiliate_chat_id: Identifier of the chat which received the commission
    :type affiliate_chat_id: :class:`Int53`
    :param star_amount: The amount of Telegram Stars that were received by the affiliate; can be negative for refunds
    :type star_amount: :class:`StarAmount`
    """

    ID: typing.Literal["affiliateInfo"] = field(default="affiliateInfo", metadata={"alias": "@type"})
    commission_per_mille: Int32
    affiliate_chat_id: Int53
    star_amount: StarAmount


@dataclass(slots=True, kw_only=True)
class AffiliateProgramInfo(BaseObject):
    """
    Contains information about an active affiliate program

    :param parameters: Parameters of the affiliate program
    :type parameters: :class:`AffiliateProgramParameters`
    :param daily_revenue_per_user_amount: The amount of daily revenue per user in Telegram Stars of the bot that created the affiliate program
    :type daily_revenue_per_user_amount: :class:`StarAmount`
    :param end_date: Point in time (Unix timestamp) when the affiliate program will be closed; 0 if the affiliate program isn't scheduled to be closed. If positive, then the program can't be connected using connectAffiliateProgram, but active connections will work until the date
    :type end_date: :class:`Int32`
    """

    ID: typing.Literal["affiliateProgramInfo"] = field(default="affiliateProgramInfo", metadata={"alias": "@type"})
    parameters: AffiliateProgramParameters
    daily_revenue_per_user_amount: StarAmount
    end_date: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class AffiliateProgramParameters(BaseObject):
    """
    Describes parameters of an affiliate program

    :param commission_per_mille: The number of Telegram Stars received by the affiliate for each 1000 Telegram Stars received by the program owner; getOption("affiliate_program_commission_per_mille_min")-getOption("affiliate_program_commission_per_mille_max")
    :type commission_per_mille: :class:`Int32`
    :param month_count: Number of months the program will be active; 0-36. If 0, then the program is eternal
    :type month_count: :class:`Int32`
    """

    ID: typing.Literal["affiliateProgramParameters"] = field(
        default="affiliateProgramParameters", metadata={"alias": "@type"}
    )
    commission_per_mille: Int32
    month_count: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class AffiliateProgramSortOrderCreationDate(BaseObject):
    """
    The affiliate programs must be sorted by creation date
    """

    ID: typing.Literal["affiliateProgramSortOrderCreationDate"] = field(
        default="affiliateProgramSortOrderCreationDate", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class AffiliateProgramSortOrderProfitability(BaseObject):
    """
    The affiliate programs must be sorted by the profitability
    """

    ID: typing.Literal["affiliateProgramSortOrderProfitability"] = field(
        default="affiliateProgramSortOrderProfitability", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class AffiliateProgramSortOrderRevenue(BaseObject):
    """
    The affiliate programs must be sorted by the expected revenue
    """

    ID: typing.Literal["affiliateProgramSortOrderRevenue"] = field(
        default="affiliateProgramSortOrderRevenue", metadata={"alias": "@type"}
    )


AffiliateProgramSortOrder = typing.Union[
    AffiliateProgramSortOrderCreationDate,
    AffiliateProgramSortOrderProfitability,
    AffiliateProgramSortOrderRevenue,
]


@dataclass(slots=True, kw_only=True)
class AffiliateTypeBot(BaseObject):
    """
    The affiliate is a bot owned by the current user

    :param user_id: User identifier of the bot
    :type user_id: :class:`Int53`
    """

    ID: typing.Literal["affiliateTypeBot"] = field(default="affiliateTypeBot", metadata={"alias": "@type"})
    user_id: Int53


@dataclass(slots=True, kw_only=True)
class AffiliateTypeChannel(BaseObject):
    """
    The affiliate is a channel chat where the current user has can_post_messages administrator right

    :param chat_id: Identifier of the channel chat
    :type chat_id: :class:`Int53`
    """

    ID: typing.Literal["affiliateTypeChannel"] = field(default="affiliateTypeChannel", metadata={"alias": "@type"})
    chat_id: Int53


@dataclass(slots=True, kw_only=True)
class AffiliateTypeCurrentUser(BaseObject):
    """
    The affiliate is the current user
    """

    ID: typing.Literal["affiliateTypeCurrentUser"] = field(
        default="affiliateTypeCurrentUser", metadata={"alias": "@type"}
    )


AffiliateType = typing.Union[
    AffiliateTypeBot,
    AffiliateTypeChannel,
    AffiliateTypeCurrentUser,
]


@dataclass(slots=True, kw_only=True)
class AlternativeVideo(BaseObject):
    """
    Describes an alternative re-encoded quality of a video file

    :param width: Video width
    :type width: :class:`Int32`
    :param height: Video height
    :type height: :class:`Int32`
    :param codec: Codec used for video file encoding, for example, "h264", "h265", or "av1"
    :type codec: :class:`String`
    :param hls_file: HLS file describing the video
    :type hls_file: :class:`File`
    :param video: File containing the video
    :type video: :class:`File`
    """

    ID: typing.Literal["alternativeVideo"] = field(default="alternativeVideo", metadata={"alias": "@type"})
    width: Int32
    height: Int32
    codec: String
    hls_file: File
    video: File


@dataclass(slots=True, kw_only=True)
class AnimatedChatPhoto(BaseObject):
    """
    Animated variant of a chat photo in MPEG4 format

    :param length: Animation width and height
    :type length: :class:`Int32`
    :param file: Information about the animation file
    :type file: :class:`File`
    :param main_frame_timestamp: Timestamp of the frame, used as a static chat photo
    :type main_frame_timestamp: :class:`Double`
    """

    ID: typing.Literal["animatedChatPhoto"] = field(default="animatedChatPhoto", metadata={"alias": "@type"})
    length: Int32
    file: File
    main_frame_timestamp: Double


@dataclass(slots=True, kw_only=True)
class AnimatedEmoji(BaseObject):
    """
    Describes an animated or custom representation of an emoji

    :param sticker_width: Expected width of the sticker, which can be used if the sticker is null
    :type sticker_width: :class:`Int32`
    :param sticker_height: Expected height of the sticker, which can be used if the sticker is null
    :type sticker_height: :class:`Int32`
    :param sticker: Sticker for the emoji; may be null if yet unknown for a custom emoji. If the sticker is a custom emoji, then it can have arbitrary format, defaults to None
    :type sticker: :class:`Sticker`, optional
    :param sound: File containing the sound to be played when the sticker is clicked; may be null. The sound is encoded with the Opus codec, and stored inside an OGG container, defaults to None
    :type sound: :class:`File`, optional
    :param fitzpatrick_type: Emoji modifier fitzpatrick type; 0-6; 0 if none, defaults to None
    :type fitzpatrick_type: :class:`Int32`, optional
    """

    ID: typing.Literal["animatedEmoji"] = field(default="animatedEmoji", metadata={"alias": "@type"})
    sticker_width: Int32
    sticker_height: Int32
    sticker: typing.Optional[Sticker] = field(default=None)
    sound: typing.Optional[File] = field(default=None)
    fitzpatrick_type: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class Animation(BaseObject):
    """
    Describes an animation file. The animation must be encoded in GIF or MPEG4 format

    :param duration: Duration of the animation, in seconds; as defined by the sender
    :type duration: :class:`Int32`
    :param width: Width of the animation
    :type width: :class:`Int32`
    :param height: Height of the animation
    :type height: :class:`Int32`
    :param file_name: Original name of the file; as defined by the sender
    :type file_name: :class:`String`
    :param mime_type: MIME type of the file, usually "image/gif" or "video/mp4"
    :type mime_type: :class:`String`
    :param animation: File containing the animation
    :type animation: :class:`File`
    :param minithumbnail: Animation minithumbnail; may be null, defaults to None
    :type minithumbnail: :class:`Minithumbnail`, optional
    :param thumbnail: Animation thumbnail in JPEG or MPEG4 format; may be null, defaults to None
    :type thumbnail: :class:`Thumbnail`, optional
    :param has_stickers: True, if stickers were added to the animation. The list of corresponding sticker set can be received using getAttachedStickerSets
    :type has_stickers: :class:`Bool`
    """

    ID: typing.Literal["animation"] = field(default="animation", metadata={"alias": "@type"})
    duration: Int32
    width: Int32
    height: Int32
    file_name: String
    mime_type: String
    animation: File
    minithumbnail: typing.Optional[Minithumbnail] = field(default=None)
    thumbnail: typing.Optional[Thumbnail] = field(default=None)
    has_stickers: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class Animations(BaseObject):
    """
    Represents a list of animations

    :param animations: List of animations
    :type animations: :class:`Vector[Animation]`
    """

    ID: typing.Literal["animations"] = field(default="animations", metadata={"alias": "@type"})
    animations: Vector[Animation]


@dataclass(slots=True, kw_only=True)
class ArchiveChatListSettings(BaseObject):
    """
    Contains settings for automatic moving of chats to and from the Archive chat lists

    :param archive_and_mute_new_chats_from_unknown_users: True, if new chats from non-contacts will be automatically archived and muted. Can be set to true only if the option "can_archive_and_mute_new_chats_from_unknown_users" is true
    :type archive_and_mute_new_chats_from_unknown_users: :class:`Bool`
    :param keep_unmuted_chats_archived: True, if unmuted chats will be kept in the Archive chat list when they get a new message
    :type keep_unmuted_chats_archived: :class:`Bool`
    :param keep_chats_from_folders_archived: True, if unmuted chats, that are always included or pinned in a folder, will be kept in the Archive chat list when they get a new message. Ignored if keep_unmuted_chats_archived == true
    :type keep_chats_from_folders_archived: :class:`Bool`
    """

    ID: typing.Literal["archiveChatListSettings"] = field(
        default="archiveChatListSettings", metadata={"alias": "@type"}
    )
    archive_and_mute_new_chats_from_unknown_users: Bool = field(default=False)
    keep_unmuted_chats_archived: Bool = field(default=False)
    keep_chats_from_folders_archived: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class AttachmentMenuBot(BaseObject):
    """
    Represents a bot, which can be added to attachment or side menu

    :param bot_user_id: User identifier of the bot
    :type bot_user_id: :class:`Int53`
    :param name: Name for the bot in attachment menu
    :type name: :class:`String`
    :param name_color: Color to highlight selected name of the bot if appropriate; may be null, defaults to None
    :type name_color: :class:`AttachmentMenuBotColor`, optional
    :param default_icon: Default icon for the bot in SVG format; may be null, defaults to None
    :type default_icon: :class:`File`, optional
    :param ios_static_icon: Icon for the bot in SVG format for the official iOS app; may be null, defaults to None
    :type ios_static_icon: :class:`File`, optional
    :param ios_animated_icon: Icon for the bot in TGS format for the official iOS app; may be null, defaults to None
    :type ios_animated_icon: :class:`File`, optional
    :param ios_side_menu_icon: Icon for the bot in PNG format for the official iOS app side menu; may be null, defaults to None
    :type ios_side_menu_icon: :class:`File`, optional
    :param android_icon: Icon for the bot in TGS format for the official Android app; may be null, defaults to None
    :type android_icon: :class:`File`, optional
    :param android_side_menu_icon: Icon for the bot in SVG format for the official Android app side menu; may be null, defaults to None
    :type android_side_menu_icon: :class:`File`, optional
    :param macos_icon: Icon for the bot in TGS format for the official native macOS app; may be null, defaults to None
    :type macos_icon: :class:`File`, optional
    :param macos_side_menu_icon: Icon for the bot in PNG format for the official macOS app side menu; may be null, defaults to None
    :type macos_side_menu_icon: :class:`File`, optional
    :param icon_color: Color to highlight selected icon of the bot if appropriate; may be null, defaults to None
    :type icon_color: :class:`AttachmentMenuBotColor`, optional
    :param web_app_placeholder: Default placeholder for opened Web Apps in SVG format; may be null, defaults to None
    :type web_app_placeholder: :class:`File`, optional
    :param supports_self_chat: True, if the bot supports opening from attachment menu in the chat with the bot
    :type supports_self_chat: :class:`Bool`
    :param supports_user_chats: True, if the bot supports opening from attachment menu in private chats with ordinary users
    :type supports_user_chats: :class:`Bool`
    :param supports_bot_chats: True, if the bot supports opening from attachment menu in private chats with other bots
    :type supports_bot_chats: :class:`Bool`
    :param supports_group_chats: True, if the bot supports opening from attachment menu in basic group and supergroup chats
    :type supports_group_chats: :class:`Bool`
    :param supports_channel_chats: True, if the bot supports opening from attachment menu in channel chats
    :type supports_channel_chats: :class:`Bool`
    :param request_write_access: True, if the user must be asked for the permission to send messages to the bot
    :type request_write_access: :class:`Bool`
    :param is_added: True, if the bot was explicitly added by the user. If the bot isn't added, then on the first bot launch toggleBotIsAddedToAttachmentMenu must be called and the bot must be added or removed
    :type is_added: :class:`Bool`
    :param show_in_attachment_menu: True, if the bot must be shown in the attachment menu
    :type show_in_attachment_menu: :class:`Bool`
    :param show_in_side_menu: True, if the bot must be shown in the side menu
    :type show_in_side_menu: :class:`Bool`
    :param show_disclaimer_in_side_menu: True, if a disclaimer, why the bot is shown in the side menu, is needed
    :type show_disclaimer_in_side_menu: :class:`Bool`
    """

    ID: typing.Literal["attachmentMenuBot"] = field(default="attachmentMenuBot", metadata={"alias": "@type"})
    bot_user_id: Int53
    name: String
    name_color: typing.Optional[AttachmentMenuBotColor] = field(default=None)
    default_icon: typing.Optional[File] = field(default=None)
    ios_static_icon: typing.Optional[File] = field(default=None)
    ios_animated_icon: typing.Optional[File] = field(default=None)
    ios_side_menu_icon: typing.Optional[File] = field(default=None)
    android_icon: typing.Optional[File] = field(default=None)
    android_side_menu_icon: typing.Optional[File] = field(default=None)
    macos_icon: typing.Optional[File] = field(default=None)
    macos_side_menu_icon: typing.Optional[File] = field(default=None)
    icon_color: typing.Optional[AttachmentMenuBotColor] = field(default=None)
    web_app_placeholder: typing.Optional[File] = field(default=None)
    supports_self_chat: Bool = field(default=False)
    supports_user_chats: Bool = field(default=False)
    supports_bot_chats: Bool = field(default=False)
    supports_group_chats: Bool = field(default=False)
    supports_channel_chats: Bool = field(default=False)
    request_write_access: Bool = field(default=False)
    is_added: Bool = field(default=False)
    show_in_attachment_menu: Bool = field(default=False)
    show_in_side_menu: Bool = field(default=False)
    show_disclaimer_in_side_menu: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class AttachmentMenuBotColor(BaseObject):
    """
    Describes a color to highlight a bot added to attachment menu

    :param light_color: Color in the RGB format for light themes
    :type light_color: :class:`Int32`
    :param dark_color: Color in the RGB format for dark themes
    :type dark_color: :class:`Int32`
    """

    ID: typing.Literal["attachmentMenuBotColor"] = field(default="attachmentMenuBotColor", metadata={"alias": "@type"})
    light_color: Int32
    dark_color: Int32


@dataclass(slots=True, kw_only=True)
class Audio(BaseObject):
    """
    Describes an audio file. Audio is usually in MP3 or M4A format

    :param duration: Duration of the audio, in seconds; as defined by the sender
    :type duration: :class:`Int32`
    :param title: Title of the audio; as defined by the sender
    :type title: :class:`String`
    :param performer: Performer of the audio; as defined by the sender
    :type performer: :class:`String`
    :param file_name: Original name of the file; as defined by the sender
    :type file_name: :class:`String`
    :param mime_type: The MIME type of the file; as defined by the sender
    :type mime_type: :class:`String`
    :param external_album_covers: Album cover variants to use if the downloaded audio file contains no album cover. Provided thumbnail dimensions are approximate
    :type external_album_covers: :class:`Vector[Thumbnail]`
    :param audio: File containing the audio
    :type audio: :class:`File`
    :param album_cover_minithumbnail: The minithumbnail of the album cover; may be null, defaults to None
    :type album_cover_minithumbnail: :class:`Minithumbnail`, optional
    :param album_cover_thumbnail: The thumbnail of the album cover in JPEG format; as defined by the sender. The full size thumbnail is expected to be extracted from the downloaded audio file; may be null, defaults to None
    :type album_cover_thumbnail: :class:`Thumbnail`, optional
    """

    ID: typing.Literal["audio"] = field(default="audio", metadata={"alias": "@type"})
    duration: Int32
    title: String
    performer: String
    file_name: String
    mime_type: String
    external_album_covers: Vector[Thumbnail]
    audio: File
    album_cover_minithumbnail: typing.Optional[Minithumbnail] = field(default=None)
    album_cover_thumbnail: typing.Optional[Thumbnail] = field(default=None)


@dataclass(slots=True, kw_only=True)
class AuthenticationCodeInfo(BaseObject):
    """
    Information about the authentication code that was sent

    :param phone_number: A phone number that is being authenticated
    :type phone_number: :class:`String`
    :param type_: The way the code was sent to the user
    :type type_: :class:`AuthenticationCodeType`
    :param timeout: Timeout before the code can be re-sent, in seconds
    :type timeout: :class:`Int32`
    :param next_type: The way the next code will be sent to the user; may be null, defaults to None
    :type next_type: :class:`AuthenticationCodeType`, optional
    """

    ID: typing.Literal["authenticationCodeInfo"] = field(default="authenticationCodeInfo", metadata={"alias": "@type"})
    phone_number: String
    type_: AuthenticationCodeType = field(default=MISSING, metadata={"alias": "type"})
    timeout: Int32
    next_type: typing.Optional[AuthenticationCodeType] = field(default=None)


@dataclass(slots=True, kw_only=True)
class AuthenticationCodeTypeCall(BaseObject):
    """
    A digit-only authentication code is delivered via a phone call to the specified phone number

    :param length: Length of the code
    :type length: :class:`Int32`
    """

    ID: typing.Literal["authenticationCodeTypeCall"] = field(
        default="authenticationCodeTypeCall", metadata={"alias": "@type"}
    )
    length: Int32


@dataclass(slots=True, kw_only=True)
class AuthenticationCodeTypeFirebaseAndroid(BaseObject):
    """
    A digit-only authentication code is delivered via Firebase Authentication to the official Android application

    :param device_verification_parameters: Parameters to be used for device verification
    :type device_verification_parameters: :class:`FirebaseDeviceVerificationParameters`
    :param length: Length of the code
    :type length: :class:`Int32`
    """

    ID: typing.Literal["authenticationCodeTypeFirebaseAndroid"] = field(
        default="authenticationCodeTypeFirebaseAndroid", metadata={"alias": "@type"}
    )
    device_verification_parameters: FirebaseDeviceVerificationParameters
    length: Int32


@dataclass(slots=True, kw_only=True)
class AuthenticationCodeTypeFirebaseIos(BaseObject):
    """
    A digit-only authentication code is delivered via Firebase Authentication to the official iOS application

    :param receipt: Receipt of successful application token validation to compare with receipt from push notification
    :type receipt: :class:`String`
    :param push_timeout: Time after the next authentication method is expected to be used if verification push notification isn't received, in seconds
    :type push_timeout: :class:`Int32`
    :param length: Length of the code
    :type length: :class:`Int32`
    """

    ID: typing.Literal["authenticationCodeTypeFirebaseIos"] = field(
        default="authenticationCodeTypeFirebaseIos", metadata={"alias": "@type"}
    )
    receipt: String
    push_timeout: Int32
    length: Int32


@dataclass(slots=True, kw_only=True)
class AuthenticationCodeTypeFlashCall(BaseObject):
    """
    An authentication code is delivered by an immediately canceled call to the specified phone number. The phone number that calls is the code that must be entered automatically

    :param pattern: Pattern of the phone number from which the call will be made
    :type pattern: :class:`String`
    """

    ID: typing.Literal["authenticationCodeTypeFlashCall"] = field(
        default="authenticationCodeTypeFlashCall", metadata={"alias": "@type"}
    )
    pattern: String


@dataclass(slots=True, kw_only=True)
class AuthenticationCodeTypeFragment(BaseObject):
    """
    A digit-only authentication code is delivered to https://fragment.com. The user must be logged in there via a wallet owning the phone number's NFT

    :param url: URL to open to receive the code
    :type url: :class:`String`
    :param length: Length of the code
    :type length: :class:`Int32`
    """

    ID: typing.Literal["authenticationCodeTypeFragment"] = field(
        default="authenticationCodeTypeFragment", metadata={"alias": "@type"}
    )
    url: String
    length: Int32


@dataclass(slots=True, kw_only=True)
class AuthenticationCodeTypeMissedCall(BaseObject):
    """
    An authentication code is delivered by an immediately canceled call to the specified phone number. The last digits of the phone number that calls are the code that must be entered manually by the user

    :param phone_number_prefix: Prefix of the phone number from which the call will be made
    :type phone_number_prefix: :class:`String`
    :param length: Number of digits in the code, excluding the prefix
    :type length: :class:`Int32`
    """

    ID: typing.Literal["authenticationCodeTypeMissedCall"] = field(
        default="authenticationCodeTypeMissedCall", metadata={"alias": "@type"}
    )
    phone_number_prefix: String
    length: Int32


@dataclass(slots=True, kw_only=True)
class AuthenticationCodeTypeSms(BaseObject):
    """
    A digit-only authentication code is delivered via an SMS message to the specified phone number; non-official applications may not receive this type of code

    :param length: Length of the code
    :type length: :class:`Int32`
    """

    ID: typing.Literal["authenticationCodeTypeSms"] = field(
        default="authenticationCodeTypeSms", metadata={"alias": "@type"}
    )
    length: Int32


@dataclass(slots=True, kw_only=True)
class AuthenticationCodeTypeSmsPhrase(BaseObject):
    """
    An authentication code is a phrase from multiple words delivered via an SMS message to the specified phone number; non-official applications may not receive this type of code

    :param first_word: The first word of the phrase if known
    :type first_word: :class:`String`
    """

    ID: typing.Literal["authenticationCodeTypeSmsPhrase"] = field(
        default="authenticationCodeTypeSmsPhrase", metadata={"alias": "@type"}
    )
    first_word: String


@dataclass(slots=True, kw_only=True)
class AuthenticationCodeTypeSmsWord(BaseObject):
    """
    An authentication code is a word delivered via an SMS message to the specified phone number; non-official applications may not receive this type of code

    :param first_letter: The first letters of the word if known
    :type first_letter: :class:`String`
    """

    ID: typing.Literal["authenticationCodeTypeSmsWord"] = field(
        default="authenticationCodeTypeSmsWord", metadata={"alias": "@type"}
    )
    first_letter: String


@dataclass(slots=True, kw_only=True)
class AuthenticationCodeTypeTelegramMessage(BaseObject):
    """
    A digit-only authentication code is delivered via a private Telegram message, which can be viewed from another active session

    :param length: Length of the code
    :type length: :class:`Int32`
    """

    ID: typing.Literal["authenticationCodeTypeTelegramMessage"] = field(
        default="authenticationCodeTypeTelegramMessage", metadata={"alias": "@type"}
    )
    length: Int32


AuthenticationCodeType = typing.Union[
    AuthenticationCodeTypeCall,
    AuthenticationCodeTypeFirebaseAndroid,
    AuthenticationCodeTypeFirebaseIos,
    AuthenticationCodeTypeFlashCall,
    AuthenticationCodeTypeFragment,
    AuthenticationCodeTypeMissedCall,
    AuthenticationCodeTypeSms,
    AuthenticationCodeTypeSmsPhrase,
    AuthenticationCodeTypeSmsWord,
    AuthenticationCodeTypeTelegramMessage,
]


@dataclass(slots=True, kw_only=True)
class AuthorizationStateClosed(BaseObject):
    """
    TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to with error code 500. To continue working, one must create a new instance of the TDLib client
    """

    ID: typing.Literal["authorizationStateClosed"] = field(
        default="authorizationStateClosed", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class AuthorizationStateClosing(BaseObject):
    """
    TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after authorizationStateClosed has been received
    """

    ID: typing.Literal["authorizationStateClosing"] = field(
        default="authorizationStateClosing", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class AuthorizationStateLoggingOut(BaseObject):
    """
    The user is currently logging out
    """

    ID: typing.Literal["authorizationStateLoggingOut"] = field(
        default="authorizationStateLoggingOut", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class AuthorizationStateReady(BaseObject):
    """
    The user has been successfully authorized. TDLib is now ready to answer general requests
    """

    ID: typing.Literal["authorizationStateReady"] = field(
        default="authorizationStateReady", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class AuthorizationStateWaitCode(BaseObject):
    """
    TDLib needs the user's authentication code to authorize. Call checkAuthenticationCode to check the code

    :param code_info: Information about the authorization code that was sent
    :type code_info: :class:`AuthenticationCodeInfo`
    """

    ID: typing.Literal["authorizationStateWaitCode"] = field(
        default="authorizationStateWaitCode", metadata={"alias": "@type"}
    )
    code_info: AuthenticationCodeInfo


@dataclass(slots=True, kw_only=True)
class AuthorizationStateWaitEmailAddress(BaseObject):
    """
    TDLib needs the user's email address to authorize. Call setAuthenticationEmailAddress to provide the email address, or directly call checkAuthenticationEmailCode with Apple ID/Google ID token if allowed

    :param allow_apple_id: True, if authorization through Apple ID is allowed
    :type allow_apple_id: :class:`Bool`
    :param allow_google_id: True, if authorization through Google ID is allowed
    :type allow_google_id: :class:`Bool`
    """

    ID: typing.Literal["authorizationStateWaitEmailAddress"] = field(
        default="authorizationStateWaitEmailAddress", metadata={"alias": "@type"}
    )
    allow_apple_id: Bool = field(default=False)
    allow_google_id: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class AuthorizationStateWaitEmailCode(BaseObject):
    """
    TDLib needs the user's authentication code sent to an email address to authorize. Call checkAuthenticationEmailCode to provide the code

    :param code_info: Information about the sent authentication code
    :type code_info: :class:`EmailAddressAuthenticationCodeInfo`
    :param email_address_reset_state: Reset state of the email address; may be null if the email address can't be reset, defaults to None
    :type email_address_reset_state: :class:`EmailAddressResetState`, optional
    :param allow_apple_id: True, if authorization through Apple ID is allowed
    :type allow_apple_id: :class:`Bool`
    :param allow_google_id: True, if authorization through Google ID is allowed
    :type allow_google_id: :class:`Bool`
    """

    ID: typing.Literal["authorizationStateWaitEmailCode"] = field(
        default="authorizationStateWaitEmailCode", metadata={"alias": "@type"}
    )
    code_info: EmailAddressAuthenticationCodeInfo
    email_address_reset_state: typing.Optional[EmailAddressResetState] = field(default=None)
    allow_apple_id: Bool = field(default=False)
    allow_google_id: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class AuthorizationStateWaitOtherDeviceConfirmation(BaseObject):
    """
    The user needs to confirm authorization on another logged in device by scanning a QR code with the provided link

    :param link: A tg:// URL for the QR code. The link will be updated frequently
    :type link: :class:`String`
    """

    ID: typing.Literal["authorizationStateWaitOtherDeviceConfirmation"] = field(
        default="authorizationStateWaitOtherDeviceConfirmation", metadata={"alias": "@type"}
    )
    link: String


@dataclass(slots=True, kw_only=True)
class AuthorizationStateWaitPassword(BaseObject):
    """
    The user has been authorized, but needs to enter a 2-step verification password to start using the application. Call checkAuthenticationPassword to provide the password, or requestAuthenticationPasswordRecovery to recover the password, or deleteAccount to delete the account after a week

    :param recovery_email_address_pattern: Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent
    :type recovery_email_address_pattern: :class:`String`
    :param password_hint: Hint for the password; may be empty
    :type password_hint: :class:`String`
    :param has_recovery_email_address: True, if a recovery email address has been set up
    :type has_recovery_email_address: :class:`Bool`
    :param has_passport_data: True, if some Telegram Passport elements were saved
    :type has_passport_data: :class:`Bool`
    """

    ID: typing.Literal["authorizationStateWaitPassword"] = field(
        default="authorizationStateWaitPassword", metadata={"alias": "@type"}
    )
    recovery_email_address_pattern: String
    password_hint: String = field(default="")
    has_recovery_email_address: Bool = field(default=False)
    has_passport_data: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class AuthorizationStateWaitPhoneNumber(BaseObject):
    """
    TDLib needs the user's phone number to authorize. Call setAuthenticationPhoneNumber to provide the phone number, or use requestQrCodeAuthentication or checkAuthenticationBotToken for other authentication options
    """

    ID: typing.Literal["authorizationStateWaitPhoneNumber"] = field(
        default="authorizationStateWaitPhoneNumber", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class AuthorizationStateWaitRegistration(BaseObject):
    """
    The user is unregistered and need to accept terms of service and enter their first name and last name to finish registration. Call registerUser to accept the terms of service and provide the data

    :param terms_of_service: Telegram terms of service
    :type terms_of_service: :class:`TermsOfService`
    """

    ID: typing.Literal["authorizationStateWaitRegistration"] = field(
        default="authorizationStateWaitRegistration", metadata={"alias": "@type"}
    )
    terms_of_service: TermsOfService


@dataclass(slots=True, kw_only=True)
class AuthorizationStateWaitTdlibParameters(BaseObject):
    """
    Initialization parameters are needed. Call setTdlibParameters to provide them
    """

    ID: typing.Literal["authorizationStateWaitTdlibParameters"] = field(
        default="authorizationStateWaitTdlibParameters", metadata={"alias": "@type"}
    )


AuthorizationState = typing.Union[
    AuthorizationStateClosed,
    AuthorizationStateClosing,
    AuthorizationStateLoggingOut,
    AuthorizationStateReady,
    AuthorizationStateWaitCode,
    AuthorizationStateWaitEmailAddress,
    AuthorizationStateWaitEmailCode,
    AuthorizationStateWaitOtherDeviceConfirmation,
    AuthorizationStateWaitPassword,
    AuthorizationStateWaitPhoneNumber,
    AuthorizationStateWaitRegistration,
    AuthorizationStateWaitTdlibParameters,
]


@dataclass(slots=True, kw_only=True)
class AutoDownloadSettings(BaseObject):
    """
    Contains auto-download settings

    :param max_photo_file_size: The maximum size of a photo file to be auto-downloaded, in bytes
    :type max_photo_file_size: :class:`Int32`
    :param max_video_file_size: The maximum size of a video file to be auto-downloaded, in bytes
    :type max_video_file_size: :class:`Int53`
    :param max_other_file_size: The maximum size of other file types to be auto-downloaded, in bytes
    :type max_other_file_size: :class:`Int53`
    :param video_upload_bitrate: The maximum suggested bitrate for uploaded videos, in kbit/s
    :type video_upload_bitrate: :class:`Int32`
    :param is_auto_download_enabled: True, if the auto-download is enabled
    :type is_auto_download_enabled: :class:`Bool`
    :param preload_large_videos: True, if the beginning of video files needs to be preloaded for instant playback
    :type preload_large_videos: :class:`Bool`
    :param preload_next_audio: True, if the next audio track needs to be preloaded while the user is listening to an audio file
    :type preload_next_audio: :class:`Bool`
    :param preload_stories: True, if stories needs to be preloaded
    :type preload_stories: :class:`Bool`
    :param use_less_data_for_calls: True, if "use less data for calls" option needs to be enabled
    :type use_less_data_for_calls: :class:`Bool`
    """

    ID: typing.Literal["autoDownloadSettings"] = field(default="autoDownloadSettings", metadata={"alias": "@type"})
    max_photo_file_size: Int32
    max_video_file_size: Int53
    max_other_file_size: Int53
    video_upload_bitrate: Int32
    is_auto_download_enabled: Bool = field(default=False)
    preload_large_videos: Bool = field(default=False)
    preload_next_audio: Bool = field(default=False)
    preload_stories: Bool = field(default=False)
    use_less_data_for_calls: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class AutoDownloadSettingsPresets(BaseObject):
    """
    Contains auto-download settings presets for the current user

    :param low: Preset with lowest settings; expected to be used by default when roaming
    :type low: :class:`AutoDownloadSettings`
    :param medium: Preset with medium settings; expected to be used by default when using mobile data
    :type medium: :class:`AutoDownloadSettings`
    :param high: Preset with highest settings; expected to be used by default when connected on Wi-Fi
    :type high: :class:`AutoDownloadSettings`
    """

    ID: typing.Literal["autoDownloadSettingsPresets"] = field(
        default="autoDownloadSettingsPresets", metadata={"alias": "@type"}
    )
    low: AutoDownloadSettings
    medium: AutoDownloadSettings
    high: AutoDownloadSettings


@dataclass(slots=True, kw_only=True)
class AutosaveSettings(BaseObject):
    """
    Describes autosave settings

    :param private_chat_settings: Default autosave settings for private chats
    :type private_chat_settings: :class:`ScopeAutosaveSettings`
    :param group_settings: Default autosave settings for basic group and supergroup chats
    :type group_settings: :class:`ScopeAutosaveSettings`
    :param channel_settings: Default autosave settings for channel chats
    :type channel_settings: :class:`ScopeAutosaveSettings`
    :param exceptions: Autosave settings for specific chats
    :type exceptions: :class:`Vector[AutosaveSettingsException]`
    """

    ID: typing.Literal["autosaveSettings"] = field(default="autosaveSettings", metadata={"alias": "@type"})
    private_chat_settings: ScopeAutosaveSettings
    group_settings: ScopeAutosaveSettings
    channel_settings: ScopeAutosaveSettings
    exceptions: Vector[AutosaveSettingsException]


@dataclass(slots=True, kw_only=True)
class AutosaveSettingsException(BaseObject):
    """
    Contains autosave settings for a chat, which overrides default settings for the corresponding scope

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param settings: Autosave settings for the chat
    :type settings: :class:`ScopeAutosaveSettings`
    """

    ID: typing.Literal["autosaveSettingsException"] = field(
        default="autosaveSettingsException", metadata={"alias": "@type"}
    )
    chat_id: Int53
    settings: ScopeAutosaveSettings


@dataclass(slots=True, kw_only=True)
class AutosaveSettingsScopeChannelChats(BaseObject):
    """
    Autosave settings applied to all channel chats without chat-specific settings
    """

    ID: typing.Literal["autosaveSettingsScopeChannelChats"] = field(
        default="autosaveSettingsScopeChannelChats", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class AutosaveSettingsScopeChat(BaseObject):
    """
    Autosave settings applied to a chat

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    """

    ID: typing.Literal["autosaveSettingsScopeChat"] = field(
        default="autosaveSettingsScopeChat", metadata={"alias": "@type"}
    )
    chat_id: Int53


@dataclass(slots=True, kw_only=True)
class AutosaveSettingsScopeGroupChats(BaseObject):
    """
    Autosave settings applied to all basic group and supergroup chats without chat-specific settings
    """

    ID: typing.Literal["autosaveSettingsScopeGroupChats"] = field(
        default="autosaveSettingsScopeGroupChats", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class AutosaveSettingsScopePrivateChats(BaseObject):
    """
    Autosave settings applied to all private chats without chat-specific settings
    """

    ID: typing.Literal["autosaveSettingsScopePrivateChats"] = field(
        default="autosaveSettingsScopePrivateChats", metadata={"alias": "@type"}
    )


AutosaveSettingsScope = typing.Union[
    AutosaveSettingsScopeChannelChats,
    AutosaveSettingsScopeChat,
    AutosaveSettingsScopeGroupChats,
    AutosaveSettingsScopePrivateChats,
]


@dataclass(slots=True, kw_only=True)
class AvailableReaction(BaseObject):
    """
    Represents an available reaction

    :param type_: Type of the reaction
    :type type_: :class:`ReactionType`
    :param needs_premium: True, if Telegram Premium is needed to send the reaction
    :type needs_premium: :class:`Bool`
    """

    ID: typing.Literal["availableReaction"] = field(default="availableReaction", metadata={"alias": "@type"})
    type_: ReactionType = field(default=MISSING, metadata={"alias": "type"})
    needs_premium: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class AvailableReactions(BaseObject):
    """
    Represents a list of reactions that can be added to a message

    :param top_reactions: List of reactions to be shown at the top
    :type top_reactions: :class:`Vector[AvailableReaction]`
    :param recent_reactions: List of recently used reactions
    :type recent_reactions: :class:`Vector[AvailableReaction]`
    :param popular_reactions: List of popular reactions
    :type popular_reactions: :class:`Vector[AvailableReaction]`
    :param unavailability_reason: The reason why the current user can't add reactions to the message, despite some other users can; may be null if none, defaults to None
    :type unavailability_reason: :class:`ReactionUnavailabilityReason`, optional
    :param allow_custom_emoji: True, if any custom emoji reaction can be added by Telegram Premium subscribers
    :type allow_custom_emoji: :class:`Bool`
    :param are_tags: True, if the reactions will be tags and the message can be found by them
    :type are_tags: :class:`Bool`
    """

    ID: typing.Literal["availableReactions"] = field(default="availableReactions", metadata={"alias": "@type"})
    top_reactions: Vector[AvailableReaction]
    recent_reactions: Vector[AvailableReaction]
    popular_reactions: Vector[AvailableReaction]
    unavailability_reason: typing.Optional[ReactionUnavailabilityReason] = field(default=None)
    allow_custom_emoji: Bool = field(default=False)
    are_tags: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class Background(BaseObject):
    """
    Describes a chat background

    :param id: Unique background identifier
    :type id: :class:`Int64`
    :param name: Unique background name
    :type name: :class:`String`
    :param type_: Type of the background
    :type type_: :class:`BackgroundType`
    :param document: Document with the background; may be null. Null only for filled and chat theme backgrounds, defaults to None
    :type document: :class:`Document`, optional
    :param is_default: True, if this is one of default backgrounds
    :type is_default: :class:`Bool`
    :param is_dark: True, if the background is dark and is recommended to be used with dark theme
    :type is_dark: :class:`Bool`
    """

    ID: typing.Literal["background"] = field(default="background", metadata={"alias": "@type"})
    id: Int64
    name: String
    type_: BackgroundType = field(default=MISSING, metadata={"alias": "type"})
    document: typing.Optional[Document] = field(default=None)
    is_default: Bool = field(default=False)
    is_dark: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class BackgroundFillFreeformGradient(BaseObject):
    """
    Describes a freeform gradient fill of a background

    :param colors: A list of 3 or 4 colors of the freeform gradient in the RGB format
    :type colors: :class:`Vector[Int32]`
    """

    ID: typing.Literal["backgroundFillFreeformGradient"] = field(
        default="backgroundFillFreeformGradient", metadata={"alias": "@type"}
    )
    colors: Vector[Int32]


@dataclass(slots=True, kw_only=True)
class BackgroundFillGradient(BaseObject):
    """
    Describes a gradient fill of a background

    :param top_color: A top color of the background in the RGB format
    :type top_color: :class:`Int32`
    :param bottom_color: A bottom color of the background in the RGB format
    :type bottom_color: :class:`Int32`
    :param rotation_angle: Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be divisible by 45
    :type rotation_angle: :class:`Int32`
    """

    ID: typing.Literal["backgroundFillGradient"] = field(default="backgroundFillGradient", metadata={"alias": "@type"})
    top_color: Int32
    bottom_color: Int32
    rotation_angle: Int32


@dataclass(slots=True, kw_only=True)
class BackgroundFillSolid(BaseObject):
    """
    Describes a solid fill of a background

    :param color: A color of the background in the RGB format
    :type color: :class:`Int32`
    """

    ID: typing.Literal["backgroundFillSolid"] = field(default="backgroundFillSolid", metadata={"alias": "@type"})
    color: Int32


BackgroundFill = typing.Union[
    BackgroundFillFreeformGradient,
    BackgroundFillGradient,
    BackgroundFillSolid,
]


@dataclass(slots=True, kw_only=True)
class BackgroundTypeChatTheme(BaseObject):
    """
    A background from a chat theme; can be used only as a chat background in channels

    :param theme_name: Name of the chat theme
    :type theme_name: :class:`String`
    """

    ID: typing.Literal["backgroundTypeChatTheme"] = field(
        default="backgroundTypeChatTheme", metadata={"alias": "@type"}
    )
    theme_name: String


@dataclass(slots=True, kw_only=True)
class BackgroundTypeFill(BaseObject):
    """
    A filled background

    :param fill: The background fill
    :type fill: :class:`BackgroundFill`
    """

    ID: typing.Literal["backgroundTypeFill"] = field(default="backgroundTypeFill", metadata={"alias": "@type"})
    fill: BackgroundFill


@dataclass(slots=True, kw_only=True)
class BackgroundTypePattern(BaseObject):
    """
    A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern") pattern to be combined with the background fill chosen by the user

    :param fill: Fill of the background
    :type fill: :class:`BackgroundFill`
    :param intensity: Intensity of the pattern when it is shown above the filled background; 0-100
    :type intensity: :class:`Int32`
    :param is_inverted: True, if the background fill must be applied only to the pattern itself. All other pixels are black in this case. For dark themes only
    :type is_inverted: :class:`Bool`
    :param is_moving: True, if the background needs to be slightly moved when device is tilted
    :type is_moving: :class:`Bool`
    """

    ID: typing.Literal["backgroundTypePattern"] = field(default="backgroundTypePattern", metadata={"alias": "@type"})
    fill: BackgroundFill
    intensity: Int32
    is_inverted: Bool = field(default=False)
    is_moving: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class BackgroundTypeWallpaper(BaseObject):
    """
    A wallpaper in JPEG format

    :param is_blurred: True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12
    :type is_blurred: :class:`Bool`
    :param is_moving: True, if the background needs to be slightly moved when device is tilted
    :type is_moving: :class:`Bool`
    """

    ID: typing.Literal["backgroundTypeWallpaper"] = field(
        default="backgroundTypeWallpaper", metadata={"alias": "@type"}
    )
    is_blurred: Bool = field(default=False)
    is_moving: Bool = field(default=False)


BackgroundType = typing.Union[
    BackgroundTypeChatTheme,
    BackgroundTypeFill,
    BackgroundTypePattern,
    BackgroundTypeWallpaper,
]


@dataclass(slots=True, kw_only=True)
class Backgrounds(BaseObject):
    """
    Contains a list of backgrounds

    :param backgrounds: A list of backgrounds
    :type backgrounds: :class:`Vector[Background]`
    """

    ID: typing.Literal["backgrounds"] = field(default="backgrounds", metadata={"alias": "@type"})
    backgrounds: Vector[Background]


@dataclass(slots=True, kw_only=True)
class BankCardActionOpenUrl(BaseObject):
    """
    Describes an action associated with a bank card number

    :param text: Action text
    :type text: :class:`String`
    :param url: The URL to be opened
    :type url: :class:`String`
    """

    ID: typing.Literal["bankCardActionOpenUrl"] = field(default="bankCardActionOpenUrl", metadata={"alias": "@type"})
    text: String
    url: String


@dataclass(slots=True, kw_only=True)
class BankCardInfo(BaseObject):
    """
    Information about a bank card

    :param title: Title of the bank card description
    :type title: :class:`String`
    :param actions: Actions that can be done with the bank card number
    :type actions: :class:`Vector[BankCardActionOpenUrl]`
    """

    ID: typing.Literal["bankCardInfo"] = field(default="bankCardInfo", metadata={"alias": "@type"})
    title: String
    actions: Vector[BankCardActionOpenUrl]


@dataclass(slots=True, kw_only=True)
class BasicGroup(BaseObject):
    """
    Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users)

    :param id: Group identifier
    :type id: :class:`Int53`
    :param member_count: Number of members in the group
    :type member_count: :class:`Int32`
    :param status: Status of the current user in the group
    :type status: :class:`ChatMemberStatus`
    :param is_active: True, if the group is active
    :type is_active: :class:`Bool`
    :param upgraded_to_supergroup_id: Identifier of the supergroup to which this group was upgraded; 0 if none, defaults to None
    :type upgraded_to_supergroup_id: :class:`Int53`, optional
    """

    ID: typing.Literal["basicGroup"] = field(default="basicGroup", metadata={"alias": "@type"})
    id: Int53
    member_count: Int32
    status: ChatMemberStatus
    is_active: Bool = field(default=False)
    upgraded_to_supergroup_id: typing.Optional[Int53] = field(default=0)


@dataclass(slots=True, kw_only=True)
class BasicGroupFullInfo(BaseObject):
    """
    Contains full information about a basic group

    :param description: Group description. Updated only after the basic group is opened
    :type description: :class:`String`
    :param members: Group members
    :type members: :class:`Vector[ChatMember]`
    :param bot_commands: List of commands of bots in the group
    :type bot_commands: :class:`Vector[BotCommands]`
    :param photo: Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo, defaults to None
    :type photo: :class:`ChatPhoto`, optional
    :param invite_link: Primary invite link for this group; may be null. For chat administrators with can_invite_users right only. Updated only after the basic group is opened, defaults to None
    :type invite_link: :class:`ChatInviteLink`, optional
    :param can_hide_members: True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators after upgrading the basic group to a supergroup
    :type can_hide_members: :class:`Bool`
    :param can_toggle_aggressive_anti_spam: True, if aggressive anti-spam checks can be enabled or disabled in the supergroup after upgrading the basic group to a supergroup
    :type can_toggle_aggressive_anti_spam: :class:`Bool`
    :param creator_user_id: User identifier of the creator of the group; 0 if unknown, defaults to None
    :type creator_user_id: :class:`Int53`, optional
    """

    ID: typing.Literal["basicGroupFullInfo"] = field(default="basicGroupFullInfo", metadata={"alias": "@type"})
    description: String
    members: Vector[ChatMember]
    bot_commands: Vector[BotCommands]
    photo: typing.Optional[ChatPhoto] = field(default=None)
    invite_link: typing.Optional[ChatInviteLink] = field(default=None)
    can_hide_members: Bool = field(default=False)
    can_toggle_aggressive_anti_spam: Bool = field(default=False)
    creator_user_id: typing.Optional[Int53] = field(default=0)


@dataclass(slots=True, kw_only=True)
class Birthdate(BaseObject):
    """
    Represents a birthdate of a user

    :param day: Day of the month; 1-31
    :type day: :class:`Int32`
    :param month: Month of the year; 1-12
    :type month: :class:`Int32`
    :param year: Birth year; 0 if unknown, defaults to None
    :type year: :class:`Int32`, optional
    """

    ID: typing.Literal["birthdate"] = field(default="birthdate", metadata={"alias": "@type"})
    day: Int32
    month: Int32
    year: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class BlockListMain(BaseObject):
    """
    The main block list that disallows writing messages to the current user, receiving their status and photo, viewing of stories, and some other actions
    """

    ID: typing.Literal["blockListMain"] = field(default="blockListMain", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class BlockListStories(BaseObject):
    """
    The block list that disallows viewing of stories of the current user
    """

    ID: typing.Literal["blockListStories"] = field(default="blockListStories", metadata={"alias": "@type"})


BlockList = typing.Union[
    BlockListMain,
    BlockListStories,
]


@dataclass(slots=True, kw_only=True)
class BotCommand(BaseObject):
    """
    Represents a command supported by a bot

    :param command: Text of the bot command
    :type command: :class:`String`
    :param description: Description of the bot command
    :type description: :class:`String`
    """

    ID: typing.Literal["botCommand"] = field(default="botCommand", metadata={"alias": "@type"})
    command: String
    description: String


@dataclass(slots=True, kw_only=True)
class BotCommandScopeAllChatAdministrators(BaseObject):
    """
    A scope covering all group and supergroup chat administrators
    """

    ID: typing.Literal["botCommandScopeAllChatAdministrators"] = field(
        default="botCommandScopeAllChatAdministrators", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BotCommandScopeAllGroupChats(BaseObject):
    """
    A scope covering all group and supergroup chats
    """

    ID: typing.Literal["botCommandScopeAllGroupChats"] = field(
        default="botCommandScopeAllGroupChats", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BotCommandScopeAllPrivateChats(BaseObject):
    """
    A scope covering all private chats
    """

    ID: typing.Literal["botCommandScopeAllPrivateChats"] = field(
        default="botCommandScopeAllPrivateChats", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BotCommandScopeChat(BaseObject):
    """
    A scope covering all members of a chat

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    """

    ID: typing.Literal["botCommandScopeChat"] = field(default="botCommandScopeChat", metadata={"alias": "@type"})
    chat_id: Int53


@dataclass(slots=True, kw_only=True)
class BotCommandScopeChatAdministrators(BaseObject):
    """
    A scope covering all administrators of a chat

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    """

    ID: typing.Literal["botCommandScopeChatAdministrators"] = field(
        default="botCommandScopeChatAdministrators", metadata={"alias": "@type"}
    )
    chat_id: Int53


@dataclass(slots=True, kw_only=True)
class BotCommandScopeChatMember(BaseObject):
    """
    A scope covering a member of a chat

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param user_id: User identifier
    :type user_id: :class:`Int53`
    """

    ID: typing.Literal["botCommandScopeChatMember"] = field(
        default="botCommandScopeChatMember", metadata={"alias": "@type"}
    )
    chat_id: Int53
    user_id: Int53


@dataclass(slots=True, kw_only=True)
class BotCommandScopeDefault(BaseObject):
    """
    A scope covering all users
    """

    ID: typing.Literal["botCommandScopeDefault"] = field(default="botCommandScopeDefault", metadata={"alias": "@type"})


BotCommandScope = typing.Union[
    BotCommandScopeAllChatAdministrators,
    BotCommandScopeAllGroupChats,
    BotCommandScopeAllPrivateChats,
    BotCommandScopeChat,
    BotCommandScopeChatAdministrators,
    BotCommandScopeChatMember,
    BotCommandScopeDefault,
]


@dataclass(slots=True, kw_only=True)
class BotCommands(BaseObject):
    """
    Contains a list of bot commands

    :param bot_user_id: Bot's user identifier
    :type bot_user_id: :class:`Int53`
    :param commands: List of bot commands
    :type commands: :class:`Vector[BotCommand]`
    """

    ID: typing.Literal["botCommands"] = field(default="botCommands", metadata={"alias": "@type"})
    bot_user_id: Int53
    commands: Vector[BotCommand]


@dataclass(slots=True, kw_only=True)
class BotInfo(BaseObject):
    """
    Contains information about a bot

    :param short_description: The text that is shown on the bot's profile page and is sent together with the link when users share the bot
    :type short_description: :class:`String`
    :param description: The text shown in the chat with the bot if the chat is empty
    :type description: :class:`String`
    :param commands: List of the bot commands
    :type commands: :class:`Vector[BotCommand]`
    :param web_app_background_light_color: Default light background color for bot Web Apps; -1 if not specified
    :type web_app_background_light_color: :class:`Int32`
    :param web_app_background_dark_color: Default dark background color for bot Web Apps; -1 if not specified
    :type web_app_background_dark_color: :class:`Int32`
    :param web_app_header_light_color: Default light header color for bot Web Apps; -1 if not specified
    :type web_app_header_light_color: :class:`Int32`
    :param web_app_header_dark_color: Default dark header color for bot Web Apps; -1 if not specified
    :type web_app_header_dark_color: :class:`Int32`
    :param photo: Photo shown in the chat with the bot if the chat is empty; may be null, defaults to None
    :type photo: :class:`Photo`, optional
    :param animation: Animation shown in the chat with the bot if the chat is empty; may be null, defaults to None
    :type animation: :class:`Animation`, optional
    :param menu_button: Information about a button to show instead of the bot commands menu button; may be null if ordinary bot commands menu must be shown, defaults to None
    :type menu_button: :class:`BotMenuButton`, optional
    :param default_group_administrator_rights: Default administrator rights for adding the bot to basic group and supergroup chats; may be null, defaults to None
    :type default_group_administrator_rights: :class:`ChatAdministratorRights`, optional
    :param default_channel_administrator_rights: Default administrator rights for adding the bot to channels; may be null, defaults to None
    :type default_channel_administrator_rights: :class:`ChatAdministratorRights`, optional
    :param affiliate_program: Information about the affiliate program of the bot; may be null if none, defaults to None
    :type affiliate_program: :class:`AffiliateProgramInfo`, optional
    :param verification_parameters: Parameters of the verification that can be provided by the bot; may be null if none or the current user isn't the owner of the bot, defaults to None
    :type verification_parameters: :class:`BotVerificationParameters`, optional
    :param edit_commands_link: The internal link, which can be used to edit bot commands; may be null, defaults to None
    :type edit_commands_link: :class:`InternalLinkType`, optional
    :param edit_description_link: The internal link, which can be used to edit bot description; may be null, defaults to None
    :type edit_description_link: :class:`InternalLinkType`, optional
    :param edit_description_media_link: The internal link, which can be used to edit the photo or animation shown in the chat with the bot if the chat is empty; may be null, defaults to None
    :type edit_description_media_link: :class:`InternalLinkType`, optional
    :param edit_settings_link: The internal link, which can be used to edit bot settings; may be null, defaults to None
    :type edit_settings_link: :class:`InternalLinkType`, optional
    :param privacy_policy_url: The HTTP link to the privacy policy of the bot. If empty, then /privacy command must be used if supported by the bot. If the command isn't supported, then https://telegram.org/privacy-tpa must be opened
    :type privacy_policy_url: :class:`String`
    :param can_get_revenue_statistics: True, if the bot's revenue statistics are available to the current user
    :type can_get_revenue_statistics: :class:`Bool`
    :param can_manage_emoji_status: True, if the bot can manage emoji status of the current user
    :type can_manage_emoji_status: :class:`Bool`
    :param has_media_previews: True, if the bot has media previews
    :type has_media_previews: :class:`Bool`
    """

    ID: typing.Literal["botInfo"] = field(default="botInfo", metadata={"alias": "@type"})
    short_description: String
    description: String
    commands: Vector[BotCommand]
    web_app_background_light_color: Int32
    web_app_background_dark_color: Int32
    web_app_header_light_color: Int32
    web_app_header_dark_color: Int32
    photo: typing.Optional[Photo] = field(default=None)
    animation: typing.Optional[Animation] = field(default=None)
    menu_button: typing.Optional[BotMenuButton] = field(default=None)
    default_group_administrator_rights: typing.Optional[ChatAdministratorRights] = field(default=None)
    default_channel_administrator_rights: typing.Optional[ChatAdministratorRights] = field(default=None)
    affiliate_program: typing.Optional[AffiliateProgramInfo] = field(default=None)
    verification_parameters: typing.Optional[BotVerificationParameters] = field(default=None)
    edit_commands_link: typing.Optional[InternalLinkType] = field(default=None)
    edit_description_link: typing.Optional[InternalLinkType] = field(default=None)
    edit_description_media_link: typing.Optional[InternalLinkType] = field(default=None)
    edit_settings_link: typing.Optional[InternalLinkType] = field(default=None)
    privacy_policy_url: String = field(default="")
    can_get_revenue_statistics: Bool = field(default=False)
    can_manage_emoji_status: Bool = field(default=False)
    has_media_previews: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class BotMediaPreview(BaseObject):
    """
    Describes media previews of a bot

    :param date: Point in time (Unix timestamp) when the preview was added or changed last time
    :type date: :class:`Int32`
    :param content: Content of the preview
    :type content: :class:`StoryContent`
    """

    ID: typing.Literal["botMediaPreview"] = field(default="botMediaPreview", metadata={"alias": "@type"})
    date: Int32
    content: StoryContent


@dataclass(slots=True, kw_only=True)
class BotMediaPreviewInfo(BaseObject):
    """
    Contains a list of media previews of a bot for the given language and the list of languages for which the bot has dedicated previews

    :param previews: List of media previews
    :type previews: :class:`Vector[BotMediaPreview]`
    :param language_codes: List of language codes for which the bot has dedicated previews
    :type language_codes: :class:`Vector[String]`
    """

    ID: typing.Literal["botMediaPreviewInfo"] = field(default="botMediaPreviewInfo", metadata={"alias": "@type"})
    previews: Vector[BotMediaPreview]
    language_codes: Vector[String]


@dataclass(slots=True, kw_only=True)
class BotMediaPreviews(BaseObject):
    """
    Contains a list of media previews of a bot

    :param previews: List of media previews
    :type previews: :class:`Vector[BotMediaPreview]`
    """

    ID: typing.Literal["botMediaPreviews"] = field(default="botMediaPreviews", metadata={"alias": "@type"})
    previews: Vector[BotMediaPreview]


@dataclass(slots=True, kw_only=True)
class BotMenuButton(BaseObject):
    """
    Describes a button to be shown instead of bot commands menu button

    :param text: Text of the button
    :type text: :class:`String`
    :param url: URL of a Web App to open when the button is pressed. If the link is of the type internalLinkTypeWebApp, then it must be processed accordingly. Otherwise, the link must be passed to openWebApp
    :type url: :class:`String`
    """

    ID: typing.Literal["botMenuButton"] = field(default="botMenuButton", metadata={"alias": "@type"})
    text: String
    url: String


@dataclass(slots=True, kw_only=True)
class BotVerification(BaseObject):
    """
    Describes verification status provided by a bot

    :param bot_user_id: Identifier of the bot that provided the verification
    :type bot_user_id: :class:`Int53`
    :param icon_custom_emoji_id: Identifier of the custom emoji that is used as the verification sign
    :type icon_custom_emoji_id: :class:`Int64`
    :param custom_description: Custom description of verification reason set by the bot. Can contain only Mention, Hashtag, Cashtag, PhoneNumber, BankCardNumber, Url, and EmailAddress entities
    :type custom_description: :class:`FormattedText`
    """

    ID: typing.Literal["botVerification"] = field(default="botVerification", metadata={"alias": "@type"})
    bot_user_id: Int53
    icon_custom_emoji_id: Int64
    custom_description: FormattedText


@dataclass(slots=True, kw_only=True)
class BotVerificationParameters(BaseObject):
    """
    Describes parameters of verification that is provided by a bot

    :param icon_custom_emoji_id: Identifier of the custom emoji that is used as the verification sign
    :type icon_custom_emoji_id: :class:`Int64`
    :param organization_name: Name of the organization that provides verification
    :type organization_name: :class:`String`
    :param default_custom_description: Default custom description of verification reason to be used as placeholder in setMessageSenderBotVerification; may be null if none, defaults to None
    :type default_custom_description: :class:`FormattedText`, optional
    :param can_set_custom_description: True, if the bot is allowed to provide custom description for verified entities
    :type can_set_custom_description: :class:`Bool`
    """

    ID: typing.Literal["botVerificationParameters"] = field(
        default="botVerificationParameters", metadata={"alias": "@type"}
    )
    icon_custom_emoji_id: Int64
    organization_name: String
    default_custom_description: typing.Optional[FormattedText] = field(default=None)
    can_set_custom_description: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class BotWriteAccessAllowReasonAcceptedRequest(BaseObject):
    """
    The user accepted bot's request to send messages with allowBotToSendMessages
    """

    ID: typing.Literal["botWriteAccessAllowReasonAcceptedRequest"] = field(
        default="botWriteAccessAllowReasonAcceptedRequest", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BotWriteAccessAllowReasonAddedToAttachmentMenu(BaseObject):
    """
    The user added the bot to attachment or side menu using toggleBotIsAddedToAttachmentMenu
    """

    ID: typing.Literal["botWriteAccessAllowReasonAddedToAttachmentMenu"] = field(
        default="botWriteAccessAllowReasonAddedToAttachmentMenu", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BotWriteAccessAllowReasonConnectedWebsite(BaseObject):
    """
    The user connected a website by logging in using Telegram Login Widget on it

    :param domain_name: Domain name of the connected website
    :type domain_name: :class:`String`
    """

    ID: typing.Literal["botWriteAccessAllowReasonConnectedWebsite"] = field(
        default="botWriteAccessAllowReasonConnectedWebsite", metadata={"alias": "@type"}
    )
    domain_name: String


@dataclass(slots=True, kw_only=True)
class BotWriteAccessAllowReasonLaunchedWebApp(BaseObject):
    """
    The user launched a Web App using getWebAppLinkUrl

    :param web_app: Information about the Web App
    :type web_app: :class:`WebApp`
    """

    ID: typing.Literal["botWriteAccessAllowReasonLaunchedWebApp"] = field(
        default="botWriteAccessAllowReasonLaunchedWebApp", metadata={"alias": "@type"}
    )
    web_app: WebApp


BotWriteAccessAllowReason = typing.Union[
    BotWriteAccessAllowReasonAcceptedRequest,
    BotWriteAccessAllowReasonAddedToAttachmentMenu,
    BotWriteAccessAllowReasonConnectedWebsite,
    BotWriteAccessAllowReasonLaunchedWebApp,
]


@dataclass(slots=True, kw_only=True)
class BusinessAwayMessageScheduleAlways(BaseObject):
    """
    Send away messages always
    """

    ID: typing.Literal["businessAwayMessageScheduleAlways"] = field(
        default="businessAwayMessageScheduleAlways", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BusinessAwayMessageScheduleCustom(BaseObject):
    """
    Send away messages only in the specified time span

    :param start_date: Point in time (Unix timestamp) when the away messages will start to be sent
    :type start_date: :class:`Int32`
    :param end_date: Point in time (Unix timestamp) when the away messages will stop to be sent
    :type end_date: :class:`Int32`
    """

    ID: typing.Literal["businessAwayMessageScheduleCustom"] = field(
        default="businessAwayMessageScheduleCustom", metadata={"alias": "@type"}
    )
    start_date: Int32
    end_date: Int32


@dataclass(slots=True, kw_only=True)
class BusinessAwayMessageScheduleOutsideOfOpeningHours(BaseObject):
    """
    Send away messages outside of the business opening hours
    """

    ID: typing.Literal["businessAwayMessageScheduleOutsideOfOpeningHours"] = field(
        default="businessAwayMessageScheduleOutsideOfOpeningHours", metadata={"alias": "@type"}
    )


BusinessAwayMessageSchedule = typing.Union[
    BusinessAwayMessageScheduleAlways,
    BusinessAwayMessageScheduleCustom,
    BusinessAwayMessageScheduleOutsideOfOpeningHours,
]


@dataclass(slots=True, kw_only=True)
class BusinessAwayMessageSettings(BaseObject):
    """
    Describes settings for messages that are automatically sent by a Telegram Business account when it is away

    :param shortcut_id: Unique quick reply shortcut identifier for the away messages
    :type shortcut_id: :class:`Int32`
    :param recipients: Chosen recipients of the away messages
    :type recipients: :class:`BusinessRecipients`
    :param schedule: Settings used to check whether the current user is away
    :type schedule: :class:`BusinessAwayMessageSchedule`
    :param offline_only: True, if the messages must not be sent if the account was online in the last 10 minutes
    :type offline_only: :class:`Bool`
    """

    ID: typing.Literal["businessAwayMessageSettings"] = field(
        default="businessAwayMessageSettings", metadata={"alias": "@type"}
    )
    shortcut_id: Int32
    recipients: BusinessRecipients
    schedule: BusinessAwayMessageSchedule
    offline_only: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class BusinessBotManageBar(BaseObject):
    """
    Contains information about a business bot that manages the chat

    :param bot_user_id: User identifier of the bot
    :type bot_user_id: :class:`Int53`
    :param manage_url: URL to be opened to manage the bot
    :type manage_url: :class:`String`
    :param is_bot_paused: True, if the bot is paused. Use toggleBusinessConnectedBotChatIsPaused to change the value of the field
    :type is_bot_paused: :class:`Bool`
    :param can_bot_reply: True, if the bot can reply
    :type can_bot_reply: :class:`Bool`
    """

    ID: typing.Literal["businessBotManageBar"] = field(default="businessBotManageBar", metadata={"alias": "@type"})
    bot_user_id: Int53
    manage_url: String
    is_bot_paused: Bool = field(default=False)
    can_bot_reply: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class BusinessChatLink(BaseObject):
    """
    Contains information about a business chat link

    :param link: The HTTPS link
    :type link: :class:`String`
    :param text: Message draft text that will be added to the input field
    :type text: :class:`FormattedText`
    :param title: Link title
    :type title: :class:`String`
    :param view_count: Number of times the link was used
    :type view_count: :class:`Int32`
    """

    ID: typing.Literal["businessChatLink"] = field(default="businessChatLink", metadata={"alias": "@type"})
    link: String
    text: FormattedText
    title: String
    view_count: Int32


@dataclass(slots=True, kw_only=True)
class BusinessChatLinkInfo(BaseObject):
    """
    Contains information about a business chat link

    :param chat_id: Identifier of the private chat that created the link
    :type chat_id: :class:`Int53`
    :param text: Message draft text that must be added to the input field
    :type text: :class:`FormattedText`
    """

    ID: typing.Literal["businessChatLinkInfo"] = field(default="businessChatLinkInfo", metadata={"alias": "@type"})
    chat_id: Int53
    text: FormattedText


@dataclass(slots=True, kw_only=True)
class BusinessChatLinks(BaseObject):
    """
    Contains a list of business chat links created by the user

    :param links: List of links
    :type links: :class:`Vector[BusinessChatLink]`
    """

    ID: typing.Literal["businessChatLinks"] = field(default="businessChatLinks", metadata={"alias": "@type"})
    links: Vector[BusinessChatLink]


@dataclass(slots=True, kw_only=True)
class BusinessConnectedBot(BaseObject):
    """
    Describes a bot connected to a business account

    :param bot_user_id: User identifier of the bot
    :type bot_user_id: :class:`Int53`
    :param recipients: Private chats that will be accessible to the bot
    :type recipients: :class:`BusinessRecipients`
    :param can_reply: True, if the bot can send messages to the private chats; false otherwise
    :type can_reply: :class:`Bool`
    """

    ID: typing.Literal["businessConnectedBot"] = field(default="businessConnectedBot", metadata={"alias": "@type"})
    bot_user_id: Int53
    recipients: BusinessRecipients
    can_reply: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class BusinessConnection(BaseObject):
    """
    Describes a connection of the bot with a business account

    :param id: Unique identifier of the connection
    :type id: :class:`String`
    :param user_id: Identifier of the business user that created the connection
    :type user_id: :class:`Int53`
    :param user_chat_id: Chat identifier of the private chat with the user
    :type user_chat_id: :class:`Int53`
    :param date: Point in time (Unix timestamp) when the connection was established
    :type date: :class:`Int32`
    :param can_reply: True, if the bot can send messages to the connected user; false otherwise
    :type can_reply: :class:`Bool`
    :param is_enabled: True, if the connection is enabled; false otherwise
    :type is_enabled: :class:`Bool`
    """

    ID: typing.Literal["businessConnection"] = field(default="businessConnection", metadata={"alias": "@type"})
    id: String
    user_id: Int53
    user_chat_id: Int53
    date: Int32
    can_reply: Bool = field(default=False)
    is_enabled: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class BusinessFeatureAccountLinks(BaseObject):
    """
    The ability to create links to the business account with predefined message text
    """

    ID: typing.Literal["businessFeatureAccountLinks"] = field(
        default="businessFeatureAccountLinks", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BusinessFeatureAwayMessage(BaseObject):
    """
    The ability to set up an away message
    """

    ID: typing.Literal["businessFeatureAwayMessage"] = field(
        default="businessFeatureAwayMessage", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BusinessFeatureBots(BaseObject):
    """
    The ability to connect a bot to the account
    """

    ID: typing.Literal["businessFeatureBots"] = field(default="businessFeatureBots", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class BusinessFeatureChatFolderTags(BaseObject):
    """
    The ability to display folder names for each chat in the chat list
    """

    ID: typing.Literal["businessFeatureChatFolderTags"] = field(
        default="businessFeatureChatFolderTags", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BusinessFeatureEmojiStatus(BaseObject):
    """
    The ability to show an emoji status along with the business name
    """

    ID: typing.Literal["businessFeatureEmojiStatus"] = field(
        default="businessFeatureEmojiStatus", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BusinessFeatureGreetingMessage(BaseObject):
    """
    The ability to set up a greeting message
    """

    ID: typing.Literal["businessFeatureGreetingMessage"] = field(
        default="businessFeatureGreetingMessage", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BusinessFeatureLocation(BaseObject):
    """
    The ability to set location
    """

    ID: typing.Literal["businessFeatureLocation"] = field(
        default="businessFeatureLocation", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BusinessFeatureOpeningHours(BaseObject):
    """
    The ability to set opening hours
    """

    ID: typing.Literal["businessFeatureOpeningHours"] = field(
        default="businessFeatureOpeningHours", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BusinessFeatureQuickReplies(BaseObject):
    """
    The ability to use quick replies
    """

    ID: typing.Literal["businessFeatureQuickReplies"] = field(
        default="businessFeatureQuickReplies", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BusinessFeatureStartPage(BaseObject):
    """
    The ability to customize start page
    """

    ID: typing.Literal["businessFeatureStartPage"] = field(
        default="businessFeatureStartPage", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class BusinessFeatureUpgradedStories(BaseObject):
    """
    Allowed to use many additional features for stories
    """

    ID: typing.Literal["businessFeatureUpgradedStories"] = field(
        default="businessFeatureUpgradedStories", metadata={"alias": "@type"}
    )


BusinessFeature = typing.Union[
    BusinessFeatureAccountLinks,
    BusinessFeatureAwayMessage,
    BusinessFeatureBots,
    BusinessFeatureChatFolderTags,
    BusinessFeatureEmojiStatus,
    BusinessFeatureGreetingMessage,
    BusinessFeatureLocation,
    BusinessFeatureOpeningHours,
    BusinessFeatureQuickReplies,
    BusinessFeatureStartPage,
    BusinessFeatureUpgradedStories,
]


@dataclass(slots=True, kw_only=True)
class BusinessFeaturePromotionAnimation(BaseObject):
    """
    Describes a promotion animation for a Business feature

    :param feature: Business feature
    :type feature: :class:`BusinessFeature`
    :param animation: Promotion animation for the feature
    :type animation: :class:`Animation`
    """

    ID: typing.Literal["businessFeaturePromotionAnimation"] = field(
        default="businessFeaturePromotionAnimation", metadata={"alias": "@type"}
    )
    feature: BusinessFeature
    animation: Animation


@dataclass(slots=True, kw_only=True)
class BusinessFeatures(BaseObject):
    """
    Contains information about features, available to Business user accounts

    :param features: The list of available business features
    :type features: :class:`Vector[BusinessFeature]`
    """

    ID: typing.Literal["businessFeatures"] = field(default="businessFeatures", metadata={"alias": "@type"})
    features: Vector[BusinessFeature]


@dataclass(slots=True, kw_only=True)
class BusinessGreetingMessageSettings(BaseObject):
    """
    Describes settings for greeting messages that are automatically sent by a Telegram Business account as response to incoming messages in an inactive private chat

    :param shortcut_id: Unique quick reply shortcut identifier for the greeting messages
    :type shortcut_id: :class:`Int32`
    :param recipients: Chosen recipients of the greeting messages
    :type recipients: :class:`BusinessRecipients`
    :param inactivity_days: The number of days after which a chat will be considered as inactive; currently, must be on of 7, 14, 21, or 28
    :type inactivity_days: :class:`Int32`
    """

    ID: typing.Literal["businessGreetingMessageSettings"] = field(
        default="businessGreetingMessageSettings", metadata={"alias": "@type"}
    )
    shortcut_id: Int32
    recipients: BusinessRecipients
    inactivity_days: Int32


@dataclass(slots=True, kw_only=True)
class BusinessInfo(BaseObject):
    """
    Contains information about a Telegram Business account

    :param location: Location of the business; may be null if none, defaults to None
    :type location: :class:`BusinessLocation`, optional
    :param opening_hours: Opening hours of the business; may be null if none. The hours are guaranteed to be valid and has already been split by week days, defaults to None
    :type opening_hours: :class:`BusinessOpeningHours`, optional
    :param local_opening_hours: Opening hours of the business in the local time; may be null if none. The hours are guaranteed to be valid and has already been split by week days. Local time zone identifier will be empty. An updateUserFullInfo update is not triggered when value of this field changes, defaults to None
    :type local_opening_hours: :class:`BusinessOpeningHours`, optional
    :param greeting_message_settings: The greeting message; may be null if none or the Business account is not of the current user, defaults to None
    :type greeting_message_settings: :class:`BusinessGreetingMessageSettings`, optional
    :param away_message_settings: The away message; may be null if none or the Business account is not of the current user, defaults to None
    :type away_message_settings: :class:`BusinessAwayMessageSettings`, optional
    :param start_page: Information about start page of the account; may be null if none, defaults to None
    :type start_page: :class:`BusinessStartPage`, optional
    :param next_open_in: Time left before the business will open the next time, in seconds; 0 if unknown. An updateUserFullInfo update is not triggered when value of this field changes, defaults to None
    :type next_open_in: :class:`Int32`, optional
    :param next_close_in: Time left before the business will close the next time, in seconds; 0 if unknown. An updateUserFullInfo update is not triggered when value of this field changes, defaults to None
    :type next_close_in: :class:`Int32`, optional
    """

    ID: typing.Literal["businessInfo"] = field(default="businessInfo", metadata={"alias": "@type"})
    location: typing.Optional[BusinessLocation] = field(default=None)
    opening_hours: typing.Optional[BusinessOpeningHours] = field(default=None)
    local_opening_hours: typing.Optional[BusinessOpeningHours] = field(default=None)
    greeting_message_settings: typing.Optional[BusinessGreetingMessageSettings] = field(default=None)
    away_message_settings: typing.Optional[BusinessAwayMessageSettings] = field(default=None)
    start_page: typing.Optional[BusinessStartPage] = field(default=None)
    next_open_in: typing.Optional[Int32] = field(default=0)
    next_close_in: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class BusinessLocation(BaseObject):
    """
    Represents a location of a business

    :param address: Location address; 1-96 characters
    :type address: :class:`String`
    :param location: The location; may be null if not specified, defaults to None
    :type location: :class:`Location`, optional
    """

    ID: typing.Literal["businessLocation"] = field(default="businessLocation", metadata={"alias": "@type"})
    address: String = field(default=MISSING, metadata={"min_length": 1, "max_length": 96})
    location: typing.Optional[Location] = field(default=None)


@dataclass(slots=True, kw_only=True)
class BusinessMessage(BaseObject):
    """
    Describes a message from a business account as received by a bot

    :param message: The message
    :type message: :class:`Message`
    :param reply_to_message: Message that is replied by the message in the same chat; may be null if none, defaults to None
    :type reply_to_message: :class:`Message`, optional
    """

    ID: typing.Literal["businessMessage"] = field(default="businessMessage", metadata={"alias": "@type"})
    message: Message
    reply_to_message: typing.Optional[Message] = field(default=None)


@dataclass(slots=True, kw_only=True)
class BusinessMessages(BaseObject):
    """
    Contains a list of messages from a business account as received by a bot

    :param messages: List of business messages
    :type messages: :class:`Vector[BusinessMessage]`
    """

    ID: typing.Literal["businessMessages"] = field(default="businessMessages", metadata={"alias": "@type"})
    messages: Vector[BusinessMessage]


@dataclass(slots=True, kw_only=True)
class BusinessOpeningHours(BaseObject):
    """
    Describes opening hours of a business

    :param time_zone_id: Unique time zone identifier
    :type time_zone_id: :class:`String`
    :param opening_hours: Intervals of the time when the business is open
    :type opening_hours: :class:`Vector[BusinessOpeningHoursInterval]`
    """

    ID: typing.Literal["businessOpeningHours"] = field(default="businessOpeningHours", metadata={"alias": "@type"})
    time_zone_id: String
    opening_hours: Vector[BusinessOpeningHoursInterval]


@dataclass(slots=True, kw_only=True)
class BusinessOpeningHoursInterval(BaseObject):
    """
    Describes an interval of time when the business is open

    :param start_minute: The minute's sequence number in a week, starting on Monday, marking the start of the time interval during which the business is open; 0-7*24*60
    :type start_minute: :class:`Int32`
    :param end_minute: The minute's sequence number in a week, starting on Monday, marking the end of the time interval during which the business is open; 1-8*24*60
    :type end_minute: :class:`Int32`
    """

    ID: typing.Literal["businessOpeningHoursInterval"] = field(
        default="businessOpeningHoursInterval", metadata={"alias": "@type"}
    )
    start_minute: Int32
    end_minute: Int32


@dataclass(slots=True, kw_only=True)
class BusinessRecipients(BaseObject):
    """
    Describes private chats chosen for automatic interaction with a business

    :param chat_ids: Identifiers of selected private chats
    :type chat_ids: :class:`Vector[Int53]`
    :param excluded_chat_ids: Identifiers of private chats that are always excluded; for businessConnectedBot only
    :type excluded_chat_ids: :class:`Vector[Int53]`
    :param select_existing_chats: True, if all existing private chats are selected
    :type select_existing_chats: :class:`Bool`
    :param select_new_chats: True, if all new private chats are selected
    :type select_new_chats: :class:`Bool`
    :param select_contacts: True, if all private chats with contacts are selected
    :type select_contacts: :class:`Bool`
    :param select_non_contacts: True, if all private chats with non-contacts are selected
    :type select_non_contacts: :class:`Bool`
    :param exclude_selected: If true, then all private chats except the selected are chosen. Otherwise, only the selected chats are chosen
    :type exclude_selected: :class:`Bool`
    """

    ID: typing.Literal["businessRecipients"] = field(default="businessRecipients", metadata={"alias": "@type"})
    chat_ids: Vector[Int53]
    excluded_chat_ids: Vector[Int53]
    select_existing_chats: Bool = field(default=False)
    select_new_chats: Bool = field(default=False)
    select_contacts: Bool = field(default=False)
    select_non_contacts: Bool = field(default=False)
    exclude_selected: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class BusinessStartPage(BaseObject):
    """
    Describes settings for a business account start page

    :param title: Title text of the start page
    :type title: :class:`String`
    :param message: Message text of the start page
    :type message: :class:`String`
    :param sticker: Greeting sticker of the start page; may be null if none, defaults to None
    :type sticker: :class:`Sticker`, optional
    """

    ID: typing.Literal["businessStartPage"] = field(default="businessStartPage", metadata={"alias": "@type"})
    title: String
    message: String
    sticker: typing.Optional[Sticker] = field(default=None)


@dataclass(slots=True, kw_only=True)
class Call(BaseObject):
    """
    Describes a call

    :param id: Call identifier, not persistent
    :type id: :class:`Int32`
    :param user_id: User identifier of the other call participant
    :type user_id: :class:`Int53`
    :param state: Call state
    :type state: :class:`CallState`
    :param is_outgoing: True, if the call is outgoing
    :type is_outgoing: :class:`Bool`
    :param is_video: True, if the call is a video call
    :type is_video: :class:`Bool`
    :param group_call_id: Identifier of the group call associated with the call; 0 if the group call isn't created yet. The group call can be received through the method getGroupCall
    :type group_call_id: :class:`Int32`
    """

    ID: typing.Literal["call"] = field(default="call", metadata={"alias": "@type"})
    id: Int32
    user_id: Int53
    state: CallState
    is_outgoing: Bool = field(default=False)
    is_video: Bool = field(default=False)
    group_call_id: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class CallDiscardReasonAllowGroupCall(BaseObject):
    """
    The call was ended because it has been used successfully to transfer private encryption key for the associated group call

    :param encrypted_group_call_key: Encrypted using the call private key encryption key for the associated group call
    :type encrypted_group_call_key: :class:`Bytes`
    """

    ID: typing.Literal["callDiscardReasonAllowGroupCall"] = field(
        default="callDiscardReasonAllowGroupCall", metadata={"alias": "@type"}
    )
    encrypted_group_call_key: Bytes


@dataclass(slots=True, kw_only=True)
class CallDiscardReasonDeclined(BaseObject):
    """
    The call was ended before the conversation started. It was declined by the other party
    """

    ID: typing.Literal["callDiscardReasonDeclined"] = field(
        default="callDiscardReasonDeclined", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CallDiscardReasonDisconnected(BaseObject):
    """
    The call was ended during the conversation because the users were disconnected
    """

    ID: typing.Literal["callDiscardReasonDisconnected"] = field(
        default="callDiscardReasonDisconnected", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CallDiscardReasonEmpty(BaseObject):
    """
    The call wasn't discarded, or the reason is unknown
    """

    ID: typing.Literal["callDiscardReasonEmpty"] = field(default="callDiscardReasonEmpty", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class CallDiscardReasonHungUp(BaseObject):
    """
    The call was ended because one of the parties hung up
    """

    ID: typing.Literal["callDiscardReasonHungUp"] = field(
        default="callDiscardReasonHungUp", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CallDiscardReasonMissed(BaseObject):
    """
    The call was ended before the conversation started. It was canceled by the caller or missed by the other party
    """

    ID: typing.Literal["callDiscardReasonMissed"] = field(
        default="callDiscardReasonMissed", metadata={"alias": "@type"}
    )


CallDiscardReason = typing.Union[
    CallDiscardReasonAllowGroupCall,
    CallDiscardReasonDeclined,
    CallDiscardReasonDisconnected,
    CallDiscardReasonEmpty,
    CallDiscardReasonHungUp,
    CallDiscardReasonMissed,
]


@dataclass(slots=True, kw_only=True)
class CallId(BaseObject):
    """
    Contains the call identifier

    :param id: Call identifier
    :type id: :class:`Int32`
    """

    ID: typing.Literal["callId"] = field(default="callId", metadata={"alias": "@type"})
    id: Int32


@dataclass(slots=True, kw_only=True)
class CallProblemDistortedSpeech(BaseObject):
    """
    The speech was distorted
    """

    ID: typing.Literal["callProblemDistortedSpeech"] = field(
        default="callProblemDistortedSpeech", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CallProblemDistortedVideo(BaseObject):
    """
    The video was distorted
    """

    ID: typing.Literal["callProblemDistortedVideo"] = field(
        default="callProblemDistortedVideo", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CallProblemDropped(BaseObject):
    """
    The call ended unexpectedly
    """

    ID: typing.Literal["callProblemDropped"] = field(default="callProblemDropped", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class CallProblemEcho(BaseObject):
    """
    The user heard their own voice
    """

    ID: typing.Literal["callProblemEcho"] = field(default="callProblemEcho", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class CallProblemInterruptions(BaseObject):
    """
    The other side kept disappearing
    """

    ID: typing.Literal["callProblemInterruptions"] = field(
        default="callProblemInterruptions", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CallProblemNoise(BaseObject):
    """
    The user heard background noise
    """

    ID: typing.Literal["callProblemNoise"] = field(default="callProblemNoise", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class CallProblemPixelatedVideo(BaseObject):
    """
    The video was pixelated
    """

    ID: typing.Literal["callProblemPixelatedVideo"] = field(
        default="callProblemPixelatedVideo", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CallProblemSilentLocal(BaseObject):
    """
    The user couldn't hear the other side
    """

    ID: typing.Literal["callProblemSilentLocal"] = field(default="callProblemSilentLocal", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class CallProblemSilentRemote(BaseObject):
    """
    The other side couldn't hear the user
    """

    ID: typing.Literal["callProblemSilentRemote"] = field(
        default="callProblemSilentRemote", metadata={"alias": "@type"}
    )


CallProblem = typing.Union[
    CallProblemDistortedSpeech,
    CallProblemDistortedVideo,
    CallProblemDropped,
    CallProblemEcho,
    CallProblemInterruptions,
    CallProblemNoise,
    CallProblemPixelatedVideo,
    CallProblemSilentLocal,
    CallProblemSilentRemote,
]


@dataclass(slots=True, kw_only=True)
class CallProtocol(BaseObject):
    """
    Specifies the supported call protocols

    :param min_layer: The minimum supported API layer; use 65
    :type min_layer: :class:`Int32`
    :param max_layer: The maximum supported API layer; use 92
    :type max_layer: :class:`Int32`
    :param library_versions: List of supported tgcalls versions
    :type library_versions: :class:`Vector[String]`
    :param udp_p2p: True, if UDP peer-to-peer connections are supported
    :type udp_p2p: :class:`Bool`
    :param udp_reflector: True, if connection through UDP reflectors is supported
    :type udp_reflector: :class:`Bool`
    """

    ID: typing.Literal["callProtocol"] = field(default="callProtocol", metadata={"alias": "@type"})
    min_layer: Int32
    max_layer: Int32
    library_versions: Vector[String]
    udp_p2p: Bool = field(default=False)
    udp_reflector: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class CallServer(BaseObject):
    """
    Describes a server for relaying call data

    :param id: Server identifier
    :type id: :class:`Int64`
    :param ip_address: Server IPv4 address
    :type ip_address: :class:`String`
    :param ipv6_address: Server IPv6 address
    :type ipv6_address: :class:`String`
    :param port: Server port number
    :type port: :class:`Int32`
    :param type_: Server type
    :type type_: :class:`CallServerType`
    """

    ID: typing.Literal["callServer"] = field(default="callServer", metadata={"alias": "@type"})
    id: Int64
    ip_address: String
    ipv6_address: String
    port: Int32
    type_: CallServerType = field(default=MISSING, metadata={"alias": "type"})


@dataclass(slots=True, kw_only=True)
class CallServerTypeTelegramReflector(BaseObject):
    """
    A Telegram call reflector

    :param peer_tag: A peer tag to be used with the reflector
    :type peer_tag: :class:`Bytes`
    :param is_tcp: True, if the server uses TCP instead of UDP
    :type is_tcp: :class:`Bool`
    """

    ID: typing.Literal["callServerTypeTelegramReflector"] = field(
        default="callServerTypeTelegramReflector", metadata={"alias": "@type"}
    )
    peer_tag: Bytes
    is_tcp: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class CallServerTypeWebrtc(BaseObject):
    """
    A WebRTC server

    :param username: Username to be used for authentication
    :type username: :class:`String`
    :param password: Authentication password
    :type password: :class:`String`
    :param supports_turn: True, if the server supports TURN
    :type supports_turn: :class:`Bool`
    :param supports_stun: True, if the server supports STUN
    :type supports_stun: :class:`Bool`
    """

    ID: typing.Literal["callServerTypeWebrtc"] = field(default="callServerTypeWebrtc", metadata={"alias": "@type"})
    username: String
    password: String
    supports_turn: Bool = field(default=False)
    supports_stun: Bool = field(default=False)


CallServerType = typing.Union[
    CallServerTypeTelegramReflector,
    CallServerTypeWebrtc,
]


@dataclass(slots=True, kw_only=True)
class CallStateDiscarded(BaseObject):
    """
    The call has ended successfully

    :param reason: The reason why the call has ended
    :type reason: :class:`CallDiscardReason`
    :param need_rating: True, if the call rating must be sent to the server
    :type need_rating: :class:`Bool`
    :param need_debug_information: True, if the call debug information must be sent to the server
    :type need_debug_information: :class:`Bool`
    :param need_log: True, if the call log must be sent to the server
    :type need_log: :class:`Bool`
    """

    ID: typing.Literal["callStateDiscarded"] = field(default="callStateDiscarded", metadata={"alias": "@type"})
    reason: CallDiscardReason
    need_rating: Bool = field(default=False)
    need_debug_information: Bool = field(default=False)
    need_log: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class CallStateError(BaseObject):
    """
    The call has ended with an error

    :param error: Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout
    :type error: :class:`Error`
    """

    ID: typing.Literal["callStateError"] = field(default="callStateError", metadata={"alias": "@type"})
    error: Error


@dataclass(slots=True, kw_only=True)
class CallStateExchangingKeys(BaseObject):
    """
    The call has been answered and encryption keys are being exchanged
    """

    ID: typing.Literal["callStateExchangingKeys"] = field(
        default="callStateExchangingKeys", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CallStateHangingUp(BaseObject):
    """
    The call is hanging up after discardCall has been called
    """

    ID: typing.Literal["callStateHangingUp"] = field(default="callStateHangingUp", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class CallStatePending(BaseObject):
    """
    The call is pending, waiting to be accepted by a user

    :param is_created: True, if the call has already been created by the server
    :type is_created: :class:`Bool`
    :param is_received: True, if the call has already been received by the other party
    :type is_received: :class:`Bool`
    """

    ID: typing.Literal["callStatePending"] = field(default="callStatePending", metadata={"alias": "@type"})
    is_created: Bool = field(default=False)
    is_received: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class CallStateReady(BaseObject):
    """
    The call is ready to use

    :param protocol: Call protocols supported by the other call participant
    :type protocol: :class:`CallProtocol`
    :param servers: List of available call servers
    :type servers: :class:`Vector[CallServer]`
    :param config: A JSON-encoded call config
    :type config: :class:`String`
    :param encryption_key: Call encryption key
    :type encryption_key: :class:`Bytes`
    :param emojis: Encryption key fingerprint represented as 4 emoji
    :type emojis: :class:`Vector[String]`
    :param custom_parameters: Custom JSON-encoded call parameters to be passed to tgcalls
    :type custom_parameters: :class:`String`
    :param allow_p2p: True, if peer-to-peer connection is allowed by users privacy settings
    :type allow_p2p: :class:`Bool`
    """

    ID: typing.Literal["callStateReady"] = field(default="callStateReady", metadata={"alias": "@type"})
    protocol: CallProtocol
    servers: Vector[CallServer]
    config: String
    encryption_key: Bytes
    emojis: Vector[String]
    custom_parameters: String
    allow_p2p: Bool = field(default=False)


CallState = typing.Union[
    CallStateDiscarded,
    CallStateError,
    CallStateExchangingKeys,
    CallStateHangingUp,
    CallStatePending,
    CallStateReady,
]


@dataclass(slots=True, kw_only=True)
class CallbackQueryAnswer(BaseObject):
    """
    Contains a bot's answer to a callback query

    :param text: Text of the answer
    :type text: :class:`String`
    :param url: URL to be opened
    :type url: :class:`String`
    :param show_alert: True, if an alert must be shown to the user instead of a toast notification
    :type show_alert: :class:`Bool`
    """

    ID: typing.Literal["callbackQueryAnswer"] = field(default="callbackQueryAnswer", metadata={"alias": "@type"})
    text: String
    url: String
    show_alert: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class CallbackQueryPayloadData(BaseObject):
    """
    The payload for a general callback button

    :param data: Data that was attached to the callback button
    :type data: :class:`Bytes`
    """

    ID: typing.Literal["callbackQueryPayloadData"] = field(
        default="callbackQueryPayloadData", metadata={"alias": "@type"}
    )
    data: Bytes


@dataclass(slots=True, kw_only=True)
class CallbackQueryPayloadDataWithPassword(BaseObject):
    """
    The payload for a callback button requiring password

    :param password: The 2-step verification password for the current user
    :type password: :class:`String`
    :param data: Data that was attached to the callback button
    :type data: :class:`Bytes`
    """

    ID: typing.Literal["callbackQueryPayloadDataWithPassword"] = field(
        default="callbackQueryPayloadDataWithPassword", metadata={"alias": "@type"}
    )
    password: String
    data: Bytes


@dataclass(slots=True, kw_only=True)
class CallbackQueryPayloadGame(BaseObject):
    """
    The payload for a game callback button

    :param game_short_name: A short name of the game that was attached to the callback button
    :type game_short_name: :class:`String`
    """

    ID: typing.Literal["callbackQueryPayloadGame"] = field(
        default="callbackQueryPayloadGame", metadata={"alias": "@type"}
    )
    game_short_name: String


CallbackQueryPayload = typing.Union[
    CallbackQueryPayloadData,
    CallbackQueryPayloadDataWithPassword,
    CallbackQueryPayloadGame,
]


@dataclass(slots=True, kw_only=True)
class CanSendMessageToUserResultOk(BaseObject):
    """
    The user can be messaged
    """

    ID: typing.Literal["canSendMessageToUserResultOk"] = field(
        default="canSendMessageToUserResultOk", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CanSendMessageToUserResultUserIsDeleted(BaseObject):
    """
    The user can't be messaged, because they are deleted or unknown
    """

    ID: typing.Literal["canSendMessageToUserResultUserIsDeleted"] = field(
        default="canSendMessageToUserResultUserIsDeleted", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CanSendMessageToUserResultUserRestrictsNewChats(BaseObject):
    """
    The user can't be messaged, because they restrict new chats with non-contacts
    """

    ID: typing.Literal["canSendMessageToUserResultUserRestrictsNewChats"] = field(
        default="canSendMessageToUserResultUserRestrictsNewChats", metadata={"alias": "@type"}
    )


CanSendMessageToUserResult = typing.Union[
    CanSendMessageToUserResultOk,
    CanSendMessageToUserResultUserIsDeleted,
    CanSendMessageToUserResultUserRestrictsNewChats,
]


@dataclass(slots=True, kw_only=True)
class CanSendStoryResultActiveStoryLimitExceeded(BaseObject):
    """
    The limit for the number of active stories exceeded. The user can buy Telegram Premium, delete an active story, or wait for the oldest story to expire
    """

    ID: typing.Literal["canSendStoryResultActiveStoryLimitExceeded"] = field(
        default="canSendStoryResultActiveStoryLimitExceeded", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CanSendStoryResultBoostNeeded(BaseObject):
    """
    The chat must be boosted first by Telegram Premium subscribers to post more stories. Call getChatBoostStatus to get current boost status of the chat
    """

    ID: typing.Literal["canSendStoryResultBoostNeeded"] = field(
        default="canSendStoryResultBoostNeeded", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CanSendStoryResultMonthlyLimitExceeded(BaseObject):
    """
    The monthly limit for the number of posted stories exceeded. The user needs to buy Telegram Premium or wait specified time

    :param retry_after: Time left before the user can send the next story
    :type retry_after: :class:`Int32`
    """

    ID: typing.Literal["canSendStoryResultMonthlyLimitExceeded"] = field(
        default="canSendStoryResultMonthlyLimitExceeded", metadata={"alias": "@type"}
    )
    retry_after: Int32


@dataclass(slots=True, kw_only=True)
class CanSendStoryResultOk(BaseObject):
    """
    A story can be sent
    """

    ID: typing.Literal["canSendStoryResultOk"] = field(default="canSendStoryResultOk", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class CanSendStoryResultPremiumNeeded(BaseObject):
    """
    The user must subscribe to Telegram Premium to be able to post stories
    """

    ID: typing.Literal["canSendStoryResultPremiumNeeded"] = field(
        default="canSendStoryResultPremiumNeeded", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CanSendStoryResultWeeklyLimitExceeded(BaseObject):
    """
    The weekly limit for the number of posted stories exceeded. The user needs to buy Telegram Premium or wait specified time

    :param retry_after: Time left before the user can send the next story
    :type retry_after: :class:`Int32`
    """

    ID: typing.Literal["canSendStoryResultWeeklyLimitExceeded"] = field(
        default="canSendStoryResultWeeklyLimitExceeded", metadata={"alias": "@type"}
    )
    retry_after: Int32


CanSendStoryResult = typing.Union[
    CanSendStoryResultActiveStoryLimitExceeded,
    CanSendStoryResultBoostNeeded,
    CanSendStoryResultMonthlyLimitExceeded,
    CanSendStoryResultOk,
    CanSendStoryResultPremiumNeeded,
    CanSendStoryResultWeeklyLimitExceeded,
]


@dataclass(slots=True, kw_only=True)
class CanTransferOwnershipResultOk(BaseObject):
    """
    The session can be used
    """

    ID: typing.Literal["canTransferOwnershipResultOk"] = field(
        default="canTransferOwnershipResultOk", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CanTransferOwnershipResultPasswordNeeded(BaseObject):
    """
    The 2-step verification needs to be enabled first
    """

    ID: typing.Literal["canTransferOwnershipResultPasswordNeeded"] = field(
        default="canTransferOwnershipResultPasswordNeeded", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CanTransferOwnershipResultPasswordTooFresh(BaseObject):
    """
    The 2-step verification was enabled recently, user needs to wait

    :param retry_after: Time left before the session can be used to transfer ownership of a chat, in seconds
    :type retry_after: :class:`Int32`
    """

    ID: typing.Literal["canTransferOwnershipResultPasswordTooFresh"] = field(
        default="canTransferOwnershipResultPasswordTooFresh", metadata={"alias": "@type"}
    )
    retry_after: Int32


@dataclass(slots=True, kw_only=True)
class CanTransferOwnershipResultSessionTooFresh(BaseObject):
    """
    The session was created recently, user needs to wait

    :param retry_after: Time left before the session can be used to transfer ownership of a chat, in seconds
    :type retry_after: :class:`Int32`
    """

    ID: typing.Literal["canTransferOwnershipResultSessionTooFresh"] = field(
        default="canTransferOwnershipResultSessionTooFresh", metadata={"alias": "@type"}
    )
    retry_after: Int32


CanTransferOwnershipResult = typing.Union[
    CanTransferOwnershipResultOk,
    CanTransferOwnershipResultPasswordNeeded,
    CanTransferOwnershipResultPasswordTooFresh,
    CanTransferOwnershipResultSessionTooFresh,
]


@dataclass(slots=True, kw_only=True)
class Chat(BaseObject):
    """
    A chat. (Can be a private chat, basic group, supergroup, or secret chat)

    :param id: Chat unique identifier
    :type id: :class:`Int53`
    :param type_: Type of the chat
    :type type_: :class:`ChatType`
    :param title: Chat title
    :type title: :class:`String`
    :param accent_color_id: Identifier of the accent color for message sender name, and backgrounds of chat photo, reply header, and link preview
    :type accent_color_id: :class:`Int32`
    :param profile_accent_color_id: Identifier of the profile accent color for the chat's profile; -1 if none
    :type profile_accent_color_id: :class:`Int32`
    :param permissions: Actions that non-administrator chat members are allowed to take in the chat
    :type permissions: :class:`ChatPermissions`
    :param positions: Positions of the chat in chat lists
    :type positions: :class:`Vector[ChatPosition]`
    :param chat_lists: Chat lists to which the chat belongs. A chat can have a non-zero position in a chat list even it doesn't belong to the chat list and have no position in a chat list even it belongs to the chat list
    :type chat_lists: :class:`Vector[ChatList]`
    :param default_disable_notification: Default value of the disable_notification parameter, used when a message is sent to the chat
    :type default_disable_notification: :class:`Bool`
    :param unread_count: Number of unread messages in the chat
    :type unread_count: :class:`Int32`
    :param last_read_inbox_message_id: Identifier of the last read incoming message
    :type last_read_inbox_message_id: :class:`Int53`
    :param last_read_outbox_message_id: Identifier of the last read outgoing message
    :type last_read_outbox_message_id: :class:`Int53`
    :param unread_mention_count: Number of unread messages with a mention/reply in the chat
    :type unread_mention_count: :class:`Int32`
    :param unread_reaction_count: Number of messages with unread reactions in the chat
    :type unread_reaction_count: :class:`Int32`
    :param notification_settings: Notification settings for the chat
    :type notification_settings: :class:`ChatNotificationSettings`
    :param available_reactions: Types of reaction, available in the chat
    :type available_reactions: :class:`ChatAvailableReactions`
    :param video_chat: Information about video chat of the chat
    :type video_chat: :class:`VideoChat`
    :param client_data: Application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used
    :type client_data: :class:`String`
    :param photo: Chat photo; may be null, defaults to None
    :type photo: :class:`ChatPhotoInfo`, optional
    :param last_message: Last message in the chat; may be null if none or unknown, defaults to None
    :type last_message: :class:`Message`, optional
    :param message_sender_id: Identifier of a user or chat that is selected to send messages in the chat; may be null if the user can't change message sender, defaults to None
    :type message_sender_id: :class:`MessageSender`, optional
    :param block_list: Block list to which the chat is added; may be null if none, defaults to None
    :type block_list: :class:`BlockList`, optional
    :param emoji_status: Emoji status to be shown along with chat title; may be null, defaults to None
    :type emoji_status: :class:`EmojiStatus`, optional
    :param background: Background set for the chat; may be null if none, defaults to None
    :type background: :class:`ChatBackground`, optional
    :param action_bar: Information about actions which must be possible to do through the chat action bar; may be null if none, defaults to None
    :type action_bar: :class:`ChatActionBar`, optional
    :param business_bot_manage_bar: Information about bar for managing a business bot in the chat; may be null if none, defaults to None
    :type business_bot_manage_bar: :class:`BusinessBotManageBar`, optional
    :param pending_join_requests: Information about pending join requests; may be null if none, defaults to None
    :type pending_join_requests: :class:`ChatJoinRequestsInfo`, optional
    :param draft_message: A draft of a message in the chat; may be null if none, defaults to None
    :type draft_message: :class:`DraftMessage`, optional
    :param has_protected_content: True, if chat content can't be saved locally, forwarded, or copied
    :type has_protected_content: :class:`Bool`
    :param is_translatable: True, if translation of all messages in the chat must be suggested to the user
    :type is_translatable: :class:`Bool`
    :param is_marked_as_unread: True, if the chat is marked as unread
    :type is_marked_as_unread: :class:`Bool`
    :param view_as_topics: True, if the chat is a forum supergroup that must be shown in the "View as topics" mode, or Saved Messages chat that must be shown in the "View as chats"
    :type view_as_topics: :class:`Bool`
    :param has_scheduled_messages: True, if the chat has scheduled messages
    :type has_scheduled_messages: :class:`Bool`
    :param can_be_deleted_only_for_self: True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
    :type can_be_deleted_only_for_self: :class:`Bool`
    :param can_be_deleted_for_all_users: True, if the chat messages can be deleted for all users
    :type can_be_deleted_for_all_users: :class:`Bool`
    :param can_be_reported: True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto
    :type can_be_reported: :class:`Bool`
    :param message_auto_delete_time: Current message auto-delete or self-destruct timer setting for the chat, in seconds; 0 if disabled. Self-destruct timer in secret chats starts after the message or its content is viewed. Auto-delete timer in other chats starts from the send date
    :type message_auto_delete_time: :class:`Int32`
    :param theme_name: If non-empty, name of a theme, set for the chat
    :type theme_name: :class:`String`
    :param reply_markup_message_id: Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
    :type reply_markup_message_id: :class:`Int53`
    :param background_custom_emoji_id: Identifier of a custom emoji to be shown on the reply header and link preview background for messages sent by the chat; 0 if none, defaults to None
    :type background_custom_emoji_id: :class:`Int64`, optional
    :param profile_background_custom_emoji_id: Identifier of a custom emoji to be shown on the background of the chat's profile; 0 if none, defaults to None
    :type profile_background_custom_emoji_id: :class:`Int64`, optional
    """

    ID: typing.Literal["chat"] = field(default="chat", metadata={"alias": "@type"})
    id: Int53
    type_: ChatType = field(default=MISSING, metadata={"alias": "type"})
    title: String
    accent_color_id: Int32
    profile_accent_color_id: Int32
    permissions: ChatPermissions
    positions: Vector[ChatPosition]
    chat_lists: Vector[ChatList]
    default_disable_notification: Bool
    unread_count: Int32
    last_read_inbox_message_id: Int53
    last_read_outbox_message_id: Int53
    unread_mention_count: Int32
    unread_reaction_count: Int32
    notification_settings: ChatNotificationSettings
    available_reactions: ChatAvailableReactions
    video_chat: VideoChat
    client_data: String
    photo: typing.Optional[ChatPhotoInfo] = field(default=None)
    last_message: typing.Optional[Message] = field(default=None)
    message_sender_id: typing.Optional[MessageSender] = field(default=None)
    block_list: typing.Optional[BlockList] = field(default=None)
    emoji_status: typing.Optional[EmojiStatus] = field(default=None)
    background: typing.Optional[ChatBackground] = field(default=None)
    action_bar: typing.Optional[ChatActionBar] = field(default=None)
    business_bot_manage_bar: typing.Optional[BusinessBotManageBar] = field(default=None)
    pending_join_requests: typing.Optional[ChatJoinRequestsInfo] = field(default=None)
    draft_message: typing.Optional[DraftMessage] = field(default=None)
    has_protected_content: Bool = field(default=False)
    is_translatable: Bool = field(default=False)
    is_marked_as_unread: Bool = field(default=False)
    view_as_topics: Bool = field(default=False)
    has_scheduled_messages: Bool = field(default=False)
    can_be_deleted_only_for_self: Bool = field(default=False)
    can_be_deleted_for_all_users: Bool = field(default=False)
    can_be_reported: Bool = field(default=False)
    message_auto_delete_time: Int32 = field(default=0)
    theme_name: String = field(default="")
    reply_markup_message_id: Int53 = field(default=0)
    background_custom_emoji_id: typing.Optional[Int64] = field(default=0)
    profile_background_custom_emoji_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatActionCancel(BaseObject):
    """
    The user has canceled the previous action
    """

    ID: typing.Literal["chatActionCancel"] = field(default="chatActionCancel", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ChatActionChoosingContact(BaseObject):
    """
    The user is picking a contact to send
    """

    ID: typing.Literal["chatActionChoosingContact"] = field(
        default="chatActionChoosingContact", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ChatActionChoosingLocation(BaseObject):
    """
    The user is picking a location or venue to send
    """

    ID: typing.Literal["chatActionChoosingLocation"] = field(
        default="chatActionChoosingLocation", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ChatActionChoosingSticker(BaseObject):
    """
    The user is picking a sticker to send
    """

    ID: typing.Literal["chatActionChoosingSticker"] = field(
        default="chatActionChoosingSticker", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ChatActionRecordingVideo(BaseObject):
    """
    The user is recording a video
    """

    ID: typing.Literal["chatActionRecordingVideo"] = field(
        default="chatActionRecordingVideo", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ChatActionRecordingVideoNote(BaseObject):
    """
    The user is recording a video note
    """

    ID: typing.Literal["chatActionRecordingVideoNote"] = field(
        default="chatActionRecordingVideoNote", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ChatActionRecordingVoiceNote(BaseObject):
    """
    The user is recording a voice note
    """

    ID: typing.Literal["chatActionRecordingVoiceNote"] = field(
        default="chatActionRecordingVoiceNote", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ChatActionStartPlayingGame(BaseObject):
    """
    The user has started to play a game
    """

    ID: typing.Literal["chatActionStartPlayingGame"] = field(
        default="chatActionStartPlayingGame", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ChatActionTyping(BaseObject):
    """
    The user is typing a message
    """

    ID: typing.Literal["chatActionTyping"] = field(default="chatActionTyping", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ChatActionUploadingDocument(BaseObject):
    """
    The user is uploading a document

    :param progress: Upload progress, as a percentage
    :type progress: :class:`Int32`
    """

    ID: typing.Literal["chatActionUploadingDocument"] = field(
        default="chatActionUploadingDocument", metadata={"alias": "@type"}
    )
    progress: Int32


@dataclass(slots=True, kw_only=True)
class ChatActionUploadingPhoto(BaseObject):
    """
    The user is uploading a photo

    :param progress: Upload progress, as a percentage
    :type progress: :class:`Int32`
    """

    ID: typing.Literal["chatActionUploadingPhoto"] = field(
        default="chatActionUploadingPhoto", metadata={"alias": "@type"}
    )
    progress: Int32


@dataclass(slots=True, kw_only=True)
class ChatActionUploadingVideo(BaseObject):
    """
    The user is uploading a video

    :param progress: Upload progress, as a percentage
    :type progress: :class:`Int32`
    """

    ID: typing.Literal["chatActionUploadingVideo"] = field(
        default="chatActionUploadingVideo", metadata={"alias": "@type"}
    )
    progress: Int32


@dataclass(slots=True, kw_only=True)
class ChatActionUploadingVideoNote(BaseObject):
    """
    The user is uploading a video note

    :param progress: Upload progress, as a percentage
    :type progress: :class:`Int32`
    """

    ID: typing.Literal["chatActionUploadingVideoNote"] = field(
        default="chatActionUploadingVideoNote", metadata={"alias": "@type"}
    )
    progress: Int32


@dataclass(slots=True, kw_only=True)
class ChatActionUploadingVoiceNote(BaseObject):
    """
    The user is uploading a voice note

    :param progress: Upload progress, as a percentage
    :type progress: :class:`Int32`
    """

    ID: typing.Literal["chatActionUploadingVoiceNote"] = field(
        default="chatActionUploadingVoiceNote", metadata={"alias": "@type"}
    )
    progress: Int32


@dataclass(slots=True, kw_only=True)
class ChatActionWatchingAnimations(BaseObject):
    """
    The user is watching animations sent by the other party by clicking on an animated emoji

    :param emoji: The animated emoji
    :type emoji: :class:`String`
    """

    ID: typing.Literal["chatActionWatchingAnimations"] = field(
        default="chatActionWatchingAnimations", metadata={"alias": "@type"}
    )
    emoji: String


ChatAction = typing.Union[
    ChatActionCancel,
    ChatActionChoosingContact,
    ChatActionChoosingLocation,
    ChatActionChoosingSticker,
    ChatActionRecordingVideo,
    ChatActionRecordingVideoNote,
    ChatActionRecordingVoiceNote,
    ChatActionStartPlayingGame,
    ChatActionTyping,
    ChatActionUploadingDocument,
    ChatActionUploadingPhoto,
    ChatActionUploadingVideo,
    ChatActionUploadingVideoNote,
    ChatActionUploadingVoiceNote,
    ChatActionWatchingAnimations,
]


@dataclass(slots=True, kw_only=True)
class ChatActionBarAddContact(BaseObject):
    """
    The chat is a private or secret chat and the other user can be added to the contact list using the method addContact
    """

    ID: typing.Literal["chatActionBarAddContact"] = field(
        default="chatActionBarAddContact", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ChatActionBarInviteMembers(BaseObject):
    """
    The chat is a recently created group chat to which new members can be invited
    """

    ID: typing.Literal["chatActionBarInviteMembers"] = field(
        default="chatActionBarInviteMembers", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ChatActionBarJoinRequest(BaseObject):
    """
    The chat is a private chat with an administrator of a chat to which the user sent join request

    :param title: Title of the chat to which the join request was sent
    :type title: :class:`String`
    :param request_date: Point in time (Unix timestamp) when the join request was sent
    :type request_date: :class:`Int32`
    :param is_channel: True, if the join request was sent to a channel chat
    :type is_channel: :class:`Bool`
    """

    ID: typing.Literal["chatActionBarJoinRequest"] = field(
        default="chatActionBarJoinRequest", metadata={"alias": "@type"}
    )
    title: String
    request_date: Int32
    is_channel: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatActionBarReportAddBlock(BaseObject):
    """
    The chat is a private or secret chat, which can be reported using the method reportChat, or the other user can be blocked using the method setMessageSenderBlockList, or the other user can be added to the contact list using the method addContact. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown

    :param can_unarchive: If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
    :type can_unarchive: :class:`Bool`
    """

    ID: typing.Literal["chatActionBarReportAddBlock"] = field(
        default="chatActionBarReportAddBlock", metadata={"alias": "@type"}
    )
    can_unarchive: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatActionBarReportSpam(BaseObject):
    """
    The chat can be reported as spam using the method reportChat with an empty option_id and message_ids. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown

    :param can_unarchive: If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
    :type can_unarchive: :class:`Bool`
    """

    ID: typing.Literal["chatActionBarReportSpam"] = field(
        default="chatActionBarReportSpam", metadata={"alias": "@type"}
    )
    can_unarchive: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatActionBarSharePhoneNumber(BaseObject):
    """
    The chat is a private or secret chat with a mutual contact and the user's phone number can be shared with the other user using the method sharePhoneNumber
    """

    ID: typing.Literal["chatActionBarSharePhoneNumber"] = field(
        default="chatActionBarSharePhoneNumber", metadata={"alias": "@type"}
    )


ChatActionBar = typing.Union[
    ChatActionBarAddContact,
    ChatActionBarInviteMembers,
    ChatActionBarJoinRequest,
    ChatActionBarReportAddBlock,
    ChatActionBarReportSpam,
    ChatActionBarSharePhoneNumber,
]


@dataclass(slots=True, kw_only=True)
class ChatActiveStories(BaseObject):
    """
    Describes active stories posted by a chat

    :param chat_id: Identifier of the chat that posted the stories
    :type chat_id: :class:`Int53`
    :param max_read_story_id: Identifier of the last read active story
    :type max_read_story_id: :class:`Int32`
    :param stories: Basic information about the stories; use getStory to get full information about the stories. The stories are in chronological order (i.e., in order of increasing story identifiers)
    :type stories: :class:`Vector[StoryInfo]`
    :param list: Identifier of the story list in which the stories are shown; may be null if the stories aren't shown in a story list, defaults to None
    :type list: :class:`StoryList`, optional
    :param order: A parameter used to determine order of the stories in the story list; 0 if the stories doesn't need to be shown in the story list. Stories must be sorted by the pair (order, story_sender_chat_id) in descending order
    :type order: :class:`Int53`
    """

    ID: typing.Literal["chatActiveStories"] = field(default="chatActiveStories", metadata={"alias": "@type"})
    chat_id: Int53
    max_read_story_id: Int32
    stories: Vector[StoryInfo]
    list: typing.Optional[StoryList] = field(default=None)
    order: Int53 = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatAdministrator(BaseObject):
    """
    Contains information about a chat administrator

    :param user_id: User identifier of the administrator
    :type user_id: :class:`Int53`
    :param custom_title: Custom title of the administrator
    :type custom_title: :class:`String`
    :param is_owner: True, if the user is the owner of the chat
    :type is_owner: :class:`Bool`
    """

    ID: typing.Literal["chatAdministrator"] = field(default="chatAdministrator", metadata={"alias": "@type"})
    user_id: Int53
    custom_title: String
    is_owner: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatAdministratorRights(BaseObject):
    """
    Describes rights of the administrator

    :param can_manage_chat: True, if the administrator can access the chat event log, get boost list, see hidden supergroup and channel members, report supergroup spam messages and ignore slow mode. Implied by any other privilege; applicable to supergroups and channels only
    :type can_manage_chat: :class:`Bool`
    :param can_change_info: True, if the administrator can change the chat title, photo, and other settings
    :type can_change_info: :class:`Bool`
    :param can_post_messages: True, if the administrator can create channel posts or view channel statistics; applicable to channels only
    :type can_post_messages: :class:`Bool`
    :param can_edit_messages: True, if the administrator can edit messages of other users and pin messages; applicable to channels only
    :type can_edit_messages: :class:`Bool`
    :param can_delete_messages: True, if the administrator can delete messages of other users
    :type can_delete_messages: :class:`Bool`
    :param can_invite_users: True, if the administrator can invite new users to the chat
    :type can_invite_users: :class:`Bool`
    :param can_restrict_members: True, if the administrator can restrict, ban, or unban chat members or view supergroup statistics; always true for channels
    :type can_restrict_members: :class:`Bool`
    :param can_pin_messages: True, if the administrator can pin messages; applicable to basic groups and supergroups only
    :type can_pin_messages: :class:`Bool`
    :param can_manage_topics: True, if the administrator can create, rename, close, reopen, hide, and unhide forum topics; applicable to forum supergroups only
    :type can_manage_topics: :class:`Bool`
    :param can_promote_members: True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them
    :type can_promote_members: :class:`Bool`
    :param can_manage_video_chats: True, if the administrator can manage video chats
    :type can_manage_video_chats: :class:`Bool`
    :param can_post_stories: True, if the administrator can create new chat stories, or edit and delete posted stories; applicable to supergroups and channels only
    :type can_post_stories: :class:`Bool`
    :param can_edit_stories: True, if the administrator can edit stories posted by other users, post stories to the chat page, pin chat stories, and access story archive; applicable to supergroups and channels only
    :type can_edit_stories: :class:`Bool`
    :param can_delete_stories: True, if the administrator can delete stories posted by other users; applicable to supergroups and channels only
    :type can_delete_stories: :class:`Bool`
    :param is_anonymous: True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
    :type is_anonymous: :class:`Bool`
    """

    ID: typing.Literal["chatAdministratorRights"] = field(
        default="chatAdministratorRights", metadata={"alias": "@type"}
    )
    can_manage_chat: Bool = field(default=False)
    can_change_info: Bool = field(default=False)
    can_post_messages: Bool = field(default=False)
    can_edit_messages: Bool = field(default=False)
    can_delete_messages: Bool = field(default=False)
    can_invite_users: Bool = field(default=False)
    can_restrict_members: Bool = field(default=False)
    can_pin_messages: Bool = field(default=False)
    can_manage_topics: Bool = field(default=False)
    can_promote_members: Bool = field(default=False)
    can_manage_video_chats: Bool = field(default=False)
    can_post_stories: Bool = field(default=False)
    can_edit_stories: Bool = field(default=False)
    can_delete_stories: Bool = field(default=False)
    is_anonymous: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatAdministrators(BaseObject):
    """
    Represents a list of chat administrators

    :param administrators: A list of chat administrators
    :type administrators: :class:`Vector[ChatAdministrator]`
    """

    ID: typing.Literal["chatAdministrators"] = field(default="chatAdministrators", metadata={"alias": "@type"})
    administrators: Vector[ChatAdministrator]


@dataclass(slots=True, kw_only=True)
class ChatAvailableReactionsAll(BaseObject):
    """
    All reactions are available in the chat, excluding the paid reaction and custom reactions in channel chats

    :param max_reaction_count: The maximum allowed number of reactions per message; 1-11
    :type max_reaction_count: :class:`Int32`
    """

    ID: typing.Literal["chatAvailableReactionsAll"] = field(
        default="chatAvailableReactionsAll", metadata={"alias": "@type"}
    )
    max_reaction_count: Int32


@dataclass(slots=True, kw_only=True)
class ChatAvailableReactionsSome(BaseObject):
    """
    Only specific reactions are available in the chat

    :param reactions: The list of reactions
    :type reactions: :class:`Vector[ReactionType]`
    :param max_reaction_count: The maximum allowed number of reactions per message; 1-11
    :type max_reaction_count: :class:`Int32`
    """

    ID: typing.Literal["chatAvailableReactionsSome"] = field(
        default="chatAvailableReactionsSome", metadata={"alias": "@type"}
    )
    reactions: Vector[ReactionType]
    max_reaction_count: Int32


ChatAvailableReactions = typing.Union[
    ChatAvailableReactionsAll,
    ChatAvailableReactionsSome,
]


@dataclass(slots=True, kw_only=True)
class ChatBackground(BaseObject):
    """
    Describes a background set for a specific chat

    :param background: The background
    :type background: :class:`Background`
    :param dark_theme_dimming: Dimming of the background in dark themes, as a percentage; 0-100. Applied only to Wallpaper and Fill types of background
    :type dark_theme_dimming: :class:`Int32`
    """

    ID: typing.Literal["chatBackground"] = field(default="chatBackground", metadata={"alias": "@type"})
    background: Background
    dark_theme_dimming: Int32


@dataclass(slots=True, kw_only=True)
class ChatBoost(BaseObject):
    """
    Describes a boost applied to a chat

    :param id: Unique identifier of the boost
    :type id: :class:`String`
    :param count: The number of identical boosts applied
    :type count: :class:`Int32`
    :param source: Source of the boost
    :type source: :class:`ChatBoostSource`
    :param start_date: Point in time (Unix timestamp) when the chat was boosted
    :type start_date: :class:`Int32`
    :param expiration_date: Point in time (Unix timestamp) when the boost will expire
    :type expiration_date: :class:`Int32`
    """

    ID: typing.Literal["chatBoost"] = field(default="chatBoost", metadata={"alias": "@type"})
    id: String
    count: Int32
    source: ChatBoostSource
    start_date: Int32
    expiration_date: Int32


@dataclass(slots=True, kw_only=True)
class ChatBoostFeatures(BaseObject):
    """
    Contains a list of features available on the first chat boost levels

    :param features: The list of features
    :type features: :class:`Vector[ChatBoostLevelFeatures]`
    :param min_profile_background_custom_emoji_boost_level: The minimum boost level required to set custom emoji for profile background
    :type min_profile_background_custom_emoji_boost_level: :class:`Int32`
    :param min_background_custom_emoji_boost_level: The minimum boost level required to set custom emoji for reply header and link preview background; for channel chats only
    :type min_background_custom_emoji_boost_level: :class:`Int32`
    :param min_emoji_status_boost_level: The minimum boost level required to set emoji status
    :type min_emoji_status_boost_level: :class:`Int32`
    :param min_chat_theme_background_boost_level: The minimum boost level required to set a chat theme background as chat background
    :type min_chat_theme_background_boost_level: :class:`Int32`
    :param min_custom_background_boost_level: The minimum boost level required to set custom chat background
    :type min_custom_background_boost_level: :class:`Int32`
    :param min_custom_emoji_sticker_set_boost_level: The minimum boost level required to set custom emoji sticker set for the chat; for supergroup chats only
    :type min_custom_emoji_sticker_set_boost_level: :class:`Int32`
    :param min_speech_recognition_boost_level: The minimum boost level allowing to recognize speech in video note and voice note messages for non-Premium users; for supergroup chats only
    :type min_speech_recognition_boost_level: :class:`Int32`
    :param min_sponsored_message_disable_boost_level: The minimum boost level allowing to disable sponsored messages in the chat; for channel chats only
    :type min_sponsored_message_disable_boost_level: :class:`Int32`
    """

    ID: typing.Literal["chatBoostFeatures"] = field(default="chatBoostFeatures", metadata={"alias": "@type"})
    features: Vector[ChatBoostLevelFeatures]
    min_profile_background_custom_emoji_boost_level: Int32
    min_background_custom_emoji_boost_level: Int32
    min_emoji_status_boost_level: Int32
    min_chat_theme_background_boost_level: Int32
    min_custom_background_boost_level: Int32
    min_custom_emoji_sticker_set_boost_level: Int32
    min_speech_recognition_boost_level: Int32
    min_sponsored_message_disable_boost_level: Int32


@dataclass(slots=True, kw_only=True)
class ChatBoostLevelFeatures(BaseObject):
    """
    Contains a list of features available on a specific chat boost level

    :param level: Target chat boost level
    :type level: :class:`Int32`
    :param story_per_day_count: Number of stories that the chat can publish daily
    :type story_per_day_count: :class:`Int32`
    :param custom_emoji_reaction_count: Number of custom emoji reactions that can be added to the list of available reactions
    :type custom_emoji_reaction_count: :class:`Int32`
    :param title_color_count: Number of custom colors for chat title
    :type title_color_count: :class:`Int32`
    :param profile_accent_color_count: Number of custom colors for profile photo background
    :type profile_accent_color_count: :class:`Int32`
    :param accent_color_count: Number of custom colors for background of empty chat photo, replies to messages and link previews
    :type accent_color_count: :class:`Int32`
    :param chat_theme_background_count: Number of chat theme backgrounds that can be set as chat background
    :type chat_theme_background_count: :class:`Int32`
    :param can_set_profile_background_custom_emoji: True, if custom emoji for profile background can be set
    :type can_set_profile_background_custom_emoji: :class:`Bool`
    :param can_set_background_custom_emoji: True, if custom emoji for reply header and link preview background can be set
    :type can_set_background_custom_emoji: :class:`Bool`
    :param can_set_emoji_status: True, if emoji status can be set
    :type can_set_emoji_status: :class:`Bool`
    :param can_set_custom_background: True, if custom background can be set in the chat for all users
    :type can_set_custom_background: :class:`Bool`
    :param can_set_custom_emoji_sticker_set: True, if custom emoji sticker set can be set for the chat
    :type can_set_custom_emoji_sticker_set: :class:`Bool`
    :param can_recognize_speech: True, if speech recognition can be used for video note and voice note messages by all users
    :type can_recognize_speech: :class:`Bool`
    :param can_disable_sponsored_messages: True, if sponsored messages can be disabled in the chat
    :type can_disable_sponsored_messages: :class:`Bool`
    """

    ID: typing.Literal["chatBoostLevelFeatures"] = field(default="chatBoostLevelFeatures", metadata={"alias": "@type"})
    level: Int32
    story_per_day_count: Int32
    custom_emoji_reaction_count: Int32
    title_color_count: Int32
    profile_accent_color_count: Int32
    accent_color_count: Int32
    chat_theme_background_count: Int32
    can_set_profile_background_custom_emoji: Bool = field(default=False)
    can_set_background_custom_emoji: Bool = field(default=False)
    can_set_emoji_status: Bool = field(default=False)
    can_set_custom_background: Bool = field(default=False)
    can_set_custom_emoji_sticker_set: Bool = field(default=False)
    can_recognize_speech: Bool = field(default=False)
    can_disable_sponsored_messages: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatBoostLink(BaseObject):
    """
    Contains an HTTPS link to boost a chat

    :param link: The link
    :type link: :class:`String`
    :param is_public: True, if the link will work for non-members of the chat
    :type is_public: :class:`Bool`
    """

    ID: typing.Literal["chatBoostLink"] = field(default="chatBoostLink", metadata={"alias": "@type"})
    link: String
    is_public: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatBoostLinkInfo(BaseObject):
    """
    Contains information about a link to boost a chat

    :param is_public: True, if the link will work for non-members of the chat
    :type is_public: :class:`Bool`
    :param chat_id: Identifier of the chat to which the link points; 0 if the chat isn't found
    :type chat_id: :class:`Int53`
    """

    ID: typing.Literal["chatBoostLinkInfo"] = field(default="chatBoostLinkInfo", metadata={"alias": "@type"})
    is_public: Bool = field(default=False)
    chat_id: Int53 = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatBoostSlot(BaseObject):
    """
    Describes a slot for chat boost

    :param slot_id: Unique identifier of the slot
    :type slot_id: :class:`Int32`
    :param expiration_date: Point in time (Unix timestamp) when the boost will expire
    :type expiration_date: :class:`Int32`
    :param cooldown_until_date: Point in time (Unix timestamp) after which the boost can be used for another chat
    :type cooldown_until_date: :class:`Int32`
    :param currently_boosted_chat_id: Identifier of the currently boosted chat; 0 if none, defaults to None
    :type currently_boosted_chat_id: :class:`Int53`, optional
    :param start_date: Point in time (Unix timestamp) when the chat was boosted; 0 if none, defaults to None
    :type start_date: :class:`Int32`, optional
    """

    ID: typing.Literal["chatBoostSlot"] = field(default="chatBoostSlot", metadata={"alias": "@type"})
    slot_id: Int32
    expiration_date: Int32
    cooldown_until_date: Int32
    currently_boosted_chat_id: typing.Optional[Int53] = field(default=0)
    start_date: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatBoostSlots(BaseObject):
    """
    Contains a list of chat boost slots

    :param slots: List of boost slots
    :type slots: :class:`Vector[ChatBoostSlot]`
    """

    ID: typing.Literal["chatBoostSlots"] = field(default="chatBoostSlots", metadata={"alias": "@type"})
    slots: Vector[ChatBoostSlot]


@dataclass(slots=True, kw_only=True)
class ChatBoostSourceGiftCode(BaseObject):
    """
    The chat created a Telegram Premium gift code for a user

    :param user_id: Identifier of a user, for which the gift code was created
    :type user_id: :class:`Int53`
    :param gift_code: The created Telegram Premium gift code, which is known only if this is a gift code for the current user, or it has already been claimed
    :type gift_code: :class:`String`
    """

    ID: typing.Literal["chatBoostSourceGiftCode"] = field(
        default="chatBoostSourceGiftCode", metadata={"alias": "@type"}
    )
    user_id: Int53
    gift_code: String


@dataclass(slots=True, kw_only=True)
class ChatBoostSourceGiveaway(BaseObject):
    """
    The chat created a giveaway

    :param gift_code: The created Telegram Premium gift code if it was used by the user or can be claimed by the current user; an empty string otherwise; for Telegram Premium giveways only
    :type gift_code: :class:`String`
    :param star_count: Number of Telegram Stars distributed among winners of the giveaway
    :type star_count: :class:`Int53`
    :param giveaway_message_id: Identifier of the corresponding giveaway message; can be an identifier of a deleted message
    :type giveaway_message_id: :class:`Int53`
    :param is_unclaimed: True, if the winner for the corresponding giveaway prize wasn't chosen, because there were not enough participants
    :type is_unclaimed: :class:`Bool`
    :param user_id: Identifier of a user that won in the giveaway; 0 if none, defaults to None
    :type user_id: :class:`Int53`, optional
    """

    ID: typing.Literal["chatBoostSourceGiveaway"] = field(
        default="chatBoostSourceGiveaway", metadata={"alias": "@type"}
    )
    gift_code: String
    star_count: Int53
    giveaway_message_id: Int53
    is_unclaimed: Bool = field(default=False)
    user_id: typing.Optional[Int53] = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatBoostSourcePremium(BaseObject):
    """
    A user with Telegram Premium subscription or gifted Telegram Premium boosted the chat

    :param user_id: Identifier of the user
    :type user_id: :class:`Int53`
    """

    ID: typing.Literal["chatBoostSourcePremium"] = field(default="chatBoostSourcePremium", metadata={"alias": "@type"})
    user_id: Int53


ChatBoostSource = typing.Union[
    ChatBoostSourceGiftCode,
    ChatBoostSourceGiveaway,
    ChatBoostSourcePremium,
]


@dataclass(slots=True, kw_only=True)
class ChatBoostStatus(BaseObject):
    """
    Describes current boost status of a chat

    :param boost_url: An HTTP URL, which can be used to boost the chat
    :type boost_url: :class:`String`
    :param applied_slot_ids: Identifiers of boost slots of the current user applied to the chat
    :type applied_slot_ids: :class:`Vector[Int32]`
    :param level: Current boost level of the chat
    :type level: :class:`Int32`
    :param boost_count: The number of boosts received by the chat
    :type boost_count: :class:`Int32`
    :param current_level_boost_count: The number of boosts added to reach the current level
    :type current_level_boost_count: :class:`Int32`
    :param prepaid_giveaways: The list of prepaid giveaways available for the chat; only for chat administrators
    :type prepaid_giveaways: :class:`Vector[PrepaidGiveaway]`
    :param gift_code_boost_count: The number of boosts received by the chat from created Telegram Premium gift codes and giveaways; always 0 if the current user isn't an administrator in the chat
    :type gift_code_boost_count: :class:`Int32`
    :param next_level_boost_count: The number of boosts needed to reach the next level; 0 if the next level isn't available
    :type next_level_boost_count: :class:`Int32`
    :param premium_member_count: Approximate number of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat
    :type premium_member_count: :class:`Int32`
    :param premium_member_percentage: A percentage of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat
    :type premium_member_percentage: :class:`Double`
    """

    ID: typing.Literal["chatBoostStatus"] = field(default="chatBoostStatus", metadata={"alias": "@type"})
    boost_url: String
    applied_slot_ids: Vector[Int32]
    level: Int32
    boost_count: Int32
    current_level_boost_count: Int32
    prepaid_giveaways: Vector[PrepaidGiveaway]
    gift_code_boost_count: Int32 = field(default=0)
    next_level_boost_count: Int32 = field(default=0)
    premium_member_count: Int32 = field(default=0)
    premium_member_percentage: Double = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatEvent(BaseObject):
    """
    Represents a chat event

    :param id: Chat event identifier
    :type id: :class:`Int64`
    :param date: Point in time (Unix timestamp) when the event happened
    :type date: :class:`Int32`
    :param member_id: Identifier of the user or chat who performed the action
    :type member_id: :class:`MessageSender`
    :param action: The action
    :type action: :class:`ChatEventAction`
    """

    ID: typing.Literal["chatEvent"] = field(default="chatEvent", metadata={"alias": "@type"})
    id: Int64
    date: Int32
    member_id: MessageSender
    action: ChatEventAction


@dataclass(slots=True, kw_only=True)
class ChatEventAccentColorChanged(BaseObject):
    """
    The chat accent color or background custom emoji were changed

    :param old_accent_color_id: Previous identifier of chat accent color
    :type old_accent_color_id: :class:`Int32`
    :param new_accent_color_id: New identifier of chat accent color
    :type new_accent_color_id: :class:`Int32`
    :param old_background_custom_emoji_id: Previous identifier of the custom emoji; 0 if none, defaults to None
    :type old_background_custom_emoji_id: :class:`Int64`, optional
    :param new_background_custom_emoji_id: New identifier of the custom emoji; 0 if none, defaults to None
    :type new_background_custom_emoji_id: :class:`Int64`, optional
    """

    ID: typing.Literal["chatEventAccentColorChanged"] = field(
        default="chatEventAccentColorChanged", metadata={"alias": "@type"}
    )
    old_accent_color_id: Int32
    new_accent_color_id: Int32
    old_background_custom_emoji_id: typing.Optional[Int64] = field(default=0)
    new_background_custom_emoji_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatEventActiveUsernamesChanged(BaseObject):
    """
    The chat active usernames were changed

    :param old_usernames: Previous list of active usernames
    :type old_usernames: :class:`Vector[String]`
    :param new_usernames: New list of active usernames
    :type new_usernames: :class:`Vector[String]`
    """

    ID: typing.Literal["chatEventActiveUsernamesChanged"] = field(
        default="chatEventActiveUsernamesChanged", metadata={"alias": "@type"}
    )
    old_usernames: Vector[String]
    new_usernames: Vector[String]


@dataclass(slots=True, kw_only=True)
class ChatEventAvailableReactionsChanged(BaseObject):
    """
    The chat available reactions were changed

    :param old_available_reactions: Previous chat available reactions
    :type old_available_reactions: :class:`ChatAvailableReactions`
    :param new_available_reactions: New chat available reactions
    :type new_available_reactions: :class:`ChatAvailableReactions`
    """

    ID: typing.Literal["chatEventAvailableReactionsChanged"] = field(
        default="chatEventAvailableReactionsChanged", metadata={"alias": "@type"}
    )
    old_available_reactions: ChatAvailableReactions
    new_available_reactions: ChatAvailableReactions


@dataclass(slots=True, kw_only=True)
class ChatEventBackgroundChanged(BaseObject):
    """
    The chat background was changed

    :param old_background: Previous background; may be null if none, defaults to None
    :type old_background: :class:`ChatBackground`, optional
    :param new_background: New background; may be null if none, defaults to None
    :type new_background: :class:`ChatBackground`, optional
    """

    ID: typing.Literal["chatEventBackgroundChanged"] = field(
        default="chatEventBackgroundChanged", metadata={"alias": "@type"}
    )
    old_background: typing.Optional[ChatBackground] = field(default=None)
    new_background: typing.Optional[ChatBackground] = field(default=None)


@dataclass(slots=True, kw_only=True)
class ChatEventCustomEmojiStickerSetChanged(BaseObject):
    """
    The supergroup sticker set with allowed custom emoji was changed

    :param old_sticker_set_id: Previous identifier of the chat sticker set; 0 if none, defaults to None
    :type old_sticker_set_id: :class:`Int64`, optional
    :param new_sticker_set_id: New identifier of the chat sticker set; 0 if none, defaults to None
    :type new_sticker_set_id: :class:`Int64`, optional
    """

    ID: typing.Literal["chatEventCustomEmojiStickerSetChanged"] = field(
        default="chatEventCustomEmojiStickerSetChanged", metadata={"alias": "@type"}
    )
    old_sticker_set_id: typing.Optional[Int64] = field(default=0)
    new_sticker_set_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatEventDescriptionChanged(BaseObject):
    """
    The chat description was changed

    :param old_description: Previous chat description
    :type old_description: :class:`String`
    :param new_description: New chat description
    :type new_description: :class:`String`
    """

    ID: typing.Literal["chatEventDescriptionChanged"] = field(
        default="chatEventDescriptionChanged", metadata={"alias": "@type"}
    )
    old_description: String
    new_description: String


@dataclass(slots=True, kw_only=True)
class ChatEventEmojiStatusChanged(BaseObject):
    """
    The chat emoji status was changed

    :param old_emoji_status: Previous emoji status; may be null if none, defaults to None
    :type old_emoji_status: :class:`EmojiStatus`, optional
    :param new_emoji_status: New emoji status; may be null if none, defaults to None
    :type new_emoji_status: :class:`EmojiStatus`, optional
    """

    ID: typing.Literal["chatEventEmojiStatusChanged"] = field(
        default="chatEventEmojiStatusChanged", metadata={"alias": "@type"}
    )
    old_emoji_status: typing.Optional[EmojiStatus] = field(default=None)
    new_emoji_status: typing.Optional[EmojiStatus] = field(default=None)


@dataclass(slots=True, kw_only=True)
class ChatEventForumTopicCreated(BaseObject):
    """
    A new forum topic was created

    :param topic_info: Information about the topic
    :type topic_info: :class:`ForumTopicInfo`
    """

    ID: typing.Literal["chatEventForumTopicCreated"] = field(
        default="chatEventForumTopicCreated", metadata={"alias": "@type"}
    )
    topic_info: ForumTopicInfo


@dataclass(slots=True, kw_only=True)
class ChatEventForumTopicDeleted(BaseObject):
    """
    A forum topic was deleted

    :param topic_info: Information about the topic
    :type topic_info: :class:`ForumTopicInfo`
    """

    ID: typing.Literal["chatEventForumTopicDeleted"] = field(
        default="chatEventForumTopicDeleted", metadata={"alias": "@type"}
    )
    topic_info: ForumTopicInfo


@dataclass(slots=True, kw_only=True)
class ChatEventForumTopicEdited(BaseObject):
    """
    A forum topic was edited

    :param old_topic_info: Old information about the topic
    :type old_topic_info: :class:`ForumTopicInfo`
    :param new_topic_info: New information about the topic
    :type new_topic_info: :class:`ForumTopicInfo`
    """

    ID: typing.Literal["chatEventForumTopicEdited"] = field(
        default="chatEventForumTopicEdited", metadata={"alias": "@type"}
    )
    old_topic_info: ForumTopicInfo
    new_topic_info: ForumTopicInfo


@dataclass(slots=True, kw_only=True)
class ChatEventForumTopicPinned(BaseObject):
    """
    A pinned forum topic was changed

    :param old_topic_info: Information about the old pinned topic; may be null, defaults to None
    :type old_topic_info: :class:`ForumTopicInfo`, optional
    :param new_topic_info: Information about the new pinned topic; may be null, defaults to None
    :type new_topic_info: :class:`ForumTopicInfo`, optional
    """

    ID: typing.Literal["chatEventForumTopicPinned"] = field(
        default="chatEventForumTopicPinned", metadata={"alias": "@type"}
    )
    old_topic_info: typing.Optional[ForumTopicInfo] = field(default=None)
    new_topic_info: typing.Optional[ForumTopicInfo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class ChatEventForumTopicToggleIsClosed(BaseObject):
    """
    A forum topic was closed or reopened

    :param topic_info: New information about the topic
    :type topic_info: :class:`ForumTopicInfo`
    """

    ID: typing.Literal["chatEventForumTopicToggleIsClosed"] = field(
        default="chatEventForumTopicToggleIsClosed", metadata={"alias": "@type"}
    )
    topic_info: ForumTopicInfo


@dataclass(slots=True, kw_only=True)
class ChatEventForumTopicToggleIsHidden(BaseObject):
    """
    The General forum topic was hidden or unhidden

    :param topic_info: New information about the topic
    :type topic_info: :class:`ForumTopicInfo`
    """

    ID: typing.Literal["chatEventForumTopicToggleIsHidden"] = field(
        default="chatEventForumTopicToggleIsHidden", metadata={"alias": "@type"}
    )
    topic_info: ForumTopicInfo


@dataclass(slots=True, kw_only=True)
class ChatEventHasAggressiveAntiSpamEnabledToggled(BaseObject):
    """
    The has_aggressive_anti_spam_enabled setting of a supergroup was toggled

    :param has_aggressive_anti_spam_enabled: New value of has_aggressive_anti_spam_enabled
    :type has_aggressive_anti_spam_enabled: :class:`Bool`
    """

    ID: typing.Literal["chatEventHasAggressiveAntiSpamEnabledToggled"] = field(
        default="chatEventHasAggressiveAntiSpamEnabledToggled", metadata={"alias": "@type"}
    )
    has_aggressive_anti_spam_enabled: Bool


@dataclass(slots=True, kw_only=True)
class ChatEventHasProtectedContentToggled(BaseObject):
    """
    The has_protected_content setting of a channel was toggled

    :param has_protected_content: New value of has_protected_content
    :type has_protected_content: :class:`Bool`
    """

    ID: typing.Literal["chatEventHasProtectedContentToggled"] = field(
        default="chatEventHasProtectedContentToggled", metadata={"alias": "@type"}
    )
    has_protected_content: Bool


@dataclass(slots=True, kw_only=True)
class ChatEventInviteLinkDeleted(BaseObject):
    """
    A revoked chat invite link was deleted

    :param invite_link: The invite link
    :type invite_link: :class:`ChatInviteLink`
    """

    ID: typing.Literal["chatEventInviteLinkDeleted"] = field(
        default="chatEventInviteLinkDeleted", metadata={"alias": "@type"}
    )
    invite_link: ChatInviteLink


@dataclass(slots=True, kw_only=True)
class ChatEventInviteLinkEdited(BaseObject):
    """
    A chat invite link was edited

    :param old_invite_link: Previous information about the invite link
    :type old_invite_link: :class:`ChatInviteLink`
    :param new_invite_link: New information about the invite link
    :type new_invite_link: :class:`ChatInviteLink`
    """

    ID: typing.Literal["chatEventInviteLinkEdited"] = field(
        default="chatEventInviteLinkEdited", metadata={"alias": "@type"}
    )
    old_invite_link: ChatInviteLink
    new_invite_link: ChatInviteLink


@dataclass(slots=True, kw_only=True)
class ChatEventInviteLinkRevoked(BaseObject):
    """
    A chat invite link was revoked

    :param invite_link: The invite link
    :type invite_link: :class:`ChatInviteLink`
    """

    ID: typing.Literal["chatEventInviteLinkRevoked"] = field(
        default="chatEventInviteLinkRevoked", metadata={"alias": "@type"}
    )
    invite_link: ChatInviteLink


@dataclass(slots=True, kw_only=True)
class ChatEventInvitesToggled(BaseObject):
    """
    The can_invite_users permission of a supergroup chat was toggled

    :param can_invite_users: New value of can_invite_users permission
    :type can_invite_users: :class:`Bool`
    """

    ID: typing.Literal["chatEventInvitesToggled"] = field(
        default="chatEventInvitesToggled", metadata={"alias": "@type"}
    )
    can_invite_users: Bool


@dataclass(slots=True, kw_only=True)
class ChatEventIsAllHistoryAvailableToggled(BaseObject):
    """
    The is_all_history_available setting of a supergroup was toggled

    :param is_all_history_available: New value of is_all_history_available
    :type is_all_history_available: :class:`Bool`
    """

    ID: typing.Literal["chatEventIsAllHistoryAvailableToggled"] = field(
        default="chatEventIsAllHistoryAvailableToggled", metadata={"alias": "@type"}
    )
    is_all_history_available: Bool


@dataclass(slots=True, kw_only=True)
class ChatEventIsForumToggled(BaseObject):
    """
    The is_forum setting of a channel was toggled

    :param is_forum: New value of is_forum
    :type is_forum: :class:`Bool`
    """

    ID: typing.Literal["chatEventIsForumToggled"] = field(
        default="chatEventIsForumToggled", metadata={"alias": "@type"}
    )
    is_forum: Bool


@dataclass(slots=True, kw_only=True)
class ChatEventLinkedChatChanged(BaseObject):
    """
    The linked chat of a supergroup was changed

    :param old_linked_chat_id: Previous supergroup linked chat identifier
    :type old_linked_chat_id: :class:`Int53`
    :param new_linked_chat_id: New supergroup linked chat identifier
    :type new_linked_chat_id: :class:`Int53`
    """

    ID: typing.Literal["chatEventLinkedChatChanged"] = field(
        default="chatEventLinkedChatChanged", metadata={"alias": "@type"}
    )
    old_linked_chat_id: Int53
    new_linked_chat_id: Int53


@dataclass(slots=True, kw_only=True)
class ChatEventLocationChanged(BaseObject):
    """
    The supergroup location was changed

    :param old_location: Previous location; may be null, defaults to None
    :type old_location: :class:`ChatLocation`, optional
    :param new_location: New location; may be null, defaults to None
    :type new_location: :class:`ChatLocation`, optional
    """

    ID: typing.Literal["chatEventLocationChanged"] = field(
        default="chatEventLocationChanged", metadata={"alias": "@type"}
    )
    old_location: typing.Optional[ChatLocation] = field(default=None)
    new_location: typing.Optional[ChatLocation] = field(default=None)


@dataclass(slots=True, kw_only=True)
class ChatEventMemberInvited(BaseObject):
    """
    A new chat member was invited

    :param user_id: New member user identifier
    :type user_id: :class:`Int53`
    :param status: New member status
    :type status: :class:`ChatMemberStatus`
    """

    ID: typing.Literal["chatEventMemberInvited"] = field(default="chatEventMemberInvited", metadata={"alias": "@type"})
    user_id: Int53
    status: ChatMemberStatus


@dataclass(slots=True, kw_only=True)
class ChatEventMemberJoined(BaseObject):
    """
    A new member joined the chat
    """

    ID: typing.Literal["chatEventMemberJoined"] = field(default="chatEventMemberJoined", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ChatEventMemberJoinedByInviteLink(BaseObject):
    """
    A new member joined the chat via an invite link

    :param invite_link: Invite link used to join the chat
    :type invite_link: :class:`ChatInviteLink`
    :param via_chat_folder_invite_link: True, if the user has joined the chat using an invite link for a chat folder
    :type via_chat_folder_invite_link: :class:`Bool`
    """

    ID: typing.Literal["chatEventMemberJoinedByInviteLink"] = field(
        default="chatEventMemberJoinedByInviteLink", metadata={"alias": "@type"}
    )
    invite_link: ChatInviteLink
    via_chat_folder_invite_link: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatEventMemberJoinedByRequest(BaseObject):
    """
    A new member was accepted to the chat by an administrator

    :param approver_user_id: User identifier of the chat administrator, approved user join request
    :type approver_user_id: :class:`Int53`
    :param invite_link: Invite link used to join the chat; may be null, defaults to None
    :type invite_link: :class:`ChatInviteLink`, optional
    """

    ID: typing.Literal["chatEventMemberJoinedByRequest"] = field(
        default="chatEventMemberJoinedByRequest", metadata={"alias": "@type"}
    )
    approver_user_id: Int53
    invite_link: typing.Optional[ChatInviteLink] = field(default=None)


@dataclass(slots=True, kw_only=True)
class ChatEventMemberLeft(BaseObject):
    """
    A member left the chat
    """

    ID: typing.Literal["chatEventMemberLeft"] = field(default="chatEventMemberLeft", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ChatEventMemberPromoted(BaseObject):
    """
    A chat member has gained/lost administrator status, or the list of their administrator privileges has changed

    :param user_id: Affected chat member user identifier
    :type user_id: :class:`Int53`
    :param old_status: Previous status of the chat member
    :type old_status: :class:`ChatMemberStatus`
    :param new_status: New status of the chat member
    :type new_status: :class:`ChatMemberStatus`
    """

    ID: typing.Literal["chatEventMemberPromoted"] = field(
        default="chatEventMemberPromoted", metadata={"alias": "@type"}
    )
    user_id: Int53
    old_status: ChatMemberStatus
    new_status: ChatMemberStatus


@dataclass(slots=True, kw_only=True)
class ChatEventMemberRestricted(BaseObject):
    """
    A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed

    :param member_id: Affected chat member identifier
    :type member_id: :class:`MessageSender`
    :param old_status: Previous status of the chat member
    :type old_status: :class:`ChatMemberStatus`
    :param new_status: New status of the chat member
    :type new_status: :class:`ChatMemberStatus`
    """

    ID: typing.Literal["chatEventMemberRestricted"] = field(
        default="chatEventMemberRestricted", metadata={"alias": "@type"}
    )
    member_id: MessageSender
    old_status: ChatMemberStatus
    new_status: ChatMemberStatus


@dataclass(slots=True, kw_only=True)
class ChatEventMemberSubscriptionExtended(BaseObject):
    """
    A chat member extended their subscription to the chat

    :param user_id: Affected chat member user identifier
    :type user_id: :class:`Int53`
    :param old_status: Previous status of the chat member
    :type old_status: :class:`ChatMemberStatus`
    :param new_status: New status of the chat member
    :type new_status: :class:`ChatMemberStatus`
    """

    ID: typing.Literal["chatEventMemberSubscriptionExtended"] = field(
        default="chatEventMemberSubscriptionExtended", metadata={"alias": "@type"}
    )
    user_id: Int53
    old_status: ChatMemberStatus
    new_status: ChatMemberStatus


@dataclass(slots=True, kw_only=True)
class ChatEventMessageAutoDeleteTimeChanged(BaseObject):
    """
    The message auto-delete timer was changed

    :param old_message_auto_delete_time: Previous value of message_auto_delete_time
    :type old_message_auto_delete_time: :class:`Int32`
    :param new_message_auto_delete_time: New value of message_auto_delete_time
    :type new_message_auto_delete_time: :class:`Int32`
    """

    ID: typing.Literal["chatEventMessageAutoDeleteTimeChanged"] = field(
        default="chatEventMessageAutoDeleteTimeChanged", metadata={"alias": "@type"}
    )
    old_message_auto_delete_time: Int32
    new_message_auto_delete_time: Int32


@dataclass(slots=True, kw_only=True)
class ChatEventMessageDeleted(BaseObject):
    """
    A message was deleted

    :param message: Deleted message
    :type message: :class:`Message`
    :param can_report_anti_spam_false_positive: True, if the message deletion can be reported via reportSupergroupAntiSpamFalsePositive
    :type can_report_anti_spam_false_positive: :class:`Bool`
    """

    ID: typing.Literal["chatEventMessageDeleted"] = field(
        default="chatEventMessageDeleted", metadata={"alias": "@type"}
    )
    message: Message
    can_report_anti_spam_false_positive: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatEventMessageEdited(BaseObject):
    """
    A message was edited

    :param old_message: The original message before the edit
    :type old_message: :class:`Message`
    :param new_message: The message after it was edited
    :type new_message: :class:`Message`
    """

    ID: typing.Literal["chatEventMessageEdited"] = field(default="chatEventMessageEdited", metadata={"alias": "@type"})
    old_message: Message
    new_message: Message


@dataclass(slots=True, kw_only=True)
class ChatEventMessagePinned(BaseObject):
    """
    A message was pinned

    :param message: Pinned message
    :type message: :class:`Message`
    """

    ID: typing.Literal["chatEventMessagePinned"] = field(default="chatEventMessagePinned", metadata={"alias": "@type"})
    message: Message


@dataclass(slots=True, kw_only=True)
class ChatEventMessageUnpinned(BaseObject):
    """
    A message was unpinned

    :param message: Unpinned message
    :type message: :class:`Message`
    """

    ID: typing.Literal["chatEventMessageUnpinned"] = field(
        default="chatEventMessageUnpinned", metadata={"alias": "@type"}
    )
    message: Message


@dataclass(slots=True, kw_only=True)
class ChatEventPermissionsChanged(BaseObject):
    """
    The chat permissions were changed

    :param old_permissions: Previous chat permissions
    :type old_permissions: :class:`ChatPermissions`
    :param new_permissions: New chat permissions
    :type new_permissions: :class:`ChatPermissions`
    """

    ID: typing.Literal["chatEventPermissionsChanged"] = field(
        default="chatEventPermissionsChanged", metadata={"alias": "@type"}
    )
    old_permissions: ChatPermissions
    new_permissions: ChatPermissions


@dataclass(slots=True, kw_only=True)
class ChatEventPhotoChanged(BaseObject):
    """
    The chat photo was changed

    :param old_photo: Previous chat photo value; may be null, defaults to None
    :type old_photo: :class:`ChatPhoto`, optional
    :param new_photo: New chat photo value; may be null, defaults to None
    :type new_photo: :class:`ChatPhoto`, optional
    """

    ID: typing.Literal["chatEventPhotoChanged"] = field(default="chatEventPhotoChanged", metadata={"alias": "@type"})
    old_photo: typing.Optional[ChatPhoto] = field(default=None)
    new_photo: typing.Optional[ChatPhoto] = field(default=None)


@dataclass(slots=True, kw_only=True)
class ChatEventPollStopped(BaseObject):
    """
    A poll in a message was stopped

    :param message: The message with the poll
    :type message: :class:`Message`
    """

    ID: typing.Literal["chatEventPollStopped"] = field(default="chatEventPollStopped", metadata={"alias": "@type"})
    message: Message


@dataclass(slots=True, kw_only=True)
class ChatEventProfileAccentColorChanged(BaseObject):
    """
    The chat's profile accent color or profile background custom emoji were changed

    :param old_profile_accent_color_id: Previous identifier of chat's profile accent color; -1 if none
    :type old_profile_accent_color_id: :class:`Int32`
    :param new_profile_accent_color_id: New identifier of chat's profile accent color; -1 if none
    :type new_profile_accent_color_id: :class:`Int32`
    :param old_profile_background_custom_emoji_id: Previous identifier of the custom emoji; 0 if none, defaults to None
    :type old_profile_background_custom_emoji_id: :class:`Int64`, optional
    :param new_profile_background_custom_emoji_id: New identifier of the custom emoji; 0 if none, defaults to None
    :type new_profile_background_custom_emoji_id: :class:`Int64`, optional
    """

    ID: typing.Literal["chatEventProfileAccentColorChanged"] = field(
        default="chatEventProfileAccentColorChanged", metadata={"alias": "@type"}
    )
    old_profile_accent_color_id: Int32
    new_profile_accent_color_id: Int32
    old_profile_background_custom_emoji_id: typing.Optional[Int64] = field(default=0)
    new_profile_background_custom_emoji_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatEventShowMessageSenderToggled(BaseObject):
    """
    The show_message_sender setting of a channel was toggled

    :param show_message_sender: New value of show_message_sender
    :type show_message_sender: :class:`Bool`
    """

    ID: typing.Literal["chatEventShowMessageSenderToggled"] = field(
        default="chatEventShowMessageSenderToggled", metadata={"alias": "@type"}
    )
    show_message_sender: Bool


@dataclass(slots=True, kw_only=True)
class ChatEventSignMessagesToggled(BaseObject):
    """
    The sign_messages setting of a channel was toggled

    :param sign_messages: New value of sign_messages
    :type sign_messages: :class:`Bool`
    """

    ID: typing.Literal["chatEventSignMessagesToggled"] = field(
        default="chatEventSignMessagesToggled", metadata={"alias": "@type"}
    )
    sign_messages: Bool


@dataclass(slots=True, kw_only=True)
class ChatEventSlowModeDelayChanged(BaseObject):
    """
    The slow_mode_delay setting of a supergroup was changed

    :param old_slow_mode_delay: Previous value of slow_mode_delay, in seconds
    :type old_slow_mode_delay: :class:`Int32`
    :param new_slow_mode_delay: New value of slow_mode_delay, in seconds
    :type new_slow_mode_delay: :class:`Int32`
    """

    ID: typing.Literal["chatEventSlowModeDelayChanged"] = field(
        default="chatEventSlowModeDelayChanged", metadata={"alias": "@type"}
    )
    old_slow_mode_delay: Int32
    new_slow_mode_delay: Int32


@dataclass(slots=True, kw_only=True)
class ChatEventStickerSetChanged(BaseObject):
    """
    The supergroup sticker set was changed

    :param old_sticker_set_id: Previous identifier of the chat sticker set; 0 if none, defaults to None
    :type old_sticker_set_id: :class:`Int64`, optional
    :param new_sticker_set_id: New identifier of the chat sticker set; 0 if none, defaults to None
    :type new_sticker_set_id: :class:`Int64`, optional
    """

    ID: typing.Literal["chatEventStickerSetChanged"] = field(
        default="chatEventStickerSetChanged", metadata={"alias": "@type"}
    )
    old_sticker_set_id: typing.Optional[Int64] = field(default=0)
    new_sticker_set_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatEventTitleChanged(BaseObject):
    """
    The chat title was changed

    :param old_title: Previous chat title
    :type old_title: :class:`String`
    :param new_title: New chat title
    :type new_title: :class:`String`
    """

    ID: typing.Literal["chatEventTitleChanged"] = field(default="chatEventTitleChanged", metadata={"alias": "@type"})
    old_title: String
    new_title: String


@dataclass(slots=True, kw_only=True)
class ChatEventUsernameChanged(BaseObject):
    """
    The chat editable username was changed

    :param old_username: Previous chat username
    :type old_username: :class:`String`
    :param new_username: New chat username
    :type new_username: :class:`String`
    """

    ID: typing.Literal["chatEventUsernameChanged"] = field(
        default="chatEventUsernameChanged", metadata={"alias": "@type"}
    )
    old_username: String
    new_username: String


@dataclass(slots=True, kw_only=True)
class ChatEventVideoChatCreated(BaseObject):
    """
    A video chat was created

    :param group_call_id: Identifier of the video chat. The video chat can be received through the method getGroupCall
    :type group_call_id: :class:`Int32`
    """

    ID: typing.Literal["chatEventVideoChatCreated"] = field(
        default="chatEventVideoChatCreated", metadata={"alias": "@type"}
    )
    group_call_id: Int32


@dataclass(slots=True, kw_only=True)
class ChatEventVideoChatEnded(BaseObject):
    """
    A video chat was ended

    :param group_call_id: Identifier of the video chat. The video chat can be received through the method getGroupCall
    :type group_call_id: :class:`Int32`
    """

    ID: typing.Literal["chatEventVideoChatEnded"] = field(
        default="chatEventVideoChatEnded", metadata={"alias": "@type"}
    )
    group_call_id: Int32


@dataclass(slots=True, kw_only=True)
class ChatEventVideoChatMuteNewParticipantsToggled(BaseObject):
    """
    The mute_new_participants setting of a video chat was toggled

    :param mute_new_participants: New value of the mute_new_participants setting
    :type mute_new_participants: :class:`Bool`
    """

    ID: typing.Literal["chatEventVideoChatMuteNewParticipantsToggled"] = field(
        default="chatEventVideoChatMuteNewParticipantsToggled", metadata={"alias": "@type"}
    )
    mute_new_participants: Bool


@dataclass(slots=True, kw_only=True)
class ChatEventVideoChatParticipantIsMutedToggled(BaseObject):
    """
    A video chat participant was muted or unmuted

    :param participant_id: Identifier of the affected group call participant
    :type participant_id: :class:`MessageSender`
    :param is_muted: New value of is_muted
    :type is_muted: :class:`Bool`
    """

    ID: typing.Literal["chatEventVideoChatParticipantIsMutedToggled"] = field(
        default="chatEventVideoChatParticipantIsMutedToggled", metadata={"alias": "@type"}
    )
    participant_id: MessageSender
    is_muted: Bool


@dataclass(slots=True, kw_only=True)
class ChatEventVideoChatParticipantVolumeLevelChanged(BaseObject):
    """
    A video chat participant volume level was changed

    :param participant_id: Identifier of the affected group call participant
    :type participant_id: :class:`MessageSender`
    :param volume_level: New value of volume_level; 1-20000 in hundreds of percents
    :type volume_level: :class:`Int32`
    """

    ID: typing.Literal["chatEventVideoChatParticipantVolumeLevelChanged"] = field(
        default="chatEventVideoChatParticipantVolumeLevelChanged", metadata={"alias": "@type"}
    )
    participant_id: MessageSender
    volume_level: Int32


ChatEventAction = typing.Union[
    ChatEventAccentColorChanged,
    ChatEventActiveUsernamesChanged,
    ChatEventAvailableReactionsChanged,
    ChatEventBackgroundChanged,
    ChatEventCustomEmojiStickerSetChanged,
    ChatEventDescriptionChanged,
    ChatEventEmojiStatusChanged,
    ChatEventForumTopicCreated,
    ChatEventForumTopicDeleted,
    ChatEventForumTopicEdited,
    ChatEventForumTopicPinned,
    ChatEventForumTopicToggleIsClosed,
    ChatEventForumTopicToggleIsHidden,
    ChatEventHasAggressiveAntiSpamEnabledToggled,
    ChatEventHasProtectedContentToggled,
    ChatEventInviteLinkDeleted,
    ChatEventInviteLinkEdited,
    ChatEventInviteLinkRevoked,
    ChatEventInvitesToggled,
    ChatEventIsAllHistoryAvailableToggled,
    ChatEventIsForumToggled,
    ChatEventLinkedChatChanged,
    ChatEventLocationChanged,
    ChatEventMemberInvited,
    ChatEventMemberJoined,
    ChatEventMemberJoinedByInviteLink,
    ChatEventMemberJoinedByRequest,
    ChatEventMemberLeft,
    ChatEventMemberPromoted,
    ChatEventMemberRestricted,
    ChatEventMemberSubscriptionExtended,
    ChatEventMessageAutoDeleteTimeChanged,
    ChatEventMessageDeleted,
    ChatEventMessageEdited,
    ChatEventMessagePinned,
    ChatEventMessageUnpinned,
    ChatEventPermissionsChanged,
    ChatEventPhotoChanged,
    ChatEventPollStopped,
    ChatEventProfileAccentColorChanged,
    ChatEventShowMessageSenderToggled,
    ChatEventSignMessagesToggled,
    ChatEventSlowModeDelayChanged,
    ChatEventStickerSetChanged,
    ChatEventTitleChanged,
    ChatEventUsernameChanged,
    ChatEventVideoChatCreated,
    ChatEventVideoChatEnded,
    ChatEventVideoChatMuteNewParticipantsToggled,
    ChatEventVideoChatParticipantIsMutedToggled,
    ChatEventVideoChatParticipantVolumeLevelChanged,
]


@dataclass(slots=True, kw_only=True)
class ChatEventLogFilters(BaseObject):
    """
    Represents a set of filters used to obtain a chat event log

    :param message_edits: True, if message edits need to be returned
    :type message_edits: :class:`Bool`
    :param message_deletions: True, if message deletions need to be returned
    :type message_deletions: :class:`Bool`
    :param message_pins: True, if pin/unpin events need to be returned
    :type message_pins: :class:`Bool`
    :param member_joins: True, if members joining events need to be returned
    :type member_joins: :class:`Bool`
    :param member_leaves: True, if members leaving events need to be returned
    :type member_leaves: :class:`Bool`
    :param member_invites: True, if invited member events need to be returned
    :type member_invites: :class:`Bool`
    :param member_promotions: True, if member promotion/demotion events need to be returned
    :type member_promotions: :class:`Bool`
    :param member_restrictions: True, if member restricted/unrestricted/banned/unbanned events need to be returned
    :type member_restrictions: :class:`Bool`
    :param info_changes: True, if changes in chat information need to be returned
    :type info_changes: :class:`Bool`
    :param setting_changes: True, if changes in chat settings need to be returned
    :type setting_changes: :class:`Bool`
    :param invite_link_changes: True, if changes to invite links need to be returned
    :type invite_link_changes: :class:`Bool`
    :param video_chat_changes: True, if video chat actions need to be returned
    :type video_chat_changes: :class:`Bool`
    :param forum_changes: True, if forum-related actions need to be returned
    :type forum_changes: :class:`Bool`
    :param subscription_extensions: True, if subscription extensions need to be returned
    :type subscription_extensions: :class:`Bool`
    """

    ID: typing.Literal["chatEventLogFilters"] = field(default="chatEventLogFilters", metadata={"alias": "@type"})
    message_edits: Bool = field(default=False)
    message_deletions: Bool = field(default=False)
    message_pins: Bool = field(default=False)
    member_joins: Bool = field(default=False)
    member_leaves: Bool = field(default=False)
    member_invites: Bool = field(default=False)
    member_promotions: Bool = field(default=False)
    member_restrictions: Bool = field(default=False)
    info_changes: Bool = field(default=False)
    setting_changes: Bool = field(default=False)
    invite_link_changes: Bool = field(default=False)
    video_chat_changes: Bool = field(default=False)
    forum_changes: Bool = field(default=False)
    subscription_extensions: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatEvents(BaseObject):
    """
    Contains a list of chat events

    :param events: List of events
    :type events: :class:`Vector[ChatEvent]`
    """

    ID: typing.Literal["chatEvents"] = field(default="chatEvents", metadata={"alias": "@type"})
    events: Vector[ChatEvent]


@dataclass(slots=True, kw_only=True)
class ChatFolder(BaseObject):
    """
    Represents a folder for user chats

    :param name: The name of the folder
    :type name: :class:`ChatFolderName`
    :param color_id: The identifier of the chosen color for the chat folder icon; from -1 to 6. If -1, then color is disabled. Can't be changed if folder tags are disabled or the current user doesn't have Telegram Premium subscription
    :type color_id: :class:`Int32`
    :param pinned_chat_ids: The chat identifiers of pinned chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
    :type pinned_chat_ids: :class:`Vector[Int53]`
    :param included_chat_ids: The chat identifiers of always included chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
    :type included_chat_ids: :class:`Vector[Int53]`
    :param excluded_chat_ids: The chat identifiers of always excluded chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") always excluded non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
    :type excluded_chat_ids: :class:`Vector[Int53]`
    :param icon: The chosen icon for the chat folder; may be null. If null, use getChatFolderDefaultIconName to get default icon name for the folder, defaults to None
    :type icon: :class:`ChatFolderIcon`, optional
    :param is_shareable: True, if at least one link has been created for the folder
    :type is_shareable: :class:`Bool`
    :param exclude_muted: True, if muted chats need to be excluded
    :type exclude_muted: :class:`Bool`
    :param exclude_read: True, if read chats need to be excluded
    :type exclude_read: :class:`Bool`
    :param exclude_archived: True, if archived chats need to be excluded
    :type exclude_archived: :class:`Bool`
    :param include_contacts: True, if contacts need to be included
    :type include_contacts: :class:`Bool`
    :param include_non_contacts: True, if non-contact users need to be included
    :type include_non_contacts: :class:`Bool`
    :param include_bots: True, if bots need to be included
    :type include_bots: :class:`Bool`
    :param include_groups: True, if basic groups and supergroups need to be included
    :type include_groups: :class:`Bool`
    :param include_channels: True, if channels need to be included
    :type include_channels: :class:`Bool`
    """

    ID: typing.Literal["chatFolder"] = field(default="chatFolder", metadata={"alias": "@type"})
    name: ChatFolderName
    color_id: Int32
    pinned_chat_ids: Vector[Int53]
    included_chat_ids: Vector[Int53]
    excluded_chat_ids: Vector[Int53]
    icon: typing.Optional[ChatFolderIcon] = field(default=None)
    is_shareable: Bool = field(default=False)
    exclude_muted: Bool = field(default=False)
    exclude_read: Bool = field(default=False)
    exclude_archived: Bool = field(default=False)
    include_contacts: Bool = field(default=False)
    include_non_contacts: Bool = field(default=False)
    include_bots: Bool = field(default=False)
    include_groups: Bool = field(default=False)
    include_channels: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatFolderIcon(BaseObject):
    """
    Represents an icon for a chat folder

    :param name: The chosen icon name for short folder representation; one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money", "Note", "Palette"
    :type name: :class:`String`
    """

    ID: typing.Literal["chatFolderIcon"] = field(default="chatFolderIcon", metadata={"alias": "@type"})
    name: String


@dataclass(slots=True, kw_only=True)
class ChatFolderInfo(BaseObject):
    """
    Contains basic information about a chat folder

    :param id: Unique chat folder identifier
    :type id: :class:`Int32`
    :param name: The name of the folder
    :type name: :class:`ChatFolderName`
    :param icon: The chosen or default icon for the chat folder
    :type icon: :class:`ChatFolderIcon`
    :param color_id: The identifier of the chosen color for the chat folder icon; from -1 to 6. If -1, then color is disabled
    :type color_id: :class:`Int32`
    :param is_shareable: True, if at least one link has been created for the folder
    :type is_shareable: :class:`Bool`
    :param has_my_invite_links: True, if the chat folder has invite links created by the current user
    :type has_my_invite_links: :class:`Bool`
    """

    ID: typing.Literal["chatFolderInfo"] = field(default="chatFolderInfo", metadata={"alias": "@type"})
    id: Int32
    name: ChatFolderName
    icon: ChatFolderIcon
    color_id: Int32
    is_shareable: Bool = field(default=False)
    has_my_invite_links: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatFolderInviteLink(BaseObject):
    """
    Contains a chat folder invite link

    :param invite_link: The chat folder invite link
    :type invite_link: :class:`String`
    :param name: Name of the link
    :type name: :class:`String`
    :param chat_ids: Identifiers of chats, included in the link
    :type chat_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["chatFolderInviteLink"] = field(default="chatFolderInviteLink", metadata={"alias": "@type"})
    invite_link: String
    name: String
    chat_ids: Vector[Int53]


@dataclass(slots=True, kw_only=True)
class ChatFolderInviteLinkInfo(BaseObject):
    """
    Contains information about an invite link to a chat folder

    :param missing_chat_ids: Identifiers of the chats from the link, which aren't added to the folder yet
    :type missing_chat_ids: :class:`Vector[Int53]`
    :param added_chat_ids: Identifiers of the chats from the link, which are added to the folder already
    :type added_chat_ids: :class:`Vector[Int53]`
    :param chat_folder_info: Basic information about the chat folder; chat folder identifier will be 0 if the user didn't have the chat folder yet
    :type chat_folder_info: :class:`ChatFolderInfo`
    """

    ID: typing.Literal["chatFolderInviteLinkInfo"] = field(
        default="chatFolderInviteLinkInfo", metadata={"alias": "@type"}
    )
    missing_chat_ids: Vector[Int53]
    added_chat_ids: Vector[Int53]
    chat_folder_info: ChatFolderInfo = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatFolderInviteLinks(BaseObject):
    """
    Represents a list of chat folder invite links

    :param invite_links: List of the invite links
    :type invite_links: :class:`Vector[ChatFolderInviteLink]`
    """

    ID: typing.Literal["chatFolderInviteLinks"] = field(default="chatFolderInviteLinks", metadata={"alias": "@type"})
    invite_links: Vector[ChatFolderInviteLink]


@dataclass(slots=True, kw_only=True)
class ChatFolderName(BaseObject):
    """
    Describes name of a chat folder

    :param text: The text of the chat folder name; 1-12 characters without line feeds. May contain only CustomEmoji entities
    :type text: :class:`FormattedText`
    :param animate_custom_emoji: True, if custom emoji in the name must be animated
    :type animate_custom_emoji: :class:`Bool`
    """

    ID: typing.Literal["chatFolderName"] = field(default="chatFolderName", metadata={"alias": "@type"})
    text: FormattedText
    animate_custom_emoji: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatInviteLink(BaseObject):
    """
    Contains a chat invite link

    :param invite_link: Chat invite link
    :type invite_link: :class:`String`
    :param name: Name of the link
    :type name: :class:`String`
    :param creator_user_id: User identifier of an administrator created the link
    :type creator_user_id: :class:`Int53`
    :param date: Point in time (Unix timestamp) when the link was created
    :type date: :class:`Int32`
    :param member_count: Number of chat members, which joined the chat using the link
    :type member_count: :class:`Int32`
    :param expired_member_count: Number of chat members, which joined the chat using the link, but have already left because of expired subscription; for subscription links only
    :type expired_member_count: :class:`Int32`
    :param pending_join_request_count: Number of pending join requests created using this link
    :type pending_join_request_count: :class:`Int32`
    :param subscription_pricing: Information about subscription plan that is applied to the users joining the chat by the link; may be null if the link doesn't require subscription, defaults to None
    :type subscription_pricing: :class:`StarSubscriptionPricing`, optional
    :param edit_date: Point in time (Unix timestamp) when the link was last edited; 0 if never or unknown
    :type edit_date: :class:`Int32`
    :param expiration_date: Point in time (Unix timestamp) when the link will expire; 0 if never
    :type expiration_date: :class:`Int32`
    :param member_limit: The maximum number of members, which can join the chat using the link simultaneously; 0 if not limited. Always 0 if the link requires approval
    :type member_limit: :class:`Int32`
    :param creates_join_request: True, if the link only creates join request. If true, total number of joining members will be unlimited
    :type creates_join_request: :class:`Bool`
    :param is_primary: True, if the link is primary. Primary invite link can't have name, expiration date, or usage limit. There is exactly one primary invite link for each administrator with can_invite_users right at a given time
    :type is_primary: :class:`Bool`
    :param is_revoked: True, if the link was revoked
    :type is_revoked: :class:`Bool`
    """

    ID: typing.Literal["chatInviteLink"] = field(default="chatInviteLink", metadata={"alias": "@type"})
    invite_link: String
    name: String
    creator_user_id: Int53
    date: Int32
    member_count: Int32
    expired_member_count: Int32
    pending_join_request_count: Int32
    subscription_pricing: typing.Optional[StarSubscriptionPricing] = field(default=None)
    edit_date: Int32 = field(default=0)
    expiration_date: Int32 = field(default=0)
    member_limit: Int32 = field(default=0)
    creates_join_request: Bool = field(default=False)
    is_primary: Bool = field(default=False)
    is_revoked: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatInviteLinkCount(BaseObject):
    """
    Describes a chat administrator with a number of active and revoked chat invite links

    :param user_id: Administrator's user identifier
    :type user_id: :class:`Int53`
    :param invite_link_count: Number of active invite links
    :type invite_link_count: :class:`Int32`
    :param revoked_invite_link_count: Number of revoked invite links
    :type revoked_invite_link_count: :class:`Int32`
    """

    ID: typing.Literal["chatInviteLinkCount"] = field(default="chatInviteLinkCount", metadata={"alias": "@type"})
    user_id: Int53
    invite_link_count: Int32
    revoked_invite_link_count: Int32


@dataclass(slots=True, kw_only=True)
class ChatInviteLinkCounts(BaseObject):
    """
    Contains a list of chat invite link counts

    :param invite_link_counts: List of invite link counts
    :type invite_link_counts: :class:`Vector[ChatInviteLinkCount]`
    """

    ID: typing.Literal["chatInviteLinkCounts"] = field(default="chatInviteLinkCounts", metadata={"alias": "@type"})
    invite_link_counts: Vector[ChatInviteLinkCount]


@dataclass(slots=True, kw_only=True)
class ChatInviteLinkInfo(BaseObject):
    """
    Contains information about a chat invite link

    :param accessible_for: If non-zero, the amount of time for which read access to the chat will remain available, in seconds
    :type accessible_for: :class:`Int32`
    :param type_: Type of the chat
    :type type_: :class:`InviteLinkChatType`
    :param title: Title of the chat
    :type title: :class:`String`
    :param accent_color_id: Identifier of the accent color for chat title and background of chat photo
    :type accent_color_id: :class:`Int32`
    :param description: Chat description
    :type description: :class:`String`
    :param member_count: Number of members in the chat
    :type member_count: :class:`Int32`
    :param member_user_ids: User identifiers of some chat members that may be known to the current user
    :type member_user_ids: :class:`Vector[Int53]`
    :param photo: Chat photo; may be null, defaults to None
    :type photo: :class:`ChatPhotoInfo`, optional
    :param subscription_info: Information about subscription plan that must be paid by the user to use the link; may be null if the link doesn't require subscription, defaults to None
    :type subscription_info: :class:`ChatInviteLinkSubscriptionInfo`, optional
    :param verification_status: Information about verification status of the chat; may be null if none, defaults to None
    :type verification_status: :class:`VerificationStatus`, optional
    :param chat_id: Chat identifier of the invite link; 0 if the user has no access to the chat before joining
    :type chat_id: :class:`Int53`
    :param creates_join_request: True, if the link only creates join request
    :type creates_join_request: :class:`Bool`
    :param is_public: True, if the chat is a public supergroup or channel, i.e. it has a username or it is a location-based supergroup
    :type is_public: :class:`Bool`
    """

    ID: typing.Literal["chatInviteLinkInfo"] = field(default="chatInviteLinkInfo", metadata={"alias": "@type"})
    accessible_for: Int32
    type_: InviteLinkChatType = field(default=MISSING, metadata={"alias": "type"})
    title: String
    accent_color_id: Int32
    description: String
    member_count: Int32
    member_user_ids: Vector[Int53]
    photo: typing.Optional[ChatPhotoInfo] = field(default=None)
    subscription_info: typing.Optional[ChatInviteLinkSubscriptionInfo] = field(default=None)
    verification_status: typing.Optional[VerificationStatus] = field(default=None)
    chat_id: Int53 = field(default=0)
    creates_join_request: Bool = field(default=False)
    is_public: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatInviteLinkMember(BaseObject):
    """
    Describes a chat member joined a chat via an invite link

    :param user_id: User identifier
    :type user_id: :class:`Int53`
    :param joined_chat_date: Point in time (Unix timestamp) when the user joined the chat
    :type joined_chat_date: :class:`Int32`
    :param approver_user_id: User identifier of the chat administrator, approved user join request
    :type approver_user_id: :class:`Int53`
    :param via_chat_folder_invite_link: True, if the user has joined the chat using an invite link for a chat folder
    :type via_chat_folder_invite_link: :class:`Bool`
    """

    ID: typing.Literal["chatInviteLinkMember"] = field(default="chatInviteLinkMember", metadata={"alias": "@type"})
    user_id: Int53
    joined_chat_date: Int32
    approver_user_id: Int53
    via_chat_folder_invite_link: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatInviteLinkMembers(BaseObject):
    """
    Contains a list of chat members joined a chat via an invite link

    :param total_count: Approximate total number of chat members found
    :type total_count: :class:`Int32`
    :param members: List of chat members, joined a chat via an invite link
    :type members: :class:`Vector[ChatInviteLinkMember]`
    """

    ID: typing.Literal["chatInviteLinkMembers"] = field(default="chatInviteLinkMembers", metadata={"alias": "@type"})
    total_count: Int32
    members: Vector[ChatInviteLinkMember]


@dataclass(slots=True, kw_only=True)
class ChatInviteLinkSubscriptionInfo(BaseObject):
    """
    Contains information about subscription plan that must be paid by the user to use a chat invite link

    :param pricing: Information about subscription plan that must be paid by the user to use the link
    :type pricing: :class:`StarSubscriptionPricing`
    :param can_reuse: True, if the user has already paid for the subscription and can use joinChatByInviteLink to join the subscribed chat again
    :type can_reuse: :class:`Bool`
    :param form_id: Identifier of the payment form to use for subscription payment; 0 if the subscription can't be paid
    :type form_id: :class:`Int64`
    """

    ID: typing.Literal["chatInviteLinkSubscriptionInfo"] = field(
        default="chatInviteLinkSubscriptionInfo", metadata={"alias": "@type"}
    )
    pricing: StarSubscriptionPricing
    can_reuse: Bool = field(default=False)
    form_id: Int64 = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatInviteLinks(BaseObject):
    """
    Contains a list of chat invite links

    :param total_count: Approximate total number of chat invite links found
    :type total_count: :class:`Int32`
    :param invite_links: List of invite links
    :type invite_links: :class:`Vector[ChatInviteLink]`
    """

    ID: typing.Literal["chatInviteLinks"] = field(default="chatInviteLinks", metadata={"alias": "@type"})
    total_count: Int32
    invite_links: Vector[ChatInviteLink]


@dataclass(slots=True, kw_only=True)
class ChatJoinRequest(BaseObject):
    """
    Describes a user that sent a join request and waits for administrator approval

    :param user_id: User identifier
    :type user_id: :class:`Int53`
    :param date: Point in time (Unix timestamp) when the user sent the join request
    :type date: :class:`Int32`
    :param bio: A short bio of the user
    :type bio: :class:`String`
    """

    ID: typing.Literal["chatJoinRequest"] = field(default="chatJoinRequest", metadata={"alias": "@type"})
    user_id: Int53
    date: Int32
    bio: String


@dataclass(slots=True, kw_only=True)
class ChatJoinRequests(BaseObject):
    """
    Contains a list of requests to join a chat

    :param total_count: Approximate total number of requests found
    :type total_count: :class:`Int32`
    :param requests: List of the requests
    :type requests: :class:`Vector[ChatJoinRequest]`
    """

    ID: typing.Literal["chatJoinRequests"] = field(default="chatJoinRequests", metadata={"alias": "@type"})
    total_count: Int32
    requests: Vector[ChatJoinRequest]


@dataclass(slots=True, kw_only=True)
class ChatJoinRequestsInfo(BaseObject):
    """
    Contains information about pending join requests for a chat

    :param total_count: Total number of pending join requests
    :type total_count: :class:`Int32`
    :param user_ids: Identifiers of at most 3 users sent the newest pending join requests
    :type user_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["chatJoinRequestsInfo"] = field(default="chatJoinRequestsInfo", metadata={"alias": "@type"})
    total_count: Int32
    user_ids: Vector[Int53]


@dataclass(slots=True, kw_only=True)
class ChatListArchive(BaseObject):
    """
    A list of chats usually located at the top of the main chat list. Unmuted chats are automatically moved from the Archive to the Main chat list when a new message arrives
    """

    ID: typing.Literal["chatListArchive"] = field(default="chatListArchive", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ChatListFolder(BaseObject):
    """
    A list of chats added to a chat folder

    :param chat_folder_id: Chat folder identifier
    :type chat_folder_id: :class:`Int32`
    """

    ID: typing.Literal["chatListFolder"] = field(default="chatListFolder", metadata={"alias": "@type"})
    chat_folder_id: Int32


@dataclass(slots=True, kw_only=True)
class ChatListMain(BaseObject):
    """
    A main list of chats
    """

    ID: typing.Literal["chatListMain"] = field(default="chatListMain", metadata={"alias": "@type"})


ChatList = typing.Union[
    ChatListArchive,
    ChatListFolder,
    ChatListMain,
]


@dataclass(slots=True, kw_only=True)
class ChatLists(BaseObject):
    """
    Contains a list of chat lists

    :param chat_lists: List of chat lists
    :type chat_lists: :class:`Vector[ChatList]`
    """

    ID: typing.Literal["chatLists"] = field(default="chatLists", metadata={"alias": "@type"})
    chat_lists: Vector[ChatList]


@dataclass(slots=True, kw_only=True)
class ChatLocation(BaseObject):
    """
    Represents a location to which a chat is connected

    :param location: The location
    :type location: :class:`Location`
    :param address: Location address; 1-64 characters, as defined by the chat owner
    :type address: :class:`String`
    """

    ID: typing.Literal["chatLocation"] = field(default="chatLocation", metadata={"alias": "@type"})
    location: Location
    address: String = field(default=MISSING, metadata={"min_length": 1, "max_length": 64})


@dataclass(slots=True, kw_only=True)
class ChatMember(BaseObject):
    """
    Describes a user or a chat as a member of another chat

    :param member_id: Identifier of the chat member. Currently, other chats can be only Left or Banned. Only supergroups and channels can have other chats as Left or Banned members and these chats must be supergroups or channels
    :type member_id: :class:`MessageSender`
    :param joined_chat_date: Point in time (Unix timestamp) when the user joined/was promoted/was banned in the chat
    :type joined_chat_date: :class:`Int32`
    :param status: Status of the member in the chat
    :type status: :class:`ChatMemberStatus`
    :param inviter_user_id: Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown, defaults to None
    :type inviter_user_id: :class:`Int53`, optional
    """

    ID: typing.Literal["chatMember"] = field(default="chatMember", metadata={"alias": "@type"})
    member_id: MessageSender
    joined_chat_date: Int32
    status: ChatMemberStatus
    inviter_user_id: typing.Optional[Int53] = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatMemberStatusAdministrator(BaseObject):
    """
    The user is a member of the chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, ban unprivileged members, and manage video chats. In supergroups and channels, there are more detailed options for administrator privileges

    :param rights: Rights of the administrator
    :type rights: :class:`ChatAdministratorRights`
    :param custom_title: A custom title of the administrator; 0-16 characters without emoji; applicable to supergroups only
    :type custom_title: :class:`String`
    :param can_be_edited: True, if the current user can edit the administrator privileges for the called user
    :type can_be_edited: :class:`Bool`
    """

    ID: typing.Literal["chatMemberStatusAdministrator"] = field(
        default="chatMemberStatusAdministrator", metadata={"alias": "@type"}
    )
    rights: ChatAdministratorRights
    custom_title: String = field(default="", metadata={"max_length": 16})
    can_be_edited: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatMemberStatusBanned(BaseObject):
    """
    The user or the chat was banned (and hence is not a member of the chat). Implies the user can't return to the chat, view messages, or be used as a participant identifier to join a video chat of the chat

    :param banned_until_date: Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Always 0 in basic groups
    :type banned_until_date: :class:`Int32`
    """

    ID: typing.Literal["chatMemberStatusBanned"] = field(default="chatMemberStatusBanned", metadata={"alias": "@type"})
    banned_until_date: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatMemberStatusCreator(BaseObject):
    """
    The user is the owner of the chat and has all the administrator privileges

    :param custom_title: A custom title of the owner; 0-16 characters without emoji; applicable to supergroups only
    :type custom_title: :class:`String`
    :param is_anonymous: True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
    :type is_anonymous: :class:`Bool`
    :param is_member: True, if the user is a member of the chat
    :type is_member: :class:`Bool`
    """

    ID: typing.Literal["chatMemberStatusCreator"] = field(
        default="chatMemberStatusCreator", metadata={"alias": "@type"}
    )
    custom_title: String = field(default="", metadata={"max_length": 16})
    is_anonymous: Bool = field(default=False)
    is_member: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatMemberStatusLeft(BaseObject):
    """
    The user or the chat is not a chat member
    """

    ID: typing.Literal["chatMemberStatusLeft"] = field(default="chatMemberStatusLeft", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ChatMemberStatusMember(BaseObject):
    """
    The user is a member of the chat, without any additional privileges or restrictions

    :param member_until_date: Point in time (Unix timestamp) when the user will be removed from the chat because of the expired subscription; 0 if never. Ignored in setChatMemberStatus
    :type member_until_date: :class:`Int32`
    """

    ID: typing.Literal["chatMemberStatusMember"] = field(default="chatMemberStatusMember", metadata={"alias": "@type"})
    member_until_date: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatMemberStatusRestricted(BaseObject):
    """
    The user is under certain restrictions in the chat. Not supported in basic groups and channels

    :param permissions: User permissions in the chat
    :type permissions: :class:`ChatPermissions`
    :param is_member: True, if the user is a member of the chat
    :type is_member: :class:`Bool`
    :param restricted_until_date: Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever
    :type restricted_until_date: :class:`Int32`
    """

    ID: typing.Literal["chatMemberStatusRestricted"] = field(
        default="chatMemberStatusRestricted", metadata={"alias": "@type"}
    )
    permissions: ChatPermissions
    is_member: Bool = field(default=False)
    restricted_until_date: Int32 = field(default=0)


ChatMemberStatus = typing.Union[
    ChatMemberStatusAdministrator,
    ChatMemberStatusBanned,
    ChatMemberStatusCreator,
    ChatMemberStatusLeft,
    ChatMemberStatusMember,
    ChatMemberStatusRestricted,
]


@dataclass(slots=True, kw_only=True)
class ChatMembers(BaseObject):
    """
    Contains a list of chat members

    :param total_count: Approximate total number of chat members found
    :type total_count: :class:`Int32`
    :param members: A list of chat members
    :type members: :class:`Vector[ChatMember]`
    """

    ID: typing.Literal["chatMembers"] = field(default="chatMembers", metadata={"alias": "@type"})
    total_count: Int32
    members: Vector[ChatMember]


@dataclass(slots=True, kw_only=True)
class ChatMembersFilterAdministrators(BaseObject):
    """
    Returns the owner and administrators
    """

    ID: typing.Literal["chatMembersFilterAdministrators"] = field(
        default="chatMembersFilterAdministrators", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ChatMembersFilterBanned(BaseObject):
    """
    Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel
    """

    ID: typing.Literal["chatMembersFilterBanned"] = field(
        default="chatMembersFilterBanned", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ChatMembersFilterBots(BaseObject):
    """
    Returns bot members of the chat
    """

    ID: typing.Literal["chatMembersFilterBots"] = field(default="chatMembersFilterBots", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ChatMembersFilterContacts(BaseObject):
    """
    Returns contacts of the user
    """

    ID: typing.Literal["chatMembersFilterContacts"] = field(
        default="chatMembersFilterContacts", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ChatMembersFilterMembers(BaseObject):
    """
    Returns all chat members, including restricted chat members
    """

    ID: typing.Literal["chatMembersFilterMembers"] = field(
        default="chatMembersFilterMembers", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ChatMembersFilterMention(BaseObject):
    """
    Returns users which can be mentioned in the chat

    :param message_thread_id: If non-zero, the identifier of the current message thread
    :type message_thread_id: :class:`Int53`
    """

    ID: typing.Literal["chatMembersFilterMention"] = field(
        default="chatMembersFilterMention", metadata={"alias": "@type"}
    )
    message_thread_id: Int53


@dataclass(slots=True, kw_only=True)
class ChatMembersFilterRestricted(BaseObject):
    """
    Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup
    """

    ID: typing.Literal["chatMembersFilterRestricted"] = field(
        default="chatMembersFilterRestricted", metadata={"alias": "@type"}
    )


ChatMembersFilter = typing.Union[
    ChatMembersFilterAdministrators,
    ChatMembersFilterBanned,
    ChatMembersFilterBots,
    ChatMembersFilterContacts,
    ChatMembersFilterMembers,
    ChatMembersFilterMention,
    ChatMembersFilterRestricted,
]


@dataclass(slots=True, kw_only=True)
class ChatMessageSender(BaseObject):
    """
    Represents a message sender, which can be used to send messages in a chat

    :param sender: The message sender
    :type sender: :class:`MessageSender`
    :param needs_premium: True, if Telegram Premium is needed to use the message sender
    :type needs_premium: :class:`Bool`
    """

    ID: typing.Literal["chatMessageSender"] = field(default="chatMessageSender", metadata={"alias": "@type"})
    sender: MessageSender
    needs_premium: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatMessageSenders(BaseObject):
    """
    Represents a list of message senders, which can be used to send messages in a chat

    :param senders: List of available message senders
    :type senders: :class:`Vector[ChatMessageSender]`
    """

    ID: typing.Literal["chatMessageSenders"] = field(default="chatMessageSenders", metadata={"alias": "@type"})
    senders: Vector[ChatMessageSender]


@dataclass(slots=True, kw_only=True)
class ChatNotificationSettings(BaseObject):
    """
    Contains information about notification settings for a chat or a forum topic

    :param mute_for: Time left before notifications will be unmuted, in seconds
    :type mute_for: :class:`Int32`
    :param use_default_mute_for: If true, the value for the relevant type of chat or the forum chat is used instead of mute_for
    :type use_default_mute_for: :class:`Bool`
    :param use_default_sound: If true, the value for the relevant type of chat or the forum chat is used instead of sound_id
    :type use_default_sound: :class:`Bool`
    :param sound_id: Identifier of the notification sound to be played for messages; 0 if sound is disabled
    :type sound_id: :class:`Int64`
    :param use_default_show_preview: If true, the value for the relevant type of chat or the forum chat is used instead of show_preview
    :type use_default_show_preview: :class:`Bool`
    :param show_preview: True, if message content must be displayed in notifications
    :type show_preview: :class:`Bool`
    :param use_default_mute_stories: If true, the value for the relevant type of chat is used instead of mute_stories
    :type use_default_mute_stories: :class:`Bool`
    :param mute_stories: True, if story notifications are disabled for the chat
    :type mute_stories: :class:`Bool`
    :param use_default_story_sound: If true, the value for the relevant type of chat is used instead of story_sound_id
    :type use_default_story_sound: :class:`Bool`
    :param story_sound_id: Identifier of the notification sound to be played for stories; 0 if sound is disabled
    :type story_sound_id: :class:`Int64`
    :param use_default_show_story_sender: If true, the value for the relevant type of chat is used instead of show_story_sender
    :type use_default_show_story_sender: :class:`Bool`
    :param show_story_sender: True, if the sender of stories must be displayed in notifications
    :type show_story_sender: :class:`Bool`
    :param use_default_disable_pinned_message_notifications: If true, the value for the relevant type of chat or the forum chat is used instead of disable_pinned_message_notifications
    :type use_default_disable_pinned_message_notifications: :class:`Bool`
    :param disable_pinned_message_notifications: If true, notifications for incoming pinned messages will be created as for an ordinary unread message
    :type disable_pinned_message_notifications: :class:`Bool`
    :param use_default_disable_mention_notifications: If true, the value for the relevant type of chat or the forum chat is used instead of disable_mention_notifications
    :type use_default_disable_mention_notifications: :class:`Bool`
    :param disable_mention_notifications: If true, notifications for messages with mentions will be created as for an ordinary unread message
    :type disable_mention_notifications: :class:`Bool`
    """

    ID: typing.Literal["chatNotificationSettings"] = field(
        default="chatNotificationSettings", metadata={"alias": "@type"}
    )
    mute_for: Int32
    use_default_mute_for: Bool = field(default=False)
    use_default_sound: Bool = field(default=False)
    sound_id: Int64 = field(default=0)
    use_default_show_preview: Bool = field(default=False)
    show_preview: Bool = field(default=False)
    use_default_mute_stories: Bool = field(default=False)
    mute_stories: Bool = field(default=False)
    use_default_story_sound: Bool = field(default=False)
    story_sound_id: Int64 = field(default=0)
    use_default_show_story_sender: Bool = field(default=False)
    show_story_sender: Bool = field(default=False)
    use_default_disable_pinned_message_notifications: Bool = field(default=False)
    disable_pinned_message_notifications: Bool = field(default=False)
    use_default_disable_mention_notifications: Bool = field(default=False)
    disable_mention_notifications: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatPermissions(BaseObject):
    """
    Describes actions that a user is allowed to take in a chat

    :param can_send_basic_messages: True, if the user can send text messages, contacts, giveaways, giveaway winners, invoices, locations, and venues
    :type can_send_basic_messages: :class:`Bool`
    :param can_send_audios: True, if the user can send music files
    :type can_send_audios: :class:`Bool`
    :param can_send_documents: True, if the user can send documents
    :type can_send_documents: :class:`Bool`
    :param can_send_photos: True, if the user can send photos
    :type can_send_photos: :class:`Bool`
    :param can_send_videos: True, if the user can send videos
    :type can_send_videos: :class:`Bool`
    :param can_send_video_notes: True, if the user can send video notes
    :type can_send_video_notes: :class:`Bool`
    :param can_send_voice_notes: True, if the user can send voice notes
    :type can_send_voice_notes: :class:`Bool`
    :param can_send_polls: True, if the user can send polls
    :type can_send_polls: :class:`Bool`
    :param can_send_other_messages: True, if the user can send animations, games, stickers, and dice and use inline bots
    :type can_send_other_messages: :class:`Bool`
    :param can_add_link_previews: True, if the user may add a link preview to their messages
    :type can_add_link_previews: :class:`Bool`
    :param can_change_info: True, if the user can change the chat title, photo, and other settings
    :type can_change_info: :class:`Bool`
    :param can_invite_users: True, if the user can invite new users to the chat
    :type can_invite_users: :class:`Bool`
    :param can_pin_messages: True, if the user can pin messages
    :type can_pin_messages: :class:`Bool`
    :param can_create_topics: True, if the user can create topics
    :type can_create_topics: :class:`Bool`
    """

    ID: typing.Literal["chatPermissions"] = field(default="chatPermissions", metadata={"alias": "@type"})
    can_send_basic_messages: Bool = field(default=False)
    can_send_audios: Bool = field(default=False)
    can_send_documents: Bool = field(default=False)
    can_send_photos: Bool = field(default=False)
    can_send_videos: Bool = field(default=False)
    can_send_video_notes: Bool = field(default=False)
    can_send_voice_notes: Bool = field(default=False)
    can_send_polls: Bool = field(default=False)
    can_send_other_messages: Bool = field(default=False)
    can_add_link_previews: Bool = field(default=False)
    can_change_info: Bool = field(default=False)
    can_invite_users: Bool = field(default=False)
    can_pin_messages: Bool = field(default=False)
    can_create_topics: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatPhoto(BaseObject):
    """
    Describes a chat or user profile photo

    :param id: Unique photo identifier
    :type id: :class:`Int64`
    :param added_date: Point in time (Unix timestamp) when the photo has been added
    :type added_date: :class:`Int32`
    :param sizes: Available variants of the photo in JPEG format, in different size
    :type sizes: :class:`Vector[PhotoSize]`
    :param minithumbnail: Photo minithumbnail; may be null, defaults to None
    :type minithumbnail: :class:`Minithumbnail`, optional
    :param animation: A big (up to 1280x1280) animated variant of the photo in MPEG4 format; may be null, defaults to None
    :type animation: :class:`AnimatedChatPhoto`, optional
    :param small_animation: A small (160x160) animated variant of the photo in MPEG4 format; may be null even the big animation is available, defaults to None
    :type small_animation: :class:`AnimatedChatPhoto`, optional
    :param sticker: Sticker-based version of the chat photo; may be null, defaults to None
    :type sticker: :class:`ChatPhotoSticker`, optional
    """

    ID: typing.Literal["chatPhoto"] = field(default="chatPhoto", metadata={"alias": "@type"})
    id: Int64
    added_date: Int32
    sizes: Vector[PhotoSize]
    minithumbnail: typing.Optional[Minithumbnail] = field(default=None)
    animation: typing.Optional[AnimatedChatPhoto] = field(default=None)
    small_animation: typing.Optional[AnimatedChatPhoto] = field(default=None)
    sticker: typing.Optional[ChatPhotoSticker] = field(default=None)


@dataclass(slots=True, kw_only=True)
class ChatPhotoInfo(BaseObject):
    """
    Contains basic information about the photo of a chat

    :param small: A small (160x160) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
    :type small: :class:`File`
    :param big: A big (640x640) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
    :type big: :class:`File`
    :param minithumbnail: Chat photo minithumbnail; may be null, defaults to None
    :type minithumbnail: :class:`Minithumbnail`, optional
    :param has_animation: True, if the photo has animated variant
    :type has_animation: :class:`Bool`
    :param is_personal: True, if the photo is visible only for the current user
    :type is_personal: :class:`Bool`
    """

    ID: typing.Literal["chatPhotoInfo"] = field(default="chatPhotoInfo", metadata={"alias": "@type"})
    small: File
    big: File
    minithumbnail: typing.Optional[Minithumbnail] = field(default=None)
    has_animation: Bool = field(default=False)
    is_personal: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatPhotoSticker(BaseObject):
    """
    Information about the sticker, which was used to create the chat photo. The sticker is shown at the center of the photo and occupies at most 67% of it

    :param type_: Type of the sticker
    :type type_: :class:`ChatPhotoStickerType`
    :param background_fill: The fill to be used as background for the sticker; rotation angle in backgroundFillGradient isn't supported
    :type background_fill: :class:`BackgroundFill`
    """

    ID: typing.Literal["chatPhotoSticker"] = field(default="chatPhotoSticker", metadata={"alias": "@type"})
    type_: ChatPhotoStickerType = field(default=MISSING, metadata={"alias": "type"})
    background_fill: BackgroundFill


@dataclass(slots=True, kw_only=True)
class ChatPhotoStickerTypeCustomEmoji(BaseObject):
    """
    Information about the custom emoji, which was used to create the chat photo

    :param custom_emoji_id: Identifier of the custom emoji
    :type custom_emoji_id: :class:`Int64`
    """

    ID: typing.Literal["chatPhotoStickerTypeCustomEmoji"] = field(
        default="chatPhotoStickerTypeCustomEmoji", metadata={"alias": "@type"}
    )
    custom_emoji_id: Int64


@dataclass(slots=True, kw_only=True)
class ChatPhotoStickerTypeRegularOrMask(BaseObject):
    """
    Information about the sticker, which was used to create the chat photo

    :param sticker_set_id: Sticker set identifier
    :type sticker_set_id: :class:`Int64`
    :param sticker_id: Identifier of the sticker in the set
    :type sticker_id: :class:`Int64`
    """

    ID: typing.Literal["chatPhotoStickerTypeRegularOrMask"] = field(
        default="chatPhotoStickerTypeRegularOrMask", metadata={"alias": "@type"}
    )
    sticker_set_id: Int64
    sticker_id: Int64


ChatPhotoStickerType = typing.Union[
    ChatPhotoStickerTypeCustomEmoji,
    ChatPhotoStickerTypeRegularOrMask,
]


@dataclass(slots=True, kw_only=True)
class ChatPhotos(BaseObject):
    """
    Contains a list of chat or user profile photos

    :param total_count: Total number of photos
    :type total_count: :class:`Int32`
    :param photos: List of photos
    :type photos: :class:`Vector[ChatPhoto]`
    """

    ID: typing.Literal["chatPhotos"] = field(default="chatPhotos", metadata={"alias": "@type"})
    total_count: Int32
    photos: Vector[ChatPhoto]


@dataclass(slots=True, kw_only=True)
class ChatPosition(BaseObject):
    """
    Describes a position of a chat in a chat list

    :param list: The chat list
    :type list: :class:`ChatList`
    :param order: A parameter used to determine order of the chat in the chat list. Chats must be sorted by the pair (order, chat.id) in descending order
    :type order: :class:`Int64`
    :param source: Source of the chat in the chat list; may be null, defaults to None
    :type source: :class:`ChatSource`, optional
    :param is_pinned: True, if the chat is pinned in the chat list
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["chatPosition"] = field(default="chatPosition", metadata={"alias": "@type"})
    list: ChatList
    order: Int64
    source: typing.Optional[ChatSource] = field(default=None)
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatRevenueAmount(BaseObject):
    """
    Contains information about revenue earned from sponsored messages in a chat

    :param cryptocurrency: Cryptocurrency in which revenue is calculated
    :type cryptocurrency: :class:`String`
    :param total_amount: Total amount of the cryptocurrency earned, in the smallest units of the cryptocurrency
    :type total_amount: :class:`Int64`
    :param balance_amount: Amount of the cryptocurrency that isn't withdrawn yet, in the smallest units of the cryptocurrency
    :type balance_amount: :class:`Int64`
    :param available_amount: Amount of the cryptocurrency available for withdrawal, in the smallest units of the cryptocurrency
    :type available_amount: :class:`Int64`
    :param withdrawal_enabled: True, if Telegram Stars can be withdrawn now or later
    :type withdrawal_enabled: :class:`Bool`
    """

    ID: typing.Literal["chatRevenueAmount"] = field(default="chatRevenueAmount", metadata={"alias": "@type"})
    cryptocurrency: String
    total_amount: Int64
    balance_amount: Int64
    available_amount: Int64
    withdrawal_enabled: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ChatRevenueStatistics(BaseObject):
    """
    A detailed statistics about revenue earned from sponsored messages in a chat

    :param revenue_by_hour_graph: A graph containing amount of revenue in a given hour
    :type revenue_by_hour_graph: :class:`StatisticalGraph`
    :param revenue_graph: A graph containing amount of revenue
    :type revenue_graph: :class:`StatisticalGraph`
    :param revenue_amount: Amount of earned revenue
    :type revenue_amount: :class:`ChatRevenueAmount`
    :param usd_rate: Current conversion rate of the cryptocurrency in which revenue is calculated to USD
    :type usd_rate: :class:`Double`
    """

    ID: typing.Literal["chatRevenueStatistics"] = field(default="chatRevenueStatistics", metadata={"alias": "@type"})
    revenue_by_hour_graph: StatisticalGraph
    revenue_graph: StatisticalGraph
    revenue_amount: ChatRevenueAmount
    usd_rate: Double


@dataclass(slots=True, kw_only=True)
class ChatRevenueTransaction(BaseObject):
    """
    Contains a chat revenue transactions

    :param cryptocurrency: Cryptocurrency in which revenue is calculated
    :type cryptocurrency: :class:`String`
    :param cryptocurrency_amount: The withdrawn amount, in the smallest units of the cryptocurrency
    :type cryptocurrency_amount: :class:`Int64`
    :param type_: Type of the transaction
    :type type_: :class:`ChatRevenueTransactionType`
    """

    ID: typing.Literal["chatRevenueTransaction"] = field(default="chatRevenueTransaction", metadata={"alias": "@type"})
    cryptocurrency: String
    cryptocurrency_amount: Int64
    type_: ChatRevenueTransactionType = field(default=MISSING, metadata={"alias": "type"})


@dataclass(slots=True, kw_only=True)
class ChatRevenueTransactionTypeEarnings(BaseObject):
    """
    Describes earnings from sponsored messages in a chat in some time frame

    :param start_date: Point in time (Unix timestamp) when the earnings started
    :type start_date: :class:`Int32`
    :param end_date: Point in time (Unix timestamp) when the earnings ended
    :type end_date: :class:`Int32`
    """

    ID: typing.Literal["chatRevenueTransactionTypeEarnings"] = field(
        default="chatRevenueTransactionTypeEarnings", metadata={"alias": "@type"}
    )
    start_date: Int32
    end_date: Int32


@dataclass(slots=True, kw_only=True)
class ChatRevenueTransactionTypeRefund(BaseObject):
    """
    Describes a refund for failed withdrawal of earnings

    :param refund_date: Point in time (Unix timestamp) when the transaction was refunded
    :type refund_date: :class:`Int32`
    :param provider: Name of the payment provider
    :type provider: :class:`String`
    """

    ID: typing.Literal["chatRevenueTransactionTypeRefund"] = field(
        default="chatRevenueTransactionTypeRefund", metadata={"alias": "@type"}
    )
    refund_date: Int32
    provider: String


@dataclass(slots=True, kw_only=True)
class ChatRevenueTransactionTypeWithdrawal(BaseObject):
    """
    Describes a withdrawal of earnings

    :param withdrawal_date: Point in time (Unix timestamp) when the earnings withdrawal started
    :type withdrawal_date: :class:`Int32`
    :param provider: Name of the payment provider
    :type provider: :class:`String`
    :param state: State of the withdrawal
    :type state: :class:`RevenueWithdrawalState`
    """

    ID: typing.Literal["chatRevenueTransactionTypeWithdrawal"] = field(
        default="chatRevenueTransactionTypeWithdrawal", metadata={"alias": "@type"}
    )
    withdrawal_date: Int32
    provider: String
    state: RevenueWithdrawalState


ChatRevenueTransactionType = typing.Union[
    ChatRevenueTransactionTypeEarnings,
    ChatRevenueTransactionTypeRefund,
    ChatRevenueTransactionTypeWithdrawal,
]


@dataclass(slots=True, kw_only=True)
class ChatRevenueTransactions(BaseObject):
    """
    Contains a list of chat revenue transactions

    :param total_count: Total number of transactions
    :type total_count: :class:`Int32`
    :param transactions: List of transactions
    :type transactions: :class:`Vector[ChatRevenueTransaction]`
    """

    ID: typing.Literal["chatRevenueTransactions"] = field(
        default="chatRevenueTransactions", metadata={"alias": "@type"}
    )
    total_count: Int32
    transactions: Vector[ChatRevenueTransaction]


@dataclass(slots=True, kw_only=True)
class ChatSourceMtprotoProxy(BaseObject):
    """
    The chat is sponsored by the user's MTProxy server
    """

    ID: typing.Literal["chatSourceMtprotoProxy"] = field(default="chatSourceMtprotoProxy", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ChatSourcePublicServiceAnnouncement(BaseObject):
    """
    The chat contains a public service announcement

    :param type_: The type of the announcement
    :type type_: :class:`String`
    :param text: The text of the announcement
    :type text: :class:`String`
    """

    ID: typing.Literal["chatSourcePublicServiceAnnouncement"] = field(
        default="chatSourcePublicServiceAnnouncement", metadata={"alias": "@type"}
    )
    type_: String = field(default=MISSING, metadata={"alias": "type"})
    text: String


ChatSource = typing.Union[
    ChatSourceMtprotoProxy,
    ChatSourcePublicServiceAnnouncement,
]


@dataclass(slots=True, kw_only=True)
class ChatStatisticsChannel(BaseObject):
    """
    A detailed statistics about a channel chat

    :param period: A period to which the statistics applies
    :type period: :class:`DateRange`
    :param member_count: Number of members in the chat
    :type member_count: :class:`StatisticalValue`
    :param mean_message_view_count: Mean number of times the recently sent messages were viewed
    :type mean_message_view_count: :class:`StatisticalValue`
    :param mean_message_share_count: Mean number of times the recently sent messages were shared
    :type mean_message_share_count: :class:`StatisticalValue`
    :param mean_message_reaction_count: Mean number of times reactions were added to the recently sent messages
    :type mean_message_reaction_count: :class:`StatisticalValue`
    :param mean_story_view_count: Mean number of times the recently sent stories were viewed
    :type mean_story_view_count: :class:`StatisticalValue`
    :param mean_story_share_count: Mean number of times the recently sent stories were shared
    :type mean_story_share_count: :class:`StatisticalValue`
    :param mean_story_reaction_count: Mean number of times reactions were added to the recently sent stories
    :type mean_story_reaction_count: :class:`StatisticalValue`
    :param enabled_notifications_percentage: A percentage of users with enabled notifications for the chat; 0-100
    :type enabled_notifications_percentage: :class:`Double`
    :param member_count_graph: A graph containing number of members in the chat
    :type member_count_graph: :class:`StatisticalGraph`
    :param join_graph: A graph containing number of members joined and left the chat
    :type join_graph: :class:`StatisticalGraph`
    :param mute_graph: A graph containing number of members muted and unmuted the chat
    :type mute_graph: :class:`StatisticalGraph`
    :param view_count_by_hour_graph: A graph containing number of message views in a given hour in the last two weeks
    :type view_count_by_hour_graph: :class:`StatisticalGraph`
    :param view_count_by_source_graph: A graph containing number of message views per source
    :type view_count_by_source_graph: :class:`StatisticalGraph`
    :param join_by_source_graph: A graph containing number of new member joins per source
    :type join_by_source_graph: :class:`StatisticalGraph`
    :param language_graph: A graph containing number of users viewed chat messages per language
    :type language_graph: :class:`StatisticalGraph`
    :param message_interaction_graph: A graph containing number of chat message views and shares
    :type message_interaction_graph: :class:`StatisticalGraph`
    :param message_reaction_graph: A graph containing number of reactions on messages
    :type message_reaction_graph: :class:`StatisticalGraph`
    :param story_interaction_graph: A graph containing number of story views and shares
    :type story_interaction_graph: :class:`StatisticalGraph`
    :param story_reaction_graph: A graph containing number of reactions on stories
    :type story_reaction_graph: :class:`StatisticalGraph`
    :param instant_view_interaction_graph: A graph containing number of views of associated with the chat instant views
    :type instant_view_interaction_graph: :class:`StatisticalGraph`
    :param recent_interactions: Detailed statistics about number of views and shares of recently sent messages and stories
    :type recent_interactions: :class:`Vector[ChatStatisticsInteractionInfo]`
    """

    ID: typing.Literal["chatStatisticsChannel"] = field(default="chatStatisticsChannel", metadata={"alias": "@type"})
    period: DateRange
    member_count: StatisticalValue
    mean_message_view_count: StatisticalValue
    mean_message_share_count: StatisticalValue
    mean_message_reaction_count: StatisticalValue
    mean_story_view_count: StatisticalValue
    mean_story_share_count: StatisticalValue
    mean_story_reaction_count: StatisticalValue
    enabled_notifications_percentage: Double
    member_count_graph: StatisticalGraph
    join_graph: StatisticalGraph
    mute_graph: StatisticalGraph
    view_count_by_hour_graph: StatisticalGraph
    view_count_by_source_graph: StatisticalGraph
    join_by_source_graph: StatisticalGraph
    language_graph: StatisticalGraph
    message_interaction_graph: StatisticalGraph
    message_reaction_graph: StatisticalGraph
    story_interaction_graph: StatisticalGraph
    story_reaction_graph: StatisticalGraph
    instant_view_interaction_graph: StatisticalGraph
    recent_interactions: Vector[ChatStatisticsInteractionInfo]


@dataclass(slots=True, kw_only=True)
class ChatStatisticsSupergroup(BaseObject):
    """
    A detailed statistics about a supergroup chat

    :param period: A period to which the statistics applies
    :type period: :class:`DateRange`
    :param member_count: Number of members in the chat
    :type member_count: :class:`StatisticalValue`
    :param message_count: Number of messages sent to the chat
    :type message_count: :class:`StatisticalValue`
    :param viewer_count: Number of users who viewed messages in the chat
    :type viewer_count: :class:`StatisticalValue`
    :param sender_count: Number of users who sent messages to the chat
    :type sender_count: :class:`StatisticalValue`
    :param member_count_graph: A graph containing number of members in the chat
    :type member_count_graph: :class:`StatisticalGraph`
    :param join_graph: A graph containing number of members joined and left the chat
    :type join_graph: :class:`StatisticalGraph`
    :param join_by_source_graph: A graph containing number of new member joins per source
    :type join_by_source_graph: :class:`StatisticalGraph`
    :param language_graph: A graph containing distribution of active users per language
    :type language_graph: :class:`StatisticalGraph`
    :param message_content_graph: A graph containing distribution of sent messages by content type
    :type message_content_graph: :class:`StatisticalGraph`
    :param action_graph: A graph containing number of different actions in the chat
    :type action_graph: :class:`StatisticalGraph`
    :param day_graph: A graph containing distribution of message views per hour
    :type day_graph: :class:`StatisticalGraph`
    :param week_graph: A graph containing distribution of message views per day of week
    :type week_graph: :class:`StatisticalGraph`
    :param top_senders: List of users sent most messages in the last week
    :type top_senders: :class:`Vector[ChatStatisticsMessageSenderInfo]`
    :param top_administrators: List of most active administrators in the last week
    :type top_administrators: :class:`Vector[ChatStatisticsAdministratorActionsInfo]`
    :param top_inviters: List of most active inviters of new members in the last week
    :type top_inviters: :class:`Vector[ChatStatisticsInviterInfo]`
    """

    ID: typing.Literal["chatStatisticsSupergroup"] = field(
        default="chatStatisticsSupergroup", metadata={"alias": "@type"}
    )
    period: DateRange
    member_count: StatisticalValue
    message_count: StatisticalValue
    viewer_count: StatisticalValue
    sender_count: StatisticalValue
    member_count_graph: StatisticalGraph
    join_graph: StatisticalGraph
    join_by_source_graph: StatisticalGraph
    language_graph: StatisticalGraph
    message_content_graph: StatisticalGraph
    action_graph: StatisticalGraph
    day_graph: StatisticalGraph
    week_graph: StatisticalGraph
    top_senders: Vector[ChatStatisticsMessageSenderInfo]
    top_administrators: Vector[ChatStatisticsAdministratorActionsInfo]
    top_inviters: Vector[ChatStatisticsInviterInfo]


ChatStatistics = typing.Union[
    ChatStatisticsChannel,
    ChatStatisticsSupergroup,
]


@dataclass(slots=True, kw_only=True)
class ChatStatisticsAdministratorActionsInfo(BaseObject):
    """
    Contains statistics about administrator actions done by a user

    :param user_id: Administrator user identifier
    :type user_id: :class:`Int53`
    :param deleted_message_count: Number of messages deleted by the administrator
    :type deleted_message_count: :class:`Int32`
    :param banned_user_count: Number of users banned by the administrator
    :type banned_user_count: :class:`Int32`
    :param restricted_user_count: Number of users restricted by the administrator
    :type restricted_user_count: :class:`Int32`
    """

    ID: typing.Literal["chatStatisticsAdministratorActionsInfo"] = field(
        default="chatStatisticsAdministratorActionsInfo", metadata={"alias": "@type"}
    )
    user_id: Int53
    deleted_message_count: Int32
    banned_user_count: Int32
    restricted_user_count: Int32


@dataclass(slots=True, kw_only=True)
class ChatStatisticsInteractionInfo(BaseObject):
    """
    Contains statistics about interactions with a message sent in the chat or a story sent by the chat

    :param object_type: Type of the object
    :type object_type: :class:`ChatStatisticsObjectType`
    :param view_count: Number of times the object was viewed
    :type view_count: :class:`Int32`
    :param forward_count: Number of times the object was forwarded
    :type forward_count: :class:`Int32`
    :param reaction_count: Number of times reactions were added to the object
    :type reaction_count: :class:`Int32`
    """

    ID: typing.Literal["chatStatisticsInteractionInfo"] = field(
        default="chatStatisticsInteractionInfo", metadata={"alias": "@type"}
    )
    object_type: ChatStatisticsObjectType
    view_count: Int32
    forward_count: Int32
    reaction_count: Int32


@dataclass(slots=True, kw_only=True)
class ChatStatisticsInviterInfo(BaseObject):
    """
    Contains statistics about number of new members invited by a user

    :param user_id: User identifier
    :type user_id: :class:`Int53`
    :param added_member_count: Number of new members invited by the user
    :type added_member_count: :class:`Int32`
    """

    ID: typing.Literal["chatStatisticsInviterInfo"] = field(
        default="chatStatisticsInviterInfo", metadata={"alias": "@type"}
    )
    user_id: Int53
    added_member_count: Int32


@dataclass(slots=True, kw_only=True)
class ChatStatisticsMessageSenderInfo(BaseObject):
    """
    Contains statistics about messages sent by a user

    :param user_id: User identifier
    :type user_id: :class:`Int53`
    :param sent_message_count: Number of sent messages
    :type sent_message_count: :class:`Int32`
    :param average_character_count: Average number of characters in sent messages; 0 if unknown, defaults to None
    :type average_character_count: :class:`Int32`, optional
    """

    ID: typing.Literal["chatStatisticsMessageSenderInfo"] = field(
        default="chatStatisticsMessageSenderInfo", metadata={"alias": "@type"}
    )
    user_id: Int53
    sent_message_count: Int32
    average_character_count: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class ChatStatisticsObjectTypeMessage(BaseObject):
    """
    Describes a message sent in the chat

    :param message_id: Message identifier
    :type message_id: :class:`Int53`
    """

    ID: typing.Literal["chatStatisticsObjectTypeMessage"] = field(
        default="chatStatisticsObjectTypeMessage", metadata={"alias": "@type"}
    )
    message_id: Int53


@dataclass(slots=True, kw_only=True)
class ChatStatisticsObjectTypeStory(BaseObject):
    """
    Describes a story sent by the chat

    :param story_id: Story identifier
    :type story_id: :class:`Int32`
    """

    ID: typing.Literal["chatStatisticsObjectTypeStory"] = field(
        default="chatStatisticsObjectTypeStory", metadata={"alias": "@type"}
    )
    story_id: Int32


ChatStatisticsObjectType = typing.Union[
    ChatStatisticsObjectTypeMessage,
    ChatStatisticsObjectTypeStory,
]


@dataclass(slots=True, kw_only=True)
class ChatTheme(BaseObject):
    """
    Describes a chat theme

    :param name: Theme name
    :type name: :class:`String`
    :param light_settings: Theme settings for a light chat theme
    :type light_settings: :class:`ThemeSettings`
    :param dark_settings: Theme settings for a dark chat theme
    :type dark_settings: :class:`ThemeSettings`
    """

    ID: typing.Literal["chatTheme"] = field(default="chatTheme", metadata={"alias": "@type"})
    name: String
    light_settings: ThemeSettings
    dark_settings: ThemeSettings


@dataclass(slots=True, kw_only=True)
class ChatTypeBasicGroup(BaseObject):
    """
    A basic group (a chat with 0-200 other users)

    :param basic_group_id: Basic group identifier
    :type basic_group_id: :class:`Int53`
    """

    ID: typing.Literal["chatTypeBasicGroup"] = field(default="chatTypeBasicGroup", metadata={"alias": "@type"})
    basic_group_id: Int53


@dataclass(slots=True, kw_only=True)
class ChatTypePrivate(BaseObject):
    """
    An ordinary chat with a user

    :param user_id: User identifier
    :type user_id: :class:`Int53`
    """

    ID: typing.Literal["chatTypePrivate"] = field(default="chatTypePrivate", metadata={"alias": "@type"})
    user_id: Int53


@dataclass(slots=True, kw_only=True)
class ChatTypeSecret(BaseObject):
    """
    A secret chat with a user

    :param secret_chat_id: Secret chat identifier
    :type secret_chat_id: :class:`Int32`
    :param user_id: User identifier of the other user in the secret chat
    :type user_id: :class:`Int53`
    """

    ID: typing.Literal["chatTypeSecret"] = field(default="chatTypeSecret", metadata={"alias": "@type"})
    secret_chat_id: Int32
    user_id: Int53


@dataclass(slots=True, kw_only=True)
class ChatTypeSupergroup(BaseObject):
    """
    A supergroup or channel (with unlimited members)

    :param supergroup_id: Supergroup or channel identifier
    :type supergroup_id: :class:`Int53`
    :param is_channel: True, if the supergroup is a channel
    :type is_channel: :class:`Bool`
    """

    ID: typing.Literal["chatTypeSupergroup"] = field(default="chatTypeSupergroup", metadata={"alias": "@type"})
    supergroup_id: Int53
    is_channel: Bool = field(default=False)


ChatType = typing.Union[
    ChatTypeBasicGroup,
    ChatTypePrivate,
    ChatTypeSecret,
    ChatTypeSupergroup,
]


@dataclass(slots=True, kw_only=True)
class Chats(BaseObject):
    """
    Represents a list of chats

    :param total_count: Approximate total number of chats found
    :type total_count: :class:`Int32`
    :param chat_ids: List of chat identifiers
    :type chat_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["chats"] = field(default="chats", metadata={"alias": "@type"})
    total_count: Int32
    chat_ids: Vector[Int53]


@dataclass(slots=True, kw_only=True)
class CheckChatUsernameResultOk(BaseObject):
    """
    The username can be set
    """

    ID: typing.Literal["checkChatUsernameResultOk"] = field(
        default="checkChatUsernameResultOk", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CheckChatUsernameResultPublicChatsTooMany(BaseObject):
    """
    The user has too many chats with username, one of them must be made private first
    """

    ID: typing.Literal["checkChatUsernameResultPublicChatsTooMany"] = field(
        default="checkChatUsernameResultPublicChatsTooMany", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CheckChatUsernameResultPublicGroupsUnavailable(BaseObject):
    """
    The user can't be a member of a public supergroup
    """

    ID: typing.Literal["checkChatUsernameResultPublicGroupsUnavailable"] = field(
        default="checkChatUsernameResultPublicGroupsUnavailable", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CheckChatUsernameResultUsernameInvalid(BaseObject):
    """
    The username is invalid
    """

    ID: typing.Literal["checkChatUsernameResultUsernameInvalid"] = field(
        default="checkChatUsernameResultUsernameInvalid", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CheckChatUsernameResultUsernameOccupied(BaseObject):
    """
    The username is occupied
    """

    ID: typing.Literal["checkChatUsernameResultUsernameOccupied"] = field(
        default="checkChatUsernameResultUsernameOccupied", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CheckChatUsernameResultUsernamePurchasable(BaseObject):
    """
    The username can be purchased at https://fragment.com. Information about the username can be received using getCollectibleItemInfo
    """

    ID: typing.Literal["checkChatUsernameResultUsernamePurchasable"] = field(
        default="checkChatUsernameResultUsernamePurchasable", metadata={"alias": "@type"}
    )


CheckChatUsernameResult = typing.Union[
    CheckChatUsernameResultOk,
    CheckChatUsernameResultPublicChatsTooMany,
    CheckChatUsernameResultPublicGroupsUnavailable,
    CheckChatUsernameResultUsernameInvalid,
    CheckChatUsernameResultUsernameOccupied,
    CheckChatUsernameResultUsernamePurchasable,
]


@dataclass(slots=True, kw_only=True)
class CheckStickerSetNameResultNameInvalid(BaseObject):
    """
    The name is invalid
    """

    ID: typing.Literal["checkStickerSetNameResultNameInvalid"] = field(
        default="checkStickerSetNameResultNameInvalid", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CheckStickerSetNameResultNameOccupied(BaseObject):
    """
    The name is occupied
    """

    ID: typing.Literal["checkStickerSetNameResultNameOccupied"] = field(
        default="checkStickerSetNameResultNameOccupied", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class CheckStickerSetNameResultOk(BaseObject):
    """
    The name can be set
    """

    ID: typing.Literal["checkStickerSetNameResultOk"] = field(
        default="checkStickerSetNameResultOk", metadata={"alias": "@type"}
    )


CheckStickerSetNameResult = typing.Union[
    CheckStickerSetNameResultNameInvalid,
    CheckStickerSetNameResultNameOccupied,
    CheckStickerSetNameResultOk,
]


@dataclass(slots=True, kw_only=True)
class CloseBirthdayUser(BaseObject):
    """
    Describes a user that had or will have a birthday soon

    :param user_id: User identifier
    :type user_id: :class:`Int53`
    :param birthdate: Birthdate of the user
    :type birthdate: :class:`Birthdate`
    """

    ID: typing.Literal["closeBirthdayUser"] = field(default="closeBirthdayUser", metadata={"alias": "@type"})
    user_id: Int53
    birthdate: Birthdate


@dataclass(slots=True, kw_only=True)
class ClosedVectorPath(BaseObject):
    """
    Represents a closed vector path. The path begins at the end point of the last command. The coordinate system origin is in the upper-left corner

    :param commands: List of vector path commands
    :type commands: :class:`Vector[VectorPathCommand]`
    """

    ID: typing.Literal["closedVectorPath"] = field(default="closedVectorPath", metadata={"alias": "@type"})
    commands: Vector[VectorPathCommand]


@dataclass(slots=True, kw_only=True)
class CollectibleItemInfo(BaseObject):
    """
    Contains information about a collectible item and its last purchase

    :param purchase_date: Point in time (Unix timestamp) when the item was purchased
    :type purchase_date: :class:`Int32`
    :param currency: Currency for the paid amount
    :type currency: :class:`String`
    :param amount: The paid amount, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param cryptocurrency: Cryptocurrency used to pay for the item
    :type cryptocurrency: :class:`String`
    :param cryptocurrency_amount: The paid amount, in the smallest units of the cryptocurrency
    :type cryptocurrency_amount: :class:`Int64`
    :param url: Individual URL for the item on https://fragment.com
    :type url: :class:`String`
    """

    ID: typing.Literal["collectibleItemInfo"] = field(default="collectibleItemInfo", metadata={"alias": "@type"})
    purchase_date: Int32
    currency: String
    amount: Int53
    cryptocurrency: String
    cryptocurrency_amount: Int64
    url: String


@dataclass(slots=True, kw_only=True)
class CollectibleItemTypePhoneNumber(BaseObject):
    """
    A phone number

    :param phone_number: The phone number
    :type phone_number: :class:`String`
    """

    ID: typing.Literal["collectibleItemTypePhoneNumber"] = field(
        default="collectibleItemTypePhoneNumber", metadata={"alias": "@type"}
    )
    phone_number: String


@dataclass(slots=True, kw_only=True)
class CollectibleItemTypeUsername(BaseObject):
    """
    A username

    :param username: The username
    :type username: :class:`String`
    """

    ID: typing.Literal["collectibleItemTypeUsername"] = field(
        default="collectibleItemTypeUsername", metadata={"alias": "@type"}
    )
    username: String


CollectibleItemType = typing.Union[
    CollectibleItemTypePhoneNumber,
    CollectibleItemTypeUsername,
]


@dataclass(slots=True, kw_only=True)
class ConnectedAffiliateProgram(BaseObject):
    """
    Describes an affiliate program that was connected to an affiliate

    :param url: The link that can be used to refer users if the program is still active
    :type url: :class:`String`
    :param bot_user_id: User identifier of the bot created the program
    :type bot_user_id: :class:`Int53`
    :param parameters: The parameters of the affiliate program
    :type parameters: :class:`AffiliateProgramParameters`
    :param connection_date: Point in time (Unix timestamp) when the affiliate program was connected
    :type connection_date: :class:`Int32`
    :param user_count: The number of users that used the affiliate program
    :type user_count: :class:`Int64`
    :param revenue_star_count: The number of Telegram Stars that were earned by the affiliate program
    :type revenue_star_count: :class:`Int64`
    :param is_disconnected: True, if the program was canceled by the bot, or disconnected by the chat owner and isn't available anymore
    :type is_disconnected: :class:`Bool`
    """

    ID: typing.Literal["connectedAffiliateProgram"] = field(
        default="connectedAffiliateProgram", metadata={"alias": "@type"}
    )
    url: String
    bot_user_id: Int53
    parameters: AffiliateProgramParameters
    connection_date: Int32
    user_count: Int64
    revenue_star_count: Int64
    is_disconnected: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ConnectedAffiliatePrograms(BaseObject):
    """
    Represents a list of affiliate programs that were connected to an affiliate

    :param total_count: The total number of affiliate programs that were connected to the affiliate
    :type total_count: :class:`Int32`
    :param programs: The list of connected affiliate programs
    :type programs: :class:`Vector[ConnectedAffiliateProgram]`
    :param next_offset: The offset for the next request. If empty, then there are no more results
    :type next_offset: :class:`String`
    """

    ID: typing.Literal["connectedAffiliatePrograms"] = field(
        default="connectedAffiliatePrograms", metadata={"alias": "@type"}
    )
    total_count: Int32
    programs: Vector[ConnectedAffiliateProgram]
    next_offset: String = field(default="")


@dataclass(slots=True, kw_only=True)
class ConnectedWebsite(BaseObject):
    """
    Contains information about one website the current user is logged in with Telegram

    :param id: Website identifier
    :type id: :class:`Int64`
    :param domain_name: The domain name of the website
    :type domain_name: :class:`String`
    :param bot_user_id: User identifier of a bot linked with the website
    :type bot_user_id: :class:`Int53`
    :param browser: The version of a browser used to log in
    :type browser: :class:`String`
    :param platform: Operating system the browser is running on
    :type platform: :class:`String`
    :param log_in_date: Point in time (Unix timestamp) when the user was logged in
    :type log_in_date: :class:`Int32`
    :param last_active_date: Point in time (Unix timestamp) when obtained authorization was last used
    :type last_active_date: :class:`Int32`
    :param ip_address: IP address from which the user was logged in, in human-readable format
    :type ip_address: :class:`String`
    :param location: Human-readable description of a country and a region from which the user was logged in, based on the IP address
    :type location: :class:`String`
    """

    ID: typing.Literal["connectedWebsite"] = field(default="connectedWebsite", metadata={"alias": "@type"})
    id: Int64
    domain_name: String
    bot_user_id: Int53
    browser: String
    platform: String
    log_in_date: Int32
    last_active_date: Int32
    ip_address: String
    location: String


@dataclass(slots=True, kw_only=True)
class ConnectedWebsites(BaseObject):
    """
    Contains a list of websites the current user is logged in with Telegram

    :param websites: List of connected websites
    :type websites: :class:`Vector[ConnectedWebsite]`
    """

    ID: typing.Literal["connectedWebsites"] = field(default="connectedWebsites", metadata={"alias": "@type"})
    websites: Vector[ConnectedWebsite]


@dataclass(slots=True, kw_only=True)
class ConnectionStateConnecting(BaseObject):
    """
    Establishing a connection to the Telegram servers
    """

    ID: typing.Literal["connectionStateConnecting"] = field(
        default="connectionStateConnecting", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ConnectionStateConnectingToProxy(BaseObject):
    """
    Establishing a connection with a proxy server
    """

    ID: typing.Literal["connectionStateConnectingToProxy"] = field(
        default="connectionStateConnectingToProxy", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ConnectionStateReady(BaseObject):
    """
    There is a working connection to the Telegram servers
    """

    ID: typing.Literal["connectionStateReady"] = field(default="connectionStateReady", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ConnectionStateUpdating(BaseObject):
    """
    Downloading data expected to be received while the application was offline
    """

    ID: typing.Literal["connectionStateUpdating"] = field(
        default="connectionStateUpdating", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ConnectionStateWaitingForNetwork(BaseObject):
    """
    Waiting for the network to become available. Use setNetworkType to change the available network type
    """

    ID: typing.Literal["connectionStateWaitingForNetwork"] = field(
        default="connectionStateWaitingForNetwork", metadata={"alias": "@type"}
    )


ConnectionState = typing.Union[
    ConnectionStateConnecting,
    ConnectionStateConnectingToProxy,
    ConnectionStateReady,
    ConnectionStateUpdating,
    ConnectionStateWaitingForNetwork,
]


@dataclass(slots=True, kw_only=True)
class Contact(BaseObject):
    """
    Describes a user contact

    :param phone_number: Phone number of the user
    :type phone_number: :class:`String`
    :param first_name: First name of the user; 1-255 characters in length
    :type first_name: :class:`String`
    :param last_name: Last name of the user
    :type last_name: :class:`String`
    :param vcard: Additional data about the user in a form of vCard; 0-2048 bytes in length
    :type vcard: :class:`String`
    :param user_id: Identifier of the user, if known; 0 otherwise
    :type user_id: :class:`Int53`
    """

    ID: typing.Literal["contact"] = field(default="contact", metadata={"alias": "@type"})
    phone_number: String
    first_name: String = field(default=MISSING, metadata={"min_length": 1, "max_length": 255})
    last_name: String
    vcard: String
    user_id: Int53


@dataclass(slots=True, kw_only=True)
class Count(BaseObject):
    """
    Contains a counter

    :param count: Count
    :type count: :class:`Int32`
    """

    ID: typing.Literal["count"] = field(default="count", metadata={"alias": "@type"})
    count: Int32


@dataclass(slots=True, kw_only=True)
class Countries(BaseObject):
    """
    Contains information about countries

    :param countries: The list of countries
    :type countries: :class:`Vector[CountryInfo]`
    """

    ID: typing.Literal["countries"] = field(default="countries", metadata={"alias": "@type"})
    countries: Vector[CountryInfo]


@dataclass(slots=True, kw_only=True)
class CountryInfo(BaseObject):
    """
    Contains information about a country

    :param country_code: A two-letter ISO 3166-1 alpha-2 country code
    :type country_code: :class:`String`
    :param name: Native name of the country
    :type name: :class:`String`
    :param english_name: English name of the country
    :type english_name: :class:`String`
    :param calling_codes: List of country calling codes
    :type calling_codes: :class:`Vector[String]`
    :param is_hidden: True, if the country must be hidden from the list of all countries
    :type is_hidden: :class:`Bool`
    """

    ID: typing.Literal["countryInfo"] = field(default="countryInfo", metadata={"alias": "@type"})
    country_code: String
    name: String
    english_name: String
    calling_codes: Vector[String]
    is_hidden: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class CreatedBasicGroupChat(BaseObject):
    """
    Contains information about a newly created basic group chat

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param failed_to_add_members: Information about failed to add members
    :type failed_to_add_members: :class:`FailedToAddMembers`
    """

    ID: typing.Literal["createdBasicGroupChat"] = field(default="createdBasicGroupChat", metadata={"alias": "@type"})
    chat_id: Int53
    failed_to_add_members: FailedToAddMembers


@dataclass(slots=True, kw_only=True)
class CurrentWeather(BaseObject):
    """
    Describes the current weather

    :param temperature: Temperature, in degree Celsius
    :type temperature: :class:`Double`
    :param emoji: Emoji representing the weather
    :type emoji: :class:`String`
    """

    ID: typing.Literal["currentWeather"] = field(default="currentWeather", metadata={"alias": "@type"})
    temperature: Double
    emoji: String


@dataclass(slots=True, kw_only=True)
class CustomRequestResult(BaseObject):
    """
    Contains the result of a custom request

    :param result: A JSON-serialized result
    :type result: :class:`String`
    """

    ID: typing.Literal["customRequestResult"] = field(default="customRequestResult", metadata={"alias": "@type"})
    result: String


@dataclass(slots=True, kw_only=True)
class DatabaseStatistics(BaseObject):
    """
    Contains database statistics

    :param statistics: Database statistics in an unspecified human-readable format
    :type statistics: :class:`String`
    """

    ID: typing.Literal["databaseStatistics"] = field(default="databaseStatistics", metadata={"alias": "@type"})
    statistics: String


@dataclass(slots=True, kw_only=True)
class Date(BaseObject):
    """
    Represents a date according to the Gregorian calendar

    :param day: Day of the month; 1-31
    :type day: :class:`Int32`
    :param month: Month; 1-12
    :type month: :class:`Int32`
    :param year: Year; 1-9999
    :type year: :class:`Int32`
    """

    ID: typing.Literal["date"] = field(default="date", metadata={"alias": "@type"})
    day: Int32
    month: Int32
    year: Int32


@dataclass(slots=True, kw_only=True)
class DateRange(BaseObject):
    """
    Represents a date range

    :param start_date: Point in time (Unix timestamp) at which the date range begins
    :type start_date: :class:`Int32`
    :param end_date: Point in time (Unix timestamp) at which the date range ends
    :type end_date: :class:`Int32`
    """

    ID: typing.Literal["dateRange"] = field(default="dateRange", metadata={"alias": "@type"})
    start_date: Int32
    end_date: Int32


@dataclass(slots=True, kw_only=True)
class DatedFile(BaseObject):
    """
    File with the date it was uploaded

    :param file: The file
    :type file: :class:`File`
    :param date: Point in time (Unix timestamp) when the file was uploaded
    :type date: :class:`Int32`
    """

    ID: typing.Literal["datedFile"] = field(default="datedFile", metadata={"alias": "@type"})
    file: File
    date: Int32


@dataclass(slots=True, kw_only=True)
class DeepLinkInfo(BaseObject):
    """
    Contains information about a tg: deep link

    :param text: Text to be shown to the user
    :type text: :class:`FormattedText`
    :param need_update_application: True, if the user must be asked to update the application
    :type need_update_application: :class:`Bool`
    """

    ID: typing.Literal["deepLinkInfo"] = field(default="deepLinkInfo", metadata={"alias": "@type"})
    text: FormattedText
    need_update_application: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class DeviceTokenApplePush(BaseObject):
    """
    A token for Apple Push Notification service

    :param device_token: Device token; may be empty to deregister a device
    :type device_token: :class:`String`
    :param is_app_sandbox: True, if App Sandbox is enabled
    :type is_app_sandbox: :class:`Bool`
    """

    ID: typing.Literal["deviceTokenApplePush"] = field(default="deviceTokenApplePush", metadata={"alias": "@type"})
    device_token: String = field(default="")
    is_app_sandbox: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class DeviceTokenApplePushVoIP(BaseObject):
    """
    A token for Apple Push Notification service VoIP notifications

    :param device_token: Device token; may be empty to deregister a device
    :type device_token: :class:`String`
    :param is_app_sandbox: True, if App Sandbox is enabled
    :type is_app_sandbox: :class:`Bool`
    :param encrypt: True, if push notifications must be additionally encrypted
    :type encrypt: :class:`Bool`
    """

    ID: typing.Literal["deviceTokenApplePushVoIP"] = field(
        default="deviceTokenApplePushVoIP", metadata={"alias": "@type"}
    )
    device_token: String = field(default="")
    is_app_sandbox: Bool = field(default=False)
    encrypt: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class DeviceTokenBlackBerryPush(BaseObject):
    """
    A token for BlackBerry Push Service

    :param token: Token; may be empty to deregister a device
    :type token: :class:`String`
    """

    ID: typing.Literal["deviceTokenBlackBerryPush"] = field(
        default="deviceTokenBlackBerryPush", metadata={"alias": "@type"}
    )
    token: String = field(default="")


@dataclass(slots=True, kw_only=True)
class DeviceTokenFirebaseCloudMessaging(BaseObject):
    """
    A token for Firebase Cloud Messaging

    :param token: Device registration token; may be empty to deregister a device
    :type token: :class:`String`
    :param encrypt: True, if push notifications must be additionally encrypted
    :type encrypt: :class:`Bool`
    """

    ID: typing.Literal["deviceTokenFirebaseCloudMessaging"] = field(
        default="deviceTokenFirebaseCloudMessaging", metadata={"alias": "@type"}
    )
    token: String = field(default="")
    encrypt: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class DeviceTokenHuaweiPush(BaseObject):
    """
    A token for HUAWEI Push Service

    :param token: Device registration token; may be empty to deregister a device
    :type token: :class:`String`
    :param encrypt: True, if push notifications must be additionally encrypted
    :type encrypt: :class:`Bool`
    """

    ID: typing.Literal["deviceTokenHuaweiPush"] = field(default="deviceTokenHuaweiPush", metadata={"alias": "@type"})
    token: String = field(default="")
    encrypt: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class DeviceTokenMicrosoftPush(BaseObject):
    """
    A token for Microsoft Push Notification Service

    :param channel_uri: Push notification channel URI; may be empty to deregister a device
    :type channel_uri: :class:`String`
    """

    ID: typing.Literal["deviceTokenMicrosoftPush"] = field(
        default="deviceTokenMicrosoftPush", metadata={"alias": "@type"}
    )
    channel_uri: String = field(default="")


@dataclass(slots=True, kw_only=True)
class DeviceTokenMicrosoftPushVoIP(BaseObject):
    """
    A token for Microsoft Push Notification Service VoIP channel

    :param channel_uri: Push notification channel URI; may be empty to deregister a device
    :type channel_uri: :class:`String`
    """

    ID: typing.Literal["deviceTokenMicrosoftPushVoIP"] = field(
        default="deviceTokenMicrosoftPushVoIP", metadata={"alias": "@type"}
    )
    channel_uri: String = field(default="")


@dataclass(slots=True, kw_only=True)
class DeviceTokenSimplePush(BaseObject):
    """
    A token for Simple Push API for Firefox OS

    :param endpoint: Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
    :type endpoint: :class:`String`
    """

    ID: typing.Literal["deviceTokenSimplePush"] = field(default="deviceTokenSimplePush", metadata={"alias": "@type"})
    endpoint: String = field(default="")


@dataclass(slots=True, kw_only=True)
class DeviceTokenTizenPush(BaseObject):
    """
    A token for Tizen Push Service

    :param reg_id: Push service registration identifier; may be empty to deregister a device
    :type reg_id: :class:`String`
    """

    ID: typing.Literal["deviceTokenTizenPush"] = field(default="deviceTokenTizenPush", metadata={"alias": "@type"})
    reg_id: String = field(default="")


@dataclass(slots=True, kw_only=True)
class DeviceTokenUbuntuPush(BaseObject):
    """
    A token for Ubuntu Push Client service

    :param token: Token; may be empty to deregister a device
    :type token: :class:`String`
    """

    ID: typing.Literal["deviceTokenUbuntuPush"] = field(default="deviceTokenUbuntuPush", metadata={"alias": "@type"})
    token: String = field(default="")


@dataclass(slots=True, kw_only=True)
class DeviceTokenWebPush(BaseObject):
    """
    A token for web Push API

    :param p256dh_base64url: Base64url-encoded P-256 elliptic curve Diffie-Hellman public key
    :type p256dh_base64url: :class:`String`
    :param auth_base64url: Base64url-encoded authentication secret
    :type auth_base64url: :class:`String`
    :param endpoint: Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
    :type endpoint: :class:`String`
    """

    ID: typing.Literal["deviceTokenWebPush"] = field(default="deviceTokenWebPush", metadata={"alias": "@type"})
    p256dh_base64url: String
    auth_base64url: String
    endpoint: String = field(default="")


@dataclass(slots=True, kw_only=True)
class DeviceTokenWindowsPush(BaseObject):
    """
    A token for Windows Push Notification Services

    :param access_token: The access token that will be used to send notifications; may be empty to deregister a device
    :type access_token: :class:`String`
    """

    ID: typing.Literal["deviceTokenWindowsPush"] = field(default="deviceTokenWindowsPush", metadata={"alias": "@type"})
    access_token: String = field(default="")


DeviceToken = typing.Union[
    DeviceTokenApplePush,
    DeviceTokenApplePushVoIP,
    DeviceTokenBlackBerryPush,
    DeviceTokenFirebaseCloudMessaging,
    DeviceTokenHuaweiPush,
    DeviceTokenMicrosoftPush,
    DeviceTokenMicrosoftPushVoIP,
    DeviceTokenSimplePush,
    DeviceTokenTizenPush,
    DeviceTokenUbuntuPush,
    DeviceTokenWebPush,
    DeviceTokenWindowsPush,
]


@dataclass(slots=True, kw_only=True)
class DiceStickersRegular(BaseObject):
    """
    A regular animated sticker

    :param sticker: The animated sticker with the dice animation
    :type sticker: :class:`Sticker`
    """

    ID: typing.Literal["diceStickersRegular"] = field(default="diceStickersRegular", metadata={"alias": "@type"})
    sticker: Sticker


@dataclass(slots=True, kw_only=True)
class DiceStickersSlotMachine(BaseObject):
    """
    Animated stickers to be combined into a slot machine

    :param background: The animated sticker with the slot machine background. The background animation must start playing after all reel animations finish
    :type background: :class:`Sticker`
    :param lever: The animated sticker with the lever animation. The lever animation must play once in the initial dice state
    :type lever: :class:`Sticker`
    :param left_reel: The animated sticker with the left reel
    :type left_reel: :class:`Sticker`
    :param center_reel: The animated sticker with the center reel
    :type center_reel: :class:`Sticker`
    :param right_reel: The animated sticker with the right reel
    :type right_reel: :class:`Sticker`
    """

    ID: typing.Literal["diceStickersSlotMachine"] = field(
        default="diceStickersSlotMachine", metadata={"alias": "@type"}
    )
    background: Sticker
    lever: Sticker
    left_reel: Sticker
    center_reel: Sticker
    right_reel: Sticker


DiceStickers = typing.Union[
    DiceStickersRegular,
    DiceStickersSlotMachine,
]


@dataclass(slots=True, kw_only=True)
class Document(BaseObject):
    """
    Describes a document of any type

    :param file_name: Original name of the file; as defined by the sender
    :type file_name: :class:`String`
    :param mime_type: MIME type of the file; as defined by the sender
    :type mime_type: :class:`String`
    :param document: File containing the document
    :type document: :class:`File`
    :param minithumbnail: Document minithumbnail; may be null, defaults to None
    :type minithumbnail: :class:`Minithumbnail`, optional
    :param thumbnail: Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns); as defined by the sender; may be null, defaults to None
    :type thumbnail: :class:`Thumbnail`, optional
    """

    ID: typing.Literal["document"] = field(default="document", metadata={"alias": "@type"})
    file_name: String
    mime_type: String
    document: File
    minithumbnail: typing.Optional[Minithumbnail] = field(default=None)
    thumbnail: typing.Optional[Thumbnail] = field(default=None)


@dataclass(slots=True, kw_only=True)
class DownloadedFileCounts(BaseObject):
    """
    Contains number of being downloaded and recently downloaded files found

    :param active_count: Number of active file downloads found, including paused
    :type active_count: :class:`Int32`
    :param paused_count: Number of paused file downloads found
    :type paused_count: :class:`Int32`
    :param completed_count: Number of completed file downloads found
    :type completed_count: :class:`Int32`
    """

    ID: typing.Literal["downloadedFileCounts"] = field(default="downloadedFileCounts", metadata={"alias": "@type"})
    active_count: Int32
    paused_count: Int32
    completed_count: Int32


@dataclass(slots=True, kw_only=True)
class DraftMessage(BaseObject):
    """
    Contains information about a message draft

    :param date: Point in time (Unix timestamp) when the draft was created
    :type date: :class:`Int32`
    :param input_message_text: Content of the message draft; must be of the type inputMessageText, inputMessageVideoNote, or inputMessageVoiceNote
    :type input_message_text: :class:`InputMessageContent`
    :param reply_to: Information about the message to be replied; must be of the type inputMessageReplyToMessage; may be null if none, defaults to None
    :type reply_to: :class:`InputMessageReplyTo`, optional
    :param effect_id: Identifier of the effect to apply to the message when it is sent; 0 if none, defaults to None
    :type effect_id: :class:`Int64`, optional
    """

    ID: typing.Literal["draftMessage"] = field(default="draftMessage", metadata={"alias": "@type"})
    date: Int32
    input_message_text: InputMessageContent
    reply_to: typing.Optional[InputMessageReplyTo] = field(default=None)
    effect_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class EmailAddressAuthenticationAppleId(BaseObject):
    """
    An authentication token received through Apple ID

    :param token: The token
    :type token: :class:`String`
    """

    ID: typing.Literal["emailAddressAuthenticationAppleId"] = field(
        default="emailAddressAuthenticationAppleId", metadata={"alias": "@type"}
    )
    token: String


@dataclass(slots=True, kw_only=True)
class EmailAddressAuthenticationCode(BaseObject):
    """
    An authentication code delivered to a user's email address

    :param code: The code
    :type code: :class:`String`
    """

    ID: typing.Literal["emailAddressAuthenticationCode"] = field(
        default="emailAddressAuthenticationCode", metadata={"alias": "@type"}
    )
    code: String


@dataclass(slots=True, kw_only=True)
class EmailAddressAuthenticationGoogleId(BaseObject):
    """
    An authentication token received through Google ID

    :param token: The token
    :type token: :class:`String`
    """

    ID: typing.Literal["emailAddressAuthenticationGoogleId"] = field(
        default="emailAddressAuthenticationGoogleId", metadata={"alias": "@type"}
    )
    token: String


EmailAddressAuthentication = typing.Union[
    EmailAddressAuthenticationAppleId,
    EmailAddressAuthenticationCode,
    EmailAddressAuthenticationGoogleId,
]


@dataclass(slots=True, kw_only=True)
class EmailAddressAuthenticationCodeInfo(BaseObject):
    """
    Information about the email address authentication code that was sent

    :param email_address_pattern: Pattern of the email address to which an authentication code was sent
    :type email_address_pattern: :class:`String`
    :param length: Length of the code; 0 if unknown, defaults to None
    :type length: :class:`Int32`, optional
    """

    ID: typing.Literal["emailAddressAuthenticationCodeInfo"] = field(
        default="emailAddressAuthenticationCodeInfo", metadata={"alias": "@type"}
    )
    email_address_pattern: String
    length: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class EmailAddressResetStateAvailable(BaseObject):
    """
    Email address can be reset after the given period. Call resetAuthenticationEmailAddress to reset it and allow the user to authorize with a code sent to the user's phone number

    :param wait_period: Time required to wait before the email address can be reset; 0 if the user is subscribed to Telegram Premium
    :type wait_period: :class:`Int32`
    """

    ID: typing.Literal["emailAddressResetStateAvailable"] = field(
        default="emailAddressResetStateAvailable", metadata={"alias": "@type"}
    )
    wait_period: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class EmailAddressResetStatePending(BaseObject):
    """
    Email address reset has already been requested. Call resetAuthenticationEmailAddress to check whether immediate reset is possible

    :param reset_in: Left time before the email address will be reset, in seconds. updateAuthorizationState is not sent when this field changes
    :type reset_in: :class:`Int32`
    """

    ID: typing.Literal["emailAddressResetStatePending"] = field(
        default="emailAddressResetStatePending", metadata={"alias": "@type"}
    )
    reset_in: Int32


EmailAddressResetState = typing.Union[
    EmailAddressResetStateAvailable,
    EmailAddressResetStatePending,
]


@dataclass(slots=True, kw_only=True)
class EmojiCategories(BaseObject):
    """
    Represents a list of emoji categories

    :param categories: List of categories
    :type categories: :class:`Vector[EmojiCategory]`
    """

    ID: typing.Literal["emojiCategories"] = field(default="emojiCategories", metadata={"alias": "@type"})
    categories: Vector[EmojiCategory]


@dataclass(slots=True, kw_only=True)
class EmojiCategory(BaseObject):
    """
    Describes an emoji category

    :param name: Name of the category
    :type name: :class:`String`
    :param icon: Custom emoji sticker, which represents icon of the category
    :type icon: :class:`Sticker`
    :param source: Source of stickers for the emoji category
    :type source: :class:`EmojiCategorySource`
    :param is_greeting: True, if the category must be shown first when choosing a sticker for the start page
    :type is_greeting: :class:`Bool`
    """

    ID: typing.Literal["emojiCategory"] = field(default="emojiCategory", metadata={"alias": "@type"})
    name: String
    icon: Sticker
    source: EmojiCategorySource
    is_greeting: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class EmojiCategorySourcePremium(BaseObject):
    """
    The category contains premium stickers that must be found by getPremiumStickers
    """

    ID: typing.Literal["emojiCategorySourcePremium"] = field(
        default="emojiCategorySourcePremium", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class EmojiCategorySourceSearch(BaseObject):
    """
    The category contains a list of similar emoji to search for in getStickers and searchStickers for stickers, or getInlineQueryResults with the bot getOption("animation_search_bot_username") for animations

    :param emojis: List of emojis to search for
    :type emojis: :class:`Vector[String]`
    """

    ID: typing.Literal["emojiCategorySourceSearch"] = field(
        default="emojiCategorySourceSearch", metadata={"alias": "@type"}
    )
    emojis: Vector[String]


EmojiCategorySource = typing.Union[
    EmojiCategorySourcePremium,
    EmojiCategorySourceSearch,
]


@dataclass(slots=True, kw_only=True)
class EmojiCategoryTypeChatPhoto(BaseObject):
    """
    The category must be used for chat photo emoji selection
    """

    ID: typing.Literal["emojiCategoryTypeChatPhoto"] = field(
        default="emojiCategoryTypeChatPhoto", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class EmojiCategoryTypeDefault(BaseObject):
    """
    The category must be used by default (e.g., for custom emoji or animation search)
    """

    ID: typing.Literal["emojiCategoryTypeDefault"] = field(
        default="emojiCategoryTypeDefault", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class EmojiCategoryTypeEmojiStatus(BaseObject):
    """
    The category must be used for emoji status selection
    """

    ID: typing.Literal["emojiCategoryTypeEmojiStatus"] = field(
        default="emojiCategoryTypeEmojiStatus", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class EmojiCategoryTypeRegularStickers(BaseObject):
    """
    The category must be used by default for regular sticker selection. It may contain greeting emoji category and premium stickers
    """

    ID: typing.Literal["emojiCategoryTypeRegularStickers"] = field(
        default="emojiCategoryTypeRegularStickers", metadata={"alias": "@type"}
    )


EmojiCategoryType = typing.Union[
    EmojiCategoryTypeChatPhoto,
    EmojiCategoryTypeDefault,
    EmojiCategoryTypeEmojiStatus,
    EmojiCategoryTypeRegularStickers,
]


@dataclass(slots=True, kw_only=True)
class EmojiKeyword(BaseObject):
    """
    Represents an emoji with its keyword

    :param emoji: The emoji
    :type emoji: :class:`String`
    :param keyword: The keyword
    :type keyword: :class:`String`
    """

    ID: typing.Literal["emojiKeyword"] = field(default="emojiKeyword", metadata={"alias": "@type"})
    emoji: String
    keyword: String


@dataclass(slots=True, kw_only=True)
class EmojiKeywords(BaseObject):
    """
    Represents a list of emojis with their keywords

    :param emoji_keywords: List of emojis with their keywords
    :type emoji_keywords: :class:`Vector[EmojiKeyword]`
    """

    ID: typing.Literal["emojiKeywords"] = field(default="emojiKeywords", metadata={"alias": "@type"})
    emoji_keywords: Vector[EmojiKeyword]


@dataclass(slots=True, kw_only=True)
class EmojiReaction(BaseObject):
    """
    Contains information about an emoji reaction

    :param emoji: Text representation of the reaction
    :type emoji: :class:`String`
    :param title: Reaction title
    :type title: :class:`String`
    :param static_icon: Static icon for the reaction
    :type static_icon: :class:`Sticker`
    :param appear_animation: Appear animation for the reaction
    :type appear_animation: :class:`Sticker`
    :param select_animation: Select animation for the reaction
    :type select_animation: :class:`Sticker`
    :param activate_animation: Activate animation for the reaction
    :type activate_animation: :class:`Sticker`
    :param effect_animation: Effect animation for the reaction
    :type effect_animation: :class:`Sticker`
    :param around_animation: Around animation for the reaction; may be null, defaults to None
    :type around_animation: :class:`Sticker`, optional
    :param center_animation: Center animation for the reaction; may be null, defaults to None
    :type center_animation: :class:`Sticker`, optional
    :param is_active: True, if the reaction can be added to new messages and enabled in chats
    :type is_active: :class:`Bool`
    """

    ID: typing.Literal["emojiReaction"] = field(default="emojiReaction", metadata={"alias": "@type"})
    emoji: String
    title: String
    static_icon: Sticker
    appear_animation: Sticker
    select_animation: Sticker
    activate_animation: Sticker
    effect_animation: Sticker
    around_animation: typing.Optional[Sticker] = field(default=None)
    center_animation: typing.Optional[Sticker] = field(default=None)
    is_active: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class EmojiStatus(BaseObject):
    """
    Describes an emoji to be shown instead of the Telegram Premium badge

    :param type_: Type of the emoji status
    :type type_: :class:`EmojiStatusType`
    :param expiration_date: Point in time (Unix timestamp) when the status will expire; 0 if never
    :type expiration_date: :class:`Int32`
    """

    ID: typing.Literal["emojiStatus"] = field(default="emojiStatus", metadata={"alias": "@type"})
    type_: EmojiStatusType = field(default=MISSING, metadata={"alias": "type"})
    expiration_date: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class EmojiStatusCustomEmojis(BaseObject):
    """
    Contains a list of custom emoji identifiers for emoji statuses

    :param custom_emoji_ids: The list of custom emoji identifiers
    :type custom_emoji_ids: :class:`Vector[Int64]`
    """

    ID: typing.Literal["emojiStatusCustomEmojis"] = field(
        default="emojiStatusCustomEmojis", metadata={"alias": "@type"}
    )
    custom_emoji_ids: Vector[Int64]


@dataclass(slots=True, kw_only=True)
class EmojiStatusTypeCustomEmoji(BaseObject):
    """
    A custom emoji set as emoji status

    :param custom_emoji_id: Identifier of the custom emoji in stickerFormatTgs format
    :type custom_emoji_id: :class:`Int64`
    """

    ID: typing.Literal["emojiStatusTypeCustomEmoji"] = field(
        default="emojiStatusTypeCustomEmoji", metadata={"alias": "@type"}
    )
    custom_emoji_id: Int64


@dataclass(slots=True, kw_only=True)
class EmojiStatusTypeUpgradedGift(BaseObject):
    """
    An upgraded gift set as emoji status

    :param upgraded_gift_id: Identifier of the upgraded gift
    :type upgraded_gift_id: :class:`Int64`
    :param gift_title: The title of the upgraded gift
    :type gift_title: :class:`String`
    :param gift_name: Unique name of the upgraded gift that can be used with internalLinkTypeUpgradedGift
    :type gift_name: :class:`String`
    :param model_custom_emoji_id: Custom emoji identifier of the model of the upgraded gift
    :type model_custom_emoji_id: :class:`Int64`
    :param symbol_custom_emoji_id: Custom emoji identifier of the symbol of the upgraded gift
    :type symbol_custom_emoji_id: :class:`Int64`
    :param backdrop_colors: Colors of the backdrop of the upgraded gift
    :type backdrop_colors: :class:`UpgradedGiftBackdropColors`
    """

    ID: typing.Literal["emojiStatusTypeUpgradedGift"] = field(
        default="emojiStatusTypeUpgradedGift", metadata={"alias": "@type"}
    )
    upgraded_gift_id: Int64
    gift_title: String
    gift_name: String
    model_custom_emoji_id: Int64
    symbol_custom_emoji_id: Int64
    backdrop_colors: UpgradedGiftBackdropColors


EmojiStatusType = typing.Union[
    EmojiStatusTypeCustomEmoji,
    EmojiStatusTypeUpgradedGift,
]


@dataclass(slots=True, kw_only=True)
class EmojiStatuses(BaseObject):
    """
    Contains a list of emoji statuses

    :param emoji_statuses: The list of emoji statuses identifiers
    :type emoji_statuses: :class:`Vector[EmojiStatus]`
    """

    ID: typing.Literal["emojiStatuses"] = field(default="emojiStatuses", metadata={"alias": "@type"})
    emoji_statuses: Vector[EmojiStatus]


@dataclass(slots=True, kw_only=True)
class Emojis(BaseObject):
    """
    Represents a list of emojis

    :param emojis: List of emojis
    :type emojis: :class:`Vector[String]`
    """

    ID: typing.Literal["emojis"] = field(default="emojis", metadata={"alias": "@type"})
    emojis: Vector[String]


@dataclass(slots=True, kw_only=True)
class EncryptedCredentials(BaseObject):
    """
    Contains encrypted Telegram Passport data credentials

    :param data: The encrypted credentials
    :type data: :class:`Bytes`
    :param hash_: The decrypted data hash
    :type hash_: :class:`Bytes`
    :param secret: Secret for data decryption, encrypted with the service's public key
    :type secret: :class:`Bytes`
    """

    ID: typing.Literal["encryptedCredentials"] = field(default="encryptedCredentials", metadata={"alias": "@type"})
    data: Bytes
    hash_: Bytes = field(default=MISSING, metadata={"alias": "hash"})
    secret: Bytes


@dataclass(slots=True, kw_only=True)
class EncryptedPassportElement(BaseObject):
    """
    Contains information about an encrypted Telegram Passport element; for bots only

    :param type_: Type of Telegram Passport element
    :type type_: :class:`PassportElementType`
    :param data: Encrypted JSON-encoded data about the user
    :type data: :class:`Bytes`
    :param front_side: The front side of an identity document
    :type front_side: :class:`DatedFile`
    :param translation: List of files containing a certified English translation of the document
    :type translation: :class:`Vector[DatedFile]`
    :param files: List of attached files
    :type files: :class:`Vector[DatedFile]`
    :param value: Unencrypted data, phone number or email address
    :type value: :class:`String`
    :param hash_: Hash of the entire element
    :type hash_: :class:`String`
    :param reverse_side: The reverse side of an identity document; may be null, defaults to None
    :type reverse_side: :class:`DatedFile`, optional
    :param selfie: Selfie with the document; may be null, defaults to None
    :type selfie: :class:`DatedFile`, optional
    """

    ID: typing.Literal["encryptedPassportElement"] = field(
        default="encryptedPassportElement", metadata={"alias": "@type"}
    )
    type_: PassportElementType = field(default=MISSING, metadata={"alias": "type"})
    data: Bytes
    front_side: DatedFile
    translation: Vector[DatedFile]
    files: Vector[DatedFile]
    value: String
    hash_: String = field(default=MISSING, metadata={"alias": "hash"})
    reverse_side: typing.Optional[DatedFile] = field(default=None)
    selfie: typing.Optional[DatedFile] = field(default=None)


@dataclass(slots=True, kw_only=True)
class Error(BaseObject):
    """
    An object of this type can be returned on every function call, in case of an error

    :param code: Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user
    :type code: :class:`Int32`
    :param message: Error message; subject to future changes
    :type message: :class:`String`
    """

    ID: typing.Literal["error"] = field(default="error", metadata={"alias": "@type"})
    code: Int32
    message: String


@dataclass(slots=True, kw_only=True)
class FactCheck(BaseObject):
    """
    Describes a fact-check added to the message by an independent checker

    :param text: Text of the fact-check
    :type text: :class:`FormattedText`
    :param country_code: A two-letter ISO 3166-1 alpha-2 country code of the country for which the fact-check is shown
    :type country_code: :class:`String`
    """

    ID: typing.Literal["factCheck"] = field(default="factCheck", metadata={"alias": "@type"})
    text: FormattedText
    country_code: String


@dataclass(slots=True, kw_only=True)
class FailedToAddMember(BaseObject):
    """
    Contains information about a user that has failed to be added to a chat

    :param user_id: User identifier
    :type user_id: :class:`Int53`
    :param premium_would_allow_invite: True, if subscription to Telegram Premium would have allowed to add the user to the chat
    :type premium_would_allow_invite: :class:`Bool`
    :param premium_required_to_send_messages: True, if subscription to Telegram Premium is required to send the user chat invite link
    :type premium_required_to_send_messages: :class:`Bool`
    """

    ID: typing.Literal["failedToAddMember"] = field(default="failedToAddMember", metadata={"alias": "@type"})
    user_id: Int53
    premium_would_allow_invite: Bool = field(default=False)
    premium_required_to_send_messages: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class FailedToAddMembers(BaseObject):
    """
    Represents a list of users that has failed to be added to a chat

    :param failed_to_add_members: Information about users that weren't added to the chat
    :type failed_to_add_members: :class:`Vector[FailedToAddMember]`
    """

    ID: typing.Literal["failedToAddMembers"] = field(default="failedToAddMembers", metadata={"alias": "@type"})
    failed_to_add_members: Vector[FailedToAddMember]


@dataclass(slots=True, kw_only=True)
class File(BaseObject):
    """
    Represents a file

    :param id: Unique file identifier
    :type id: :class:`Int32`
    :param expected_size: Approximate file size in bytes in case the exact file size is unknown. Can be used to show download/upload progress
    :type expected_size: :class:`Int53`
    :param local: Information about the local copy of the file
    :type local: :class:`LocalFile`
    :param remote: Information about the remote copy of the file
    :type remote: :class:`RemoteFile`
    :param size: File size, in bytes; 0 if unknown, defaults to None
    :type size: :class:`Int53`, optional
    """

    ID: typing.Literal["file"] = field(default="file", metadata={"alias": "@type"})
    id: Int32
    expected_size: Int53
    local: LocalFile
    remote: RemoteFile
    size: typing.Optional[Int53] = field(default=0)


@dataclass(slots=True, kw_only=True)
class FileDownload(BaseObject):
    """
    Describes a file added to file download list

    :param file_id: File identifier
    :type file_id: :class:`Int32`
    :param message: The message with the file
    :type message: :class:`Message`
    :param add_date: Point in time (Unix timestamp) when the file was added to the download list
    :type add_date: :class:`Int32`
    :param complete_date: Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
    :type complete_date: :class:`Int32`
    :param is_paused: True, if downloading of the file is paused
    :type is_paused: :class:`Bool`
    """

    ID: typing.Literal["fileDownload"] = field(default="fileDownload", metadata={"alias": "@type"})
    file_id: Int32
    message: Message
    add_date: Int32
    complete_date: Int32 = field(default=0)
    is_paused: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class FileDownloadedPrefixSize(BaseObject):
    """
    Contains size of downloaded prefix of a file

    :param size: The prefix size, in bytes
    :type size: :class:`Int53`
    """

    ID: typing.Literal["fileDownloadedPrefixSize"] = field(
        default="fileDownloadedPrefixSize", metadata={"alias": "@type"}
    )
    size: Int53


@dataclass(slots=True, kw_only=True)
class FilePart(BaseObject):
    """
    Contains a part of a file

    :param data: File bytes
    :type data: :class:`Bytes`
    """

    ID: typing.Literal["filePart"] = field(default="filePart", metadata={"alias": "@type"})
    data: Bytes


@dataclass(slots=True, kw_only=True)
class FileTypeAnimation(BaseObject):
    """
    The file is an animation
    """

    ID: typing.Literal["fileTypeAnimation"] = field(default="fileTypeAnimation", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeAudio(BaseObject):
    """
    The file is an audio file
    """

    ID: typing.Literal["fileTypeAudio"] = field(default="fileTypeAudio", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeDocument(BaseObject):
    """
    The file is a document
    """

    ID: typing.Literal["fileTypeDocument"] = field(default="fileTypeDocument", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeNone(BaseObject):
    """
    The data is not a file
    """

    ID: typing.Literal["fileTypeNone"] = field(default="fileTypeNone", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeNotificationSound(BaseObject):
    """
    The file is a notification sound
    """

    ID: typing.Literal["fileTypeNotificationSound"] = field(
        default="fileTypeNotificationSound", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class FileTypePhoto(BaseObject):
    """
    The file is a photo
    """

    ID: typing.Literal["fileTypePhoto"] = field(default="fileTypePhoto", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypePhotoStory(BaseObject):
    """
    The file is a photo published as a story
    """

    ID: typing.Literal["fileTypePhotoStory"] = field(default="fileTypePhotoStory", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeProfilePhoto(BaseObject):
    """
    The file is a profile photo
    """

    ID: typing.Literal["fileTypeProfilePhoto"] = field(default="fileTypeProfilePhoto", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeSecret(BaseObject):
    """
    The file was sent to a secret chat (the file type is not known to the server)
    """

    ID: typing.Literal["fileTypeSecret"] = field(default="fileTypeSecret", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeSecretThumbnail(BaseObject):
    """
    The file is a thumbnail of a file from a secret chat
    """

    ID: typing.Literal["fileTypeSecretThumbnail"] = field(
        default="fileTypeSecretThumbnail", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class FileTypeSecure(BaseObject):
    """
    The file is a file from Secure storage used for storing Telegram Passport files
    """

    ID: typing.Literal["fileTypeSecure"] = field(default="fileTypeSecure", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeSelfDestructingPhoto(BaseObject):
    """
    The file is a self-destructing photo in a private chat
    """

    ID: typing.Literal["fileTypeSelfDestructingPhoto"] = field(
        default="fileTypeSelfDestructingPhoto", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class FileTypeSelfDestructingVideo(BaseObject):
    """
    The file is a self-destructing video in a private chat
    """

    ID: typing.Literal["fileTypeSelfDestructingVideo"] = field(
        default="fileTypeSelfDestructingVideo", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class FileTypeSelfDestructingVideoNote(BaseObject):
    """
    The file is a self-destructing video note in a private chat
    """

    ID: typing.Literal["fileTypeSelfDestructingVideoNote"] = field(
        default="fileTypeSelfDestructingVideoNote", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class FileTypeSelfDestructingVoiceNote(BaseObject):
    """
    The file is a self-destructing voice note in a private chat
    """

    ID: typing.Literal["fileTypeSelfDestructingVoiceNote"] = field(
        default="fileTypeSelfDestructingVoiceNote", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class FileTypeSticker(BaseObject):
    """
    The file is a sticker
    """

    ID: typing.Literal["fileTypeSticker"] = field(default="fileTypeSticker", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeThumbnail(BaseObject):
    """
    The file is a thumbnail of another file
    """

    ID: typing.Literal["fileTypeThumbnail"] = field(default="fileTypeThumbnail", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeUnknown(BaseObject):
    """
    The file type is not yet known
    """

    ID: typing.Literal["fileTypeUnknown"] = field(default="fileTypeUnknown", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeVideo(BaseObject):
    """
    The file is a video
    """

    ID: typing.Literal["fileTypeVideo"] = field(default="fileTypeVideo", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeVideoNote(BaseObject):
    """
    The file is a video note
    """

    ID: typing.Literal["fileTypeVideoNote"] = field(default="fileTypeVideoNote", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeVideoStory(BaseObject):
    """
    The file is a video published as a story
    """

    ID: typing.Literal["fileTypeVideoStory"] = field(default="fileTypeVideoStory", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeVoiceNote(BaseObject):
    """
    The file is a voice note
    """

    ID: typing.Literal["fileTypeVoiceNote"] = field(default="fileTypeVoiceNote", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class FileTypeWallpaper(BaseObject):
    """
    The file is a wallpaper or a background pattern
    """

    ID: typing.Literal["fileTypeWallpaper"] = field(default="fileTypeWallpaper", metadata={"alias": "@type"})


FileType = typing.Union[
    FileTypeAnimation,
    FileTypeAudio,
    FileTypeDocument,
    FileTypeNone,
    FileTypeNotificationSound,
    FileTypePhoto,
    FileTypePhotoStory,
    FileTypeProfilePhoto,
    FileTypeSecret,
    FileTypeSecretThumbnail,
    FileTypeSecure,
    FileTypeSelfDestructingPhoto,
    FileTypeSelfDestructingVideo,
    FileTypeSelfDestructingVideoNote,
    FileTypeSelfDestructingVoiceNote,
    FileTypeSticker,
    FileTypeThumbnail,
    FileTypeUnknown,
    FileTypeVideo,
    FileTypeVideoNote,
    FileTypeVideoStory,
    FileTypeVoiceNote,
    FileTypeWallpaper,
]


@dataclass(slots=True, kw_only=True)
class FirebaseAuthenticationSettingsAndroid(BaseObject):
    """
    Settings for Firebase Authentication in the official Android application
    """

    ID: typing.Literal["firebaseAuthenticationSettingsAndroid"] = field(
        default="firebaseAuthenticationSettingsAndroid", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class FirebaseAuthenticationSettingsIos(BaseObject):
    """
    Settings for Firebase Authentication in the official iOS application

    :param device_token: Device token from Apple Push Notification service
    :type device_token: :class:`String`
    :param is_app_sandbox: True, if App Sandbox is enabled
    :type is_app_sandbox: :class:`Bool`
    """

    ID: typing.Literal["firebaseAuthenticationSettingsIos"] = field(
        default="firebaseAuthenticationSettingsIos", metadata={"alias": "@type"}
    )
    device_token: String
    is_app_sandbox: Bool = field(default=False)


FirebaseAuthenticationSettings = typing.Union[
    FirebaseAuthenticationSettingsAndroid,
    FirebaseAuthenticationSettingsIos,
]


@dataclass(slots=True, kw_only=True)
class FirebaseDeviceVerificationParametersPlayIntegrity(BaseObject):
    """
    Device verification must be performed with the classic Play Integrity verification (https://developer.android.com/google/play/integrity/classic)

    :param nonce: Base64url-encoded nonce to pass to the Play Integrity API
    :type nonce: :class:`String`
    :param cloud_project_number: Cloud project number to pass to the Play Integrity API
    :type cloud_project_number: :class:`Int64`
    """

    ID: typing.Literal["firebaseDeviceVerificationParametersPlayIntegrity"] = field(
        default="firebaseDeviceVerificationParametersPlayIntegrity", metadata={"alias": "@type"}
    )
    nonce: String
    cloud_project_number: Int64


@dataclass(slots=True, kw_only=True)
class FirebaseDeviceVerificationParametersSafetyNet(BaseObject):
    """
    Device verification must be performed with the SafetyNet Attestation API

    :param nonce: Nonce to pass to the SafetyNet Attestation API
    :type nonce: :class:`Bytes`
    """

    ID: typing.Literal["firebaseDeviceVerificationParametersSafetyNet"] = field(
        default="firebaseDeviceVerificationParametersSafetyNet", metadata={"alias": "@type"}
    )
    nonce: Bytes


FirebaseDeviceVerificationParameters = typing.Union[
    FirebaseDeviceVerificationParametersPlayIntegrity,
    FirebaseDeviceVerificationParametersSafetyNet,
]


@dataclass(slots=True, kw_only=True)
class FormattedText(BaseObject):
    """
    A text with some entities

    :param text: The text
    :type text: :class:`String`
    :param entities: Entities contained in the text. Entities can be nested, but must not mutually intersect with each other. Pre, Code and PreCode entities can't contain other entities. BlockQuote entities can't contain other BlockQuote entities. Bold, Italic, Underline, Strikethrough, and Spoiler entities can contain and can be part of any other entities. All other entities can't contain each other
    :type entities: :class:`Vector[TextEntity]`
    """

    ID: typing.Literal["formattedText"] = field(default="formattedText", metadata={"alias": "@type"})
    text: String
    entities: Vector[TextEntity]


@dataclass(slots=True, kw_only=True)
class ForumTopic(BaseObject):
    """
    Describes a forum topic

    :param info: Basic information about the topic
    :type info: :class:`ForumTopicInfo`
    :param unread_count: Number of unread messages in the topic
    :type unread_count: :class:`Int32`
    :param last_read_inbox_message_id: Identifier of the last read incoming message
    :type last_read_inbox_message_id: :class:`Int53`
    :param last_read_outbox_message_id: Identifier of the last read outgoing message
    :type last_read_outbox_message_id: :class:`Int53`
    :param unread_mention_count: Number of unread messages with a mention/reply in the topic
    :type unread_mention_count: :class:`Int32`
    :param unread_reaction_count: Number of messages with unread reactions in the topic
    :type unread_reaction_count: :class:`Int32`
    :param notification_settings: Notification settings for the topic
    :type notification_settings: :class:`ChatNotificationSettings`
    :param last_message: Last message in the topic; may be null if unknown, defaults to None
    :type last_message: :class:`Message`, optional
    :param draft_message: A draft of a message in the topic; may be null if none, defaults to None
    :type draft_message: :class:`DraftMessage`, optional
    :param is_pinned: True, if the topic is pinned in the topic list
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["forumTopic"] = field(default="forumTopic", metadata={"alias": "@type"})
    info: ForumTopicInfo
    unread_count: Int32
    last_read_inbox_message_id: Int53
    last_read_outbox_message_id: Int53
    unread_mention_count: Int32
    unread_reaction_count: Int32
    notification_settings: ChatNotificationSettings
    last_message: typing.Optional[Message] = field(default=None)
    draft_message: typing.Optional[DraftMessage] = field(default=None)
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ForumTopicIcon(BaseObject):
    """
    Describes a forum topic icon

    :param color: Color of the topic icon in RGB format
    :type color: :class:`Int32`
    :param custom_emoji_id: Unique identifier of the custom emoji shown on the topic icon; 0 if none, defaults to None
    :type custom_emoji_id: :class:`Int64`, optional
    """

    ID: typing.Literal["forumTopicIcon"] = field(default="forumTopicIcon", metadata={"alias": "@type"})
    color: Int32
    custom_emoji_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class ForumTopicInfo(BaseObject):
    """
    Contains basic information about a forum topic

    :param message_thread_id: Message thread identifier of the topic
    :type message_thread_id: :class:`Int53`
    :param name: Name of the topic
    :type name: :class:`String`
    :param icon: Icon of the topic
    :type icon: :class:`ForumTopicIcon`
    :param creation_date: Point in time (Unix timestamp) when the topic was created
    :type creation_date: :class:`Int32`
    :param creator_id: Identifier of the creator of the topic
    :type creator_id: :class:`MessageSender`
    :param is_general: True, if the topic is the General topic list
    :type is_general: :class:`Bool`
    :param is_outgoing: True, if the topic was created by the current user
    :type is_outgoing: :class:`Bool`
    :param is_closed: True, if the topic is closed
    :type is_closed: :class:`Bool`
    :param is_hidden: True, if the topic is hidden above the topic list and closed; for General topic only
    :type is_hidden: :class:`Bool`
    """

    ID: typing.Literal["forumTopicInfo"] = field(default="forumTopicInfo", metadata={"alias": "@type"})
    message_thread_id: Int53
    name: String
    icon: ForumTopicIcon
    creation_date: Int32
    creator_id: MessageSender
    is_general: Bool = field(default=False)
    is_outgoing: Bool = field(default=False)
    is_closed: Bool = field(default=False)
    is_hidden: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ForumTopics(BaseObject):
    """
    Describes a list of forum topics

    :param total_count: Approximate total number of forum topics found
    :type total_count: :class:`Int32`
    :param topics: List of forum topics
    :type topics: :class:`Vector[ForumTopic]`
    :param next_offset_date: Offset date for the next getForumTopics request
    :type next_offset_date: :class:`Int32`
    :param next_offset_message_id: Offset message identifier for the next getForumTopics request
    :type next_offset_message_id: :class:`Int53`
    :param next_offset_message_thread_id: Offset message thread identifier for the next getForumTopics request
    :type next_offset_message_thread_id: :class:`Int53`
    """

    ID: typing.Literal["forumTopics"] = field(default="forumTopics", metadata={"alias": "@type"})
    total_count: Int32
    topics: Vector[ForumTopic]
    next_offset_date: Int32
    next_offset_message_id: Int53
    next_offset_message_thread_id: Int53


@dataclass(slots=True, kw_only=True)
class ForwardSource(BaseObject):
    """
    Contains information about the last message from which a new message was forwarded last time

    :param sender_name: Name of the sender of the message if the sender is hidden by their privacy settings
    :type sender_name: :class:`String`
    :param sender_id: Identifier of the sender of the message; may be null if unknown or the new message was forwarded not to Saved Messages, defaults to None
    :type sender_id: :class:`MessageSender`, optional
    :param chat_id: Identifier of the chat to which the message that was forwarded belonged; may be 0 if unknown
    :type chat_id: :class:`Int53`
    :param message_id: Identifier of the message; may be 0 if unknown
    :type message_id: :class:`Int53`
    :param is_outgoing: True, if the message that was forwarded is outgoing; always false if sender is unknown
    :type is_outgoing: :class:`Bool`
    :param date: Point in time (Unix timestamp) when the message is sent; 0 if unknown, defaults to None
    :type date: :class:`Int32`, optional
    """

    ID: typing.Literal["forwardSource"] = field(default="forwardSource", metadata={"alias": "@type"})
    sender_name: String
    sender_id: typing.Optional[MessageSender] = field(default=None)
    chat_id: Int53 = field(default=0)
    message_id: Int53 = field(default=0)
    is_outgoing: Bool = field(default=False)
    date: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class FoundAffiliateProgram(BaseObject):
    """
    Describes a found affiliate program

    :param bot_user_id: User identifier of the bot created the program
    :type bot_user_id: :class:`Int53`
    :param info: Information about the affiliate program
    :type info: :class:`AffiliateProgramInfo`
    """

    ID: typing.Literal["foundAffiliateProgram"] = field(default="foundAffiliateProgram", metadata={"alias": "@type"})
    bot_user_id: Int53
    info: AffiliateProgramInfo


@dataclass(slots=True, kw_only=True)
class FoundAffiliatePrograms(BaseObject):
    """
    Represents a list of found affiliate programs

    :param total_count: The total number of found affiliate programs
    :type total_count: :class:`Int32`
    :param programs: The list of affiliate programs
    :type programs: :class:`Vector[FoundAffiliateProgram]`
    :param next_offset: The offset for the next request. If empty, then there are no more results
    :type next_offset: :class:`String`
    """

    ID: typing.Literal["foundAffiliatePrograms"] = field(default="foundAffiliatePrograms", metadata={"alias": "@type"})
    total_count: Int32
    programs: Vector[FoundAffiliateProgram]
    next_offset: String = field(default="")


@dataclass(slots=True, kw_only=True)
class FoundChatBoosts(BaseObject):
    """
    Contains a list of boosts applied to a chat

    :param total_count: Total number of boosts applied to the chat
    :type total_count: :class:`Int32`
    :param boosts: List of boosts
    :type boosts: :class:`Vector[ChatBoost]`
    :param next_offset: The offset for the next request. If empty, then there are no more results
    :type next_offset: :class:`String`
    """

    ID: typing.Literal["foundChatBoosts"] = field(default="foundChatBoosts", metadata={"alias": "@type"})
    total_count: Int32
    boosts: Vector[ChatBoost]
    next_offset: String = field(default="")


@dataclass(slots=True, kw_only=True)
class FoundChatMessages(BaseObject):
    """
    Contains a list of messages found by a search in a given chat

    :param total_count: Approximate total number of messages found; -1 if unknown
    :type total_count: :class:`Int32`
    :param messages: List of messages
    :type messages: :class:`Vector[Message]`
    :param next_from_message_id: The offset for the next request. If 0, there are no more results
    :type next_from_message_id: :class:`Int53`
    """

    ID: typing.Literal["foundChatMessages"] = field(default="foundChatMessages", metadata={"alias": "@type"})
    total_count: Int32
    messages: Vector[Message]
    next_from_message_id: Int53 = field(default=0)


@dataclass(slots=True, kw_only=True)
class FoundFileDownloads(BaseObject):
    """
    Contains a list of downloaded files, found by a search

    :param total_counts: Total number of suitable files, ignoring offset
    :type total_counts: :class:`DownloadedFileCounts`
    :param files: The list of files
    :type files: :class:`Vector[FileDownload]`
    :param next_offset: The offset for the next request. If empty, then there are no more results
    :type next_offset: :class:`String`
    """

    ID: typing.Literal["foundFileDownloads"] = field(default="foundFileDownloads", metadata={"alias": "@type"})
    total_counts: DownloadedFileCounts
    files: Vector[FileDownload]
    next_offset: String = field(default="")


@dataclass(slots=True, kw_only=True)
class FoundMessages(BaseObject):
    """
    Contains a list of messages found by a search

    :param total_count: Approximate total number of messages found; -1 if unknown
    :type total_count: :class:`Int32`
    :param messages: List of messages
    :type messages: :class:`Vector[Message]`
    :param next_offset: The offset for the next request. If empty, then there are no more results
    :type next_offset: :class:`String`
    """

    ID: typing.Literal["foundMessages"] = field(default="foundMessages", metadata={"alias": "@type"})
    total_count: Int32
    messages: Vector[Message]
    next_offset: String = field(default="")


@dataclass(slots=True, kw_only=True)
class FoundPosition(BaseObject):
    """
    Contains 0-based match position

    :param position: The position of the match
    :type position: :class:`Int32`
    """

    ID: typing.Literal["foundPosition"] = field(default="foundPosition", metadata={"alias": "@type"})
    position: Int32


@dataclass(slots=True, kw_only=True)
class FoundPositions(BaseObject):
    """
    Contains 0-based positions of matched objects

    :param total_count: Total number of matched objects
    :type total_count: :class:`Int32`
    :param positions: The positions of the matched objects
    :type positions: :class:`Vector[Int32]`
    """

    ID: typing.Literal["foundPositions"] = field(default="foundPositions", metadata={"alias": "@type"})
    total_count: Int32
    positions: Vector[Int32]


@dataclass(slots=True, kw_only=True)
class FoundStories(BaseObject):
    """
    Contains a list of stories found by a search

    :param total_count: Approximate total number of stories found
    :type total_count: :class:`Int32`
    :param stories: List of stories
    :type stories: :class:`Vector[Story]`
    :param next_offset: The offset for the next request. If empty, then there are no more results
    :type next_offset: :class:`String`
    """

    ID: typing.Literal["foundStories"] = field(default="foundStories", metadata={"alias": "@type"})
    total_count: Int32
    stories: Vector[Story]
    next_offset: String = field(default="")


@dataclass(slots=True, kw_only=True)
class FoundUsers(BaseObject):
    """
    Represents a list of found users

    :param user_ids: Identifiers of the found users
    :type user_ids: :class:`Vector[Int53]`
    :param next_offset: The offset for the next request. If empty, then there are no more results
    :type next_offset: :class:`String`
    """

    ID: typing.Literal["foundUsers"] = field(default="foundUsers", metadata={"alias": "@type"})
    user_ids: Vector[Int53]
    next_offset: String = field(default="")


@dataclass(slots=True, kw_only=True)
class FoundWebApp(BaseObject):
    """
    Contains information about a Web App found by its short name

    :param web_app: The Web App
    :type web_app: :class:`WebApp`
    :param request_write_access: True, if the user must be asked for the permission to the bot to send them messages
    :type request_write_access: :class:`Bool`
    :param skip_confirmation: True, if there is no need to show an ordinary open URL confirmation before opening the Web App. The field must be ignored and confirmation must be shown anyway if the Web App link was hidden
    :type skip_confirmation: :class:`Bool`
    """

    ID: typing.Literal["foundWebApp"] = field(default="foundWebApp", metadata={"alias": "@type"})
    web_app: WebApp
    request_write_access: Bool = field(default=False)
    skip_confirmation: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class Game(BaseObject):
    """
    Describes a game. Use getInternalLink with internalLinkTypeGame to share the game

    :param id: Unique game identifier
    :type id: :class:`Int64`
    :param short_name: Game short name
    :type short_name: :class:`String`
    :param title: Game title
    :type title: :class:`String`
    :param text: Game text, usually containing scoreboards for a game
    :type text: :class:`FormattedText`
    :param description: Game description
    :type description: :class:`String`
    :param photo: Game photo
    :type photo: :class:`Photo`
    :param animation: Game animation; may be null, defaults to None
    :type animation: :class:`Animation`, optional
    """

    ID: typing.Literal["game"] = field(default="game", metadata={"alias": "@type"})
    id: Int64
    short_name: String
    title: String
    text: FormattedText
    description: String
    photo: Photo
    animation: typing.Optional[Animation] = field(default=None)


@dataclass(slots=True, kw_only=True)
class GameHighScore(BaseObject):
    """
    Contains one row of the game high score table

    :param position: Position in the high score table
    :type position: :class:`Int32`
    :param user_id: User identifier
    :type user_id: :class:`Int53`
    :param score: User score
    :type score: :class:`Int32`
    """

    ID: typing.Literal["gameHighScore"] = field(default="gameHighScore", metadata={"alias": "@type"})
    position: Int32
    user_id: Int53
    score: Int32


@dataclass(slots=True, kw_only=True)
class GameHighScores(BaseObject):
    """
    Contains a list of game high scores

    :param scores: A list of game high scores
    :type scores: :class:`Vector[GameHighScore]`
    """

    ID: typing.Literal["gameHighScores"] = field(default="gameHighScores", metadata={"alias": "@type"})
    scores: Vector[GameHighScore]


@dataclass(slots=True, kw_only=True)
class Gift(BaseObject):
    """
    Describes a gift that can be sent to another user or channel chat

    :param id: Unique identifier of the gift
    :type id: :class:`Int64`
    :param sticker: The sticker representing the gift
    :type sticker: :class:`Sticker`
    :param star_count: Number of Telegram Stars that must be paid for the gift
    :type star_count: :class:`Int53`
    :param default_sell_star_count: Number of Telegram Stars that can be claimed by the receiver instead of the regular gift by default. If the gift was paid with just bought Telegram Stars, then full value can be claimed
    :type default_sell_star_count: :class:`Int53`
    :param first_send_date: Point in time (Unix timestamp) when the gift was send for the first time; for sold out gifts only
    :type first_send_date: :class:`Int32`
    :param last_send_date: Point in time (Unix timestamp) when the gift was send for the last time; for sold out gifts only
    :type last_send_date: :class:`Int32`
    :param upgrade_star_count: Number of Telegram Stars that must be paid to upgrade the gift; 0 if upgrade isn't possible
    :type upgrade_star_count: :class:`Int53`
    :param is_for_birthday: True, if the gift is a birthday gift
    :type is_for_birthday: :class:`Bool`
    :param remaining_count: Number of remaining times the gift can be purchased; 0 if not limited or the gift was sold out
    :type remaining_count: :class:`Int32`
    :param total_count: Number of total times the gift can be purchased; 0 if not limited
    :type total_count: :class:`Int32`
    """

    ID: typing.Literal["gift"] = field(default="gift", metadata={"alias": "@type"})
    id: Int64
    sticker: Sticker
    star_count: Int53
    default_sell_star_count: Int53
    first_send_date: Int32
    last_send_date: Int32
    upgrade_star_count: Int53 = field(default=0)
    is_for_birthday: Bool = field(default=False)
    remaining_count: Int32 = field(default=0)
    total_count: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class GiftUpgradePreview(BaseObject):
    """
    Contains examples of possible upgraded gifts for the given regular gift

    :param models: Examples of possible models that can be chosen for the gift after upgrade
    :type models: :class:`Vector[UpgradedGiftModel]`
    :param symbols: Examples of possible symbols that can be chosen for the gift after upgrade
    :type symbols: :class:`Vector[UpgradedGiftSymbol]`
    :param backdrops: Examples of possible backdrops that can be chosen for the gift after upgrade
    :type backdrops: :class:`Vector[UpgradedGiftBackdrop]`
    """

    ID: typing.Literal["giftUpgradePreview"] = field(default="giftUpgradePreview", metadata={"alias": "@type"})
    models: Vector[UpgradedGiftModel]
    symbols: Vector[UpgradedGiftSymbol]
    backdrops: Vector[UpgradedGiftBackdrop]


@dataclass(slots=True, kw_only=True)
class Gifts(BaseObject):
    """
    Contains a list of gifts that can be sent to another user or channel chat

    :param gifts: The list of gifts
    :type gifts: :class:`Vector[Gift]`
    """

    ID: typing.Literal["gifts"] = field(default="gifts", metadata={"alias": "@type"})
    gifts: Vector[Gift]


@dataclass(slots=True, kw_only=True)
class GiveawayInfoCompleted(BaseObject):
    """
    Describes a completed giveaway

    :param creation_date: Point in time (Unix timestamp) when the giveaway was created
    :type creation_date: :class:`Int32`
    :param actual_winners_selection_date: Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
    :type actual_winners_selection_date: :class:`Int32`
    :param winner_count: Number of winners in the giveaway
    :type winner_count: :class:`Int32`
    :param activation_count: Number of winners, which activated their gift codes; for Telegram Premium giveaways only
    :type activation_count: :class:`Int32`
    :param gift_code: Telegram Premium gift code that was received by the current user; empty if the user isn't a winner in the giveaway or the giveaway isn't a Telegram Premium giveaway
    :type gift_code: :class:`String`
    :param was_refunded: True, if the giveaway was canceled and was fully refunded
    :type was_refunded: :class:`Bool`
    :param is_winner: True, if the current user is a winner of the giveaway
    :type is_winner: :class:`Bool`
    :param won_star_count: The amount of Telegram Stars won by the current user; 0 if the user isn't a winner in the giveaway or the giveaway isn't a Telegram Star giveaway
    :type won_star_count: :class:`Int53`
    """

    ID: typing.Literal["giveawayInfoCompleted"] = field(default="giveawayInfoCompleted", metadata={"alias": "@type"})
    creation_date: Int32
    actual_winners_selection_date: Int32
    winner_count: Int32
    activation_count: Int32
    gift_code: String
    was_refunded: Bool = field(default=False)
    is_winner: Bool = field(default=False)
    won_star_count: Int53 = field(default=0)


@dataclass(slots=True, kw_only=True)
class GiveawayInfoOngoing(BaseObject):
    """
    Describes an ongoing giveaway

    :param creation_date: Point in time (Unix timestamp) when the giveaway was created
    :type creation_date: :class:`Int32`
    :param status: Status of the current user in the giveaway
    :type status: :class:`GiveawayParticipantStatus`
    :param is_ended: True, if the giveaway has ended and results are being prepared
    :type is_ended: :class:`Bool`
    """

    ID: typing.Literal["giveawayInfoOngoing"] = field(default="giveawayInfoOngoing", metadata={"alias": "@type"})
    creation_date: Int32
    status: GiveawayParticipantStatus
    is_ended: Bool = field(default=False)


GiveawayInfo = typing.Union[
    GiveawayInfoCompleted,
    GiveawayInfoOngoing,
]


@dataclass(slots=True, kw_only=True)
class GiveawayParameters(BaseObject):
    """
    Describes parameters of a giveaway

    :param boosted_chat_id: Identifier of the supergroup or channel chat, which will be automatically boosted by the winners of the giveaway for duration of the Telegram Premium subscription, or for the specified time. If the chat is a channel, then can_post_messages right is required in the channel, otherwise, the user must be an administrator in the supergroup
    :type boosted_chat_id: :class:`Int53`
    :param additional_chat_ids: Identifiers of other supergroup or channel chats that must be subscribed by the users to be eligible for the giveaway. There can be up to getOption("giveaway_additional_chat_count_max") additional chats
    :type additional_chat_ids: :class:`Vector[Int53]`
    :param winners_selection_date: Point in time (Unix timestamp) when the giveaway is expected to be performed; must be 60-getOption("giveaway_duration_max") seconds in the future in scheduled giveaways
    :type winners_selection_date: :class:`Int32`
    :param only_new_members: True, if only new members of the chats will be eligible for the giveaway
    :type only_new_members: :class:`Bool`
    :param has_public_winners: True, if the list of winners of the giveaway will be available to everyone
    :type has_public_winners: :class:`Bool`
    :param country_codes: The list of two-letter ISO 3166-1 alpha-2 codes of countries, users from which will be eligible for the giveaway. If empty, then all users can participate in the giveaway. There can be up to getOption("giveaway_country_count_max") chosen countries. Users with phone number that was bought at https://fragment.com can participate in any giveaway and the country code "FT" must not be specified in the list, defaults to list()
    :type country_codes: :class:`Vector[String]`
    :param prize_description: Additional description of the giveaway prize; 0-128 characters
    :type prize_description: :class:`String`
    """

    ID: typing.Literal["giveawayParameters"] = field(default="giveawayParameters", metadata={"alias": "@type"})
    boosted_chat_id: Int53
    additional_chat_ids: Vector[Int53]
    winners_selection_date: Int32
    only_new_members: Bool = field(default=False)
    has_public_winners: Bool = field(default=False)
    country_codes: Vector[String] = field(default_factory=list)
    prize_description: String = field(default="", metadata={"max_length": 128})


@dataclass(slots=True, kw_only=True)
class GiveawayParticipantStatusAdministrator(BaseObject):
    """
    The user can't participate in the giveaway, because they are an administrator in one of the chats that created the giveaway

    :param chat_id: Identifier of the chat administered by the user
    :type chat_id: :class:`Int53`
    """

    ID: typing.Literal["giveawayParticipantStatusAdministrator"] = field(
        default="giveawayParticipantStatusAdministrator", metadata={"alias": "@type"}
    )
    chat_id: Int53


@dataclass(slots=True, kw_only=True)
class GiveawayParticipantStatusAlreadyWasMember(BaseObject):
    """
    The user can't participate in the giveaway, because they have already been member of the chat

    :param joined_chat_date: Point in time (Unix timestamp) when the user joined the chat
    :type joined_chat_date: :class:`Int32`
    """

    ID: typing.Literal["giveawayParticipantStatusAlreadyWasMember"] = field(
        default="giveawayParticipantStatusAlreadyWasMember", metadata={"alias": "@type"}
    )
    joined_chat_date: Int32


@dataclass(slots=True, kw_only=True)
class GiveawayParticipantStatusDisallowedCountry(BaseObject):
    """
    The user can't participate in the giveaway, because they phone number is from a disallowed country

    :param user_country_code: A two-letter ISO 3166-1 alpha-2 country code of the user's country
    :type user_country_code: :class:`String`
    """

    ID: typing.Literal["giveawayParticipantStatusDisallowedCountry"] = field(
        default="giveawayParticipantStatusDisallowedCountry", metadata={"alias": "@type"}
    )
    user_country_code: String


@dataclass(slots=True, kw_only=True)
class GiveawayParticipantStatusEligible(BaseObject):
    """
    The user is eligible for the giveaway
    """

    ID: typing.Literal["giveawayParticipantStatusEligible"] = field(
        default="giveawayParticipantStatusEligible", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class GiveawayParticipantStatusParticipating(BaseObject):
    """
    The user participates in the giveaway
    """

    ID: typing.Literal["giveawayParticipantStatusParticipating"] = field(
        default="giveawayParticipantStatusParticipating", metadata={"alias": "@type"}
    )


GiveawayParticipantStatus = typing.Union[
    GiveawayParticipantStatusAdministrator,
    GiveawayParticipantStatusAlreadyWasMember,
    GiveawayParticipantStatusDisallowedCountry,
    GiveawayParticipantStatusEligible,
    GiveawayParticipantStatusParticipating,
]


@dataclass(slots=True, kw_only=True)
class GiveawayPrizePremium(BaseObject):
    """
    The giveaway sends Telegram Premium subscriptions to the winners

    :param month_count: Number of months the Telegram Premium subscription will be active after code activation
    :type month_count: :class:`Int32`
    """

    ID: typing.Literal["giveawayPrizePremium"] = field(default="giveawayPrizePremium", metadata={"alias": "@type"})
    month_count: Int32


@dataclass(slots=True, kw_only=True)
class GiveawayPrizeStars(BaseObject):
    """
    The giveaway sends Telegram Stars to the winners

    :param star_count: Number of Telegram Stars that will be shared by all winners
    :type star_count: :class:`Int53`
    """

    ID: typing.Literal["giveawayPrizeStars"] = field(default="giveawayPrizeStars", metadata={"alias": "@type"})
    star_count: Int53


GiveawayPrize = typing.Union[
    GiveawayPrizePremium,
    GiveawayPrizeStars,
]


@dataclass(slots=True, kw_only=True)
class GroupCall(BaseObject):
    """
    Describes a group call

    :param id: Group call identifier
    :type id: :class:`Int32`
    :param title: Group call title
    :type title: :class:`String`
    :param participant_count: Number of participants in the group call
    :type participant_count: :class:`Int32`
    :param recent_speakers: At most 3 recently speaking users in the group call
    :type recent_speakers: :class:`Vector[GroupCallRecentSpeaker]`
    :param duration: Call duration, in seconds; for ended calls only
    :type duration: :class:`Int32`
    :param scheduled_start_date: Point in time (Unix timestamp) when the group call is expected to be started by an administrator; 0 if it is already active or was ended
    :type scheduled_start_date: :class:`Int32`
    :param enabled_start_notification: True, if the group call is scheduled and the current user will receive a notification when the group call starts
    :type enabled_start_notification: :class:`Bool`
    :param is_active: True, if the call is active
    :type is_active: :class:`Bool`
    :param is_rtmp_stream: True, if the chat is an RTMP stream instead of an ordinary video chat
    :type is_rtmp_stream: :class:`Bool`
    :param is_joined: True, if the call is joined
    :type is_joined: :class:`Bool`
    :param need_rejoin: True, if user was kicked from the call because of network loss and the call needs to be rejoined
    :type need_rejoin: :class:`Bool`
    :param can_be_managed: True, if the current user can manage the group call
    :type can_be_managed: :class:`Bool`
    :param has_hidden_listeners: True, if group call participants, which are muted, aren't returned in participant list
    :type has_hidden_listeners: :class:`Bool`
    :param loaded_all_participants: True, if all group call participants are loaded
    :type loaded_all_participants: :class:`Bool`
    :param is_my_video_enabled: True, if the current user's video is enabled
    :type is_my_video_enabled: :class:`Bool`
    :param is_my_video_paused: True, if the current user's video is paused
    :type is_my_video_paused: :class:`Bool`
    :param can_enable_video: True, if the current user can broadcast video or share screen
    :type can_enable_video: :class:`Bool`
    :param mute_new_participants: True, if only group call administrators can unmute new participants
    :type mute_new_participants: :class:`Bool`
    :param can_toggle_mute_new_participants: True, if the current user can enable or disable mute_new_participants setting
    :type can_toggle_mute_new_participants: :class:`Bool`
    :param is_video_recorded: True, if a video file is being recorded for the call
    :type is_video_recorded: :class:`Bool`
    :param record_duration: Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall update is not triggered when value of this field changes, but the same recording goes on, defaults to None
    :type record_duration: :class:`Int32`, optional
    """

    ID: typing.Literal["groupCall"] = field(default="groupCall", metadata={"alias": "@type"})
    id: Int32
    title: String
    participant_count: Int32
    recent_speakers: Vector[GroupCallRecentSpeaker]
    duration: Int32
    scheduled_start_date: Int32 = field(default=0)
    enabled_start_notification: Bool = field(default=False)
    is_active: Bool = field(default=False)
    is_rtmp_stream: Bool = field(default=False)
    is_joined: Bool = field(default=False)
    need_rejoin: Bool = field(default=False)
    can_be_managed: Bool = field(default=False)
    has_hidden_listeners: Bool = field(default=False)
    loaded_all_participants: Bool = field(default=False)
    is_my_video_enabled: Bool = field(default=False)
    is_my_video_paused: Bool = field(default=False)
    can_enable_video: Bool = field(default=False)
    mute_new_participants: Bool = field(default=False)
    can_toggle_mute_new_participants: Bool = field(default=False)
    is_video_recorded: Bool = field(default=False)
    record_duration: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class GroupCallId(BaseObject):
    """
    Contains the group call identifier

    :param id: Group call identifier
    :type id: :class:`Int32`
    """

    ID: typing.Literal["groupCallId"] = field(default="groupCallId", metadata={"alias": "@type"})
    id: Int32


@dataclass(slots=True, kw_only=True)
class GroupCallParticipant(BaseObject):
    """
    Represents a group call participant

    :param participant_id: Identifier of the group call participant
    :type participant_id: :class:`MessageSender`
    :param audio_source_id: User's audio channel synchronization source identifier
    :type audio_source_id: :class:`Int32`
    :param screen_sharing_audio_source_id: User's screen sharing audio channel synchronization source identifier
    :type screen_sharing_audio_source_id: :class:`Int32`
    :param bio: The participant user's bio or the participant chat's description
    :type bio: :class:`String`
    :param volume_level: Participant's volume level; 1-20000 in hundreds of percents
    :type volume_level: :class:`Int32`
    :param order: User's order in the group call participant list. Orders must be compared lexicographically. The bigger is order, the higher is user in the list. If order is empty, the user must be removed from the participant list
    :type order: :class:`String`
    :param video_info: Information about user's video channel; may be null if there is no active video, defaults to None
    :type video_info: :class:`GroupCallParticipantVideoInfo`, optional
    :param screen_sharing_video_info: Information about user's screen sharing video channel; may be null if there is no active screen sharing video, defaults to None
    :type screen_sharing_video_info: :class:`GroupCallParticipantVideoInfo`, optional
    :param is_current_user: True, if the participant is the current user
    :type is_current_user: :class:`Bool`
    :param is_speaking: True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking
    :type is_speaking: :class:`Bool`
    :param is_hand_raised: True, if the participant hand is raised
    :type is_hand_raised: :class:`Bool`
    :param can_be_muted_for_all_users: True, if the current user can mute the participant for all other group call participants
    :type can_be_muted_for_all_users: :class:`Bool`
    :param can_be_unmuted_for_all_users: True, if the current user can allow the participant to unmute themselves or unmute the participant (if the participant is the current user)
    :type can_be_unmuted_for_all_users: :class:`Bool`
    :param can_be_muted_for_current_user: True, if the current user can mute the participant only for self
    :type can_be_muted_for_current_user: :class:`Bool`
    :param can_be_unmuted_for_current_user: True, if the current user can unmute the participant for self
    :type can_be_unmuted_for_current_user: :class:`Bool`
    :param is_muted_for_all_users: True, if the participant is muted for all users
    :type is_muted_for_all_users: :class:`Bool`
    :param is_muted_for_current_user: True, if the participant is muted for the current user
    :type is_muted_for_current_user: :class:`Bool`
    :param can_unmute_self: True, if the participant is muted for all users, but can unmute themselves
    :type can_unmute_self: :class:`Bool`
    """

    ID: typing.Literal["groupCallParticipant"] = field(default="groupCallParticipant", metadata={"alias": "@type"})
    participant_id: MessageSender
    audio_source_id: Int32
    screen_sharing_audio_source_id: Int32
    bio: String
    volume_level: Int32
    order: String
    video_info: typing.Optional[GroupCallParticipantVideoInfo] = field(default=None)
    screen_sharing_video_info: typing.Optional[GroupCallParticipantVideoInfo] = field(default=None)
    is_current_user: Bool = field(default=False)
    is_speaking: Bool = field(default=False)
    is_hand_raised: Bool = field(default=False)
    can_be_muted_for_all_users: Bool = field(default=False)
    can_be_unmuted_for_all_users: Bool = field(default=False)
    can_be_muted_for_current_user: Bool = field(default=False)
    can_be_unmuted_for_current_user: Bool = field(default=False)
    is_muted_for_all_users: Bool = field(default=False)
    is_muted_for_current_user: Bool = field(default=False)
    can_unmute_self: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class GroupCallParticipantVideoInfo(BaseObject):
    """
    Contains information about a group call participant's video channel

    :param source_groups: List of synchronization source groups of the video
    :type source_groups: :class:`Vector[GroupCallVideoSourceGroup]`
    :param endpoint_id: Video channel endpoint identifier
    :type endpoint_id: :class:`String`
    :param is_paused: True, if the video is paused. This flag needs to be ignored, if new video frames are received
    :type is_paused: :class:`Bool`
    """

    ID: typing.Literal["groupCallParticipantVideoInfo"] = field(
        default="groupCallParticipantVideoInfo", metadata={"alias": "@type"}
    )
    source_groups: Vector[GroupCallVideoSourceGroup]
    endpoint_id: String
    is_paused: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class GroupCallRecentSpeaker(BaseObject):
    """
    Describes a recently speaking participant in a group call

    :param participant_id: Group call participant identifier
    :type participant_id: :class:`MessageSender`
    :param is_speaking: True, is the user has spoken recently
    :type is_speaking: :class:`Bool`
    """

    ID: typing.Literal["groupCallRecentSpeaker"] = field(default="groupCallRecentSpeaker", metadata={"alias": "@type"})
    participant_id: MessageSender
    is_speaking: Bool


@dataclass(slots=True, kw_only=True)
class GroupCallStream(BaseObject):
    """
    Describes an available stream in a group call

    :param channel_id: Identifier of an audio/video channel
    :type channel_id: :class:`Int32`
    :param scale: Scale of segment durations in the stream. The duration is 1000/(2**scale) milliseconds
    :type scale: :class:`Int32`
    :param time_offset: Point in time when the stream currently ends; Unix timestamp in milliseconds
    :type time_offset: :class:`Int53`
    """

    ID: typing.Literal["groupCallStream"] = field(default="groupCallStream", metadata={"alias": "@type"})
    channel_id: Int32
    scale: Int32
    time_offset: Int53


@dataclass(slots=True, kw_only=True)
class GroupCallStreams(BaseObject):
    """
    Represents a list of group call streams

    :param streams: A list of group call streams
    :type streams: :class:`Vector[GroupCallStream]`
    """

    ID: typing.Literal["groupCallStreams"] = field(default="groupCallStreams", metadata={"alias": "@type"})
    streams: Vector[GroupCallStream]


@dataclass(slots=True, kw_only=True)
class GroupCallVideoQualityFull(BaseObject):
    """
    The best available video quality
    """

    ID: typing.Literal["groupCallVideoQualityFull"] = field(
        default="groupCallVideoQualityFull", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class GroupCallVideoQualityMedium(BaseObject):
    """
    The medium video quality
    """

    ID: typing.Literal["groupCallVideoQualityMedium"] = field(
        default="groupCallVideoQualityMedium", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class GroupCallVideoQualityThumbnail(BaseObject):
    """
    The worst available video quality
    """

    ID: typing.Literal["groupCallVideoQualityThumbnail"] = field(
        default="groupCallVideoQualityThumbnail", metadata={"alias": "@type"}
    )


GroupCallVideoQuality = typing.Union[
    GroupCallVideoQualityFull,
    GroupCallVideoQualityMedium,
    GroupCallVideoQualityThumbnail,
]


@dataclass(slots=True, kw_only=True)
class GroupCallVideoSourceGroup(BaseObject):
    """
    Describes a group of video synchronization source identifiers

    :param semantics: The semantics of sources, one of "SIM" or "FID"
    :type semantics: :class:`String`
    :param source_ids: The list of synchronization source identifiers
    :type source_ids: :class:`Vector[Int32]`
    """

    ID: typing.Literal["groupCallVideoSourceGroup"] = field(
        default="groupCallVideoSourceGroup", metadata={"alias": "@type"}
    )
    semantics: String
    source_ids: Vector[Int32]


@dataclass(slots=True, kw_only=True)
class Hashtags(BaseObject):
    """
    Contains a list of hashtags

    :param hashtags: A list of hashtags
    :type hashtags: :class:`Vector[String]`
    """

    ID: typing.Literal["hashtags"] = field(default="hashtags", metadata={"alias": "@type"})
    hashtags: Vector[String]


@dataclass(slots=True, kw_only=True)
class HttpUrl(BaseObject):
    """
    Contains an HTTP URL

    :param url: The URL
    :type url: :class:`String`
    """

    ID: typing.Literal["httpUrl"] = field(default="httpUrl", metadata={"alias": "@type"})
    url: String


@dataclass(slots=True, kw_only=True)
class IdentityDocument(BaseObject):
    """
    An identity document

    :param number: Document number; 1-24 characters
    :type number: :class:`String`
    :param front_side: Front side of the document
    :type front_side: :class:`DatedFile`
    :param translation: List of files containing a certified English translation of the document
    :type translation: :class:`Vector[DatedFile]`
    :param expiration_date: Document expiration date; may be null if not applicable, defaults to None
    :type expiration_date: :class:`Date`, optional
    :param reverse_side: Reverse side of the document; only for driver license and identity card; may be null, defaults to None
    :type reverse_side: :class:`DatedFile`, optional
    :param selfie: Selfie with the document; may be null, defaults to None
    :type selfie: :class:`DatedFile`, optional
    """

    ID: typing.Literal["identityDocument"] = field(default="identityDocument", metadata={"alias": "@type"})
    number: String = field(default=MISSING, metadata={"min_length": 1, "max_length": 24})
    front_side: DatedFile
    translation: Vector[DatedFile]
    expiration_date: typing.Optional[Date] = field(default=None)
    reverse_side: typing.Optional[DatedFile] = field(default=None)
    selfie: typing.Optional[DatedFile] = field(default=None)


@dataclass(slots=True, kw_only=True)
class ImportedContacts(BaseObject):
    """
    Represents the result of an importContacts request

    :param user_ids: User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user
    :type user_ids: :class:`Vector[Int53]`
    :param importer_count: The number of users that imported the corresponding contact; 0 for already registered users or if unavailable
    :type importer_count: :class:`Vector[Int32]`
    """

    ID: typing.Literal["importedContacts"] = field(default="importedContacts", metadata={"alias": "@type"})
    user_ids: Vector[Int53] = field(default=0)
    importer_count: Vector[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class InlineKeyboardButton(BaseObject):
    """
    Represents a single button in an inline keyboard

    :param text: Text of the button
    :type text: :class:`String`
    :param type_: Type of the button
    :type type_: :class:`InlineKeyboardButtonType`
    """

    ID: typing.Literal["inlineKeyboardButton"] = field(default="inlineKeyboardButton", metadata={"alias": "@type"})
    text: String
    type_: InlineKeyboardButtonType = field(default=MISSING, metadata={"alias": "type"})


@dataclass(slots=True, kw_only=True)
class InlineKeyboardButtonTypeBuy(BaseObject):
    """
    A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageInvoice
    """

    ID: typing.Literal["inlineKeyboardButtonTypeBuy"] = field(
        default="inlineKeyboardButtonTypeBuy", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InlineKeyboardButtonTypeCallback(BaseObject):
    """
    A button that sends a callback query to a bot

    :param data: Data to be sent to the bot via a callback query
    :type data: :class:`Bytes`
    """

    ID: typing.Literal["inlineKeyboardButtonTypeCallback"] = field(
        default="inlineKeyboardButtonTypeCallback", metadata={"alias": "@type"}
    )
    data: Bytes


@dataclass(slots=True, kw_only=True)
class InlineKeyboardButtonTypeCallbackGame(BaseObject):
    """
    A button with a game that sends a callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageGame
    """

    ID: typing.Literal["inlineKeyboardButtonTypeCallbackGame"] = field(
        default="inlineKeyboardButtonTypeCallbackGame", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InlineKeyboardButtonTypeCallbackWithPassword(BaseObject):
    """
    A button that asks for the 2-step verification password of the current user and then sends a callback query to a bot

    :param data: Data to be sent to the bot via a callback query
    :type data: :class:`Bytes`
    """

    ID: typing.Literal["inlineKeyboardButtonTypeCallbackWithPassword"] = field(
        default="inlineKeyboardButtonTypeCallbackWithPassword", metadata={"alias": "@type"}
    )
    data: Bytes


@dataclass(slots=True, kw_only=True)
class InlineKeyboardButtonTypeCopyText(BaseObject):
    """
    A button that copies specified text to clipboard

    :param text: The text to copy to clipboard
    :type text: :class:`String`
    """

    ID: typing.Literal["inlineKeyboardButtonTypeCopyText"] = field(
        default="inlineKeyboardButtonTypeCopyText", metadata={"alias": "@type"}
    )
    text: String


@dataclass(slots=True, kw_only=True)
class InlineKeyboardButtonTypeLoginUrl(BaseObject):
    """
    A button that opens a specified URL and automatically authorize the current user by calling getLoginUrlInfo

    :param url: An HTTP URL to pass to getLoginUrlInfo
    :type url: :class:`String`
    :param id: Unique button identifier
    :type id: :class:`Int53`
    :param forward_text: If non-empty, new text of the button in forwarded messages
    :type forward_text: :class:`String`
    """

    ID: typing.Literal["inlineKeyboardButtonTypeLoginUrl"] = field(
        default="inlineKeyboardButtonTypeLoginUrl", metadata={"alias": "@type"}
    )
    url: String
    id: Int53
    forward_text: String = field(default="")


@dataclass(slots=True, kw_only=True)
class InlineKeyboardButtonTypeSwitchInline(BaseObject):
    """
    A button that forces an inline query to the bot to be inserted in the input field

    :param query: Inline query to be sent to the bot
    :type query: :class:`String`
    :param target_chat: Target chat from which to send the inline query
    :type target_chat: :class:`TargetChat`
    """

    ID: typing.Literal["inlineKeyboardButtonTypeSwitchInline"] = field(
        default="inlineKeyboardButtonTypeSwitchInline", metadata={"alias": "@type"}
    )
    query: String
    target_chat: TargetChat


@dataclass(slots=True, kw_only=True)
class InlineKeyboardButtonTypeUrl(BaseObject):
    """
    A button that opens a specified URL

    :param url: HTTP or tg:// URL to open. If the link is of the type internalLinkTypeWebApp, then the button must be marked as a Web App button
    :type url: :class:`String`
    """

    ID: typing.Literal["inlineKeyboardButtonTypeUrl"] = field(
        default="inlineKeyboardButtonTypeUrl", metadata={"alias": "@type"}
    )
    url: String


@dataclass(slots=True, kw_only=True)
class InlineKeyboardButtonTypeUser(BaseObject):
    """
    A button with a user reference to be handled in the same way as textEntityTypeMentionName entities

    :param user_id: User identifier
    :type user_id: :class:`Int53`
    """

    ID: typing.Literal["inlineKeyboardButtonTypeUser"] = field(
        default="inlineKeyboardButtonTypeUser", metadata={"alias": "@type"}
    )
    user_id: Int53


@dataclass(slots=True, kw_only=True)
class InlineKeyboardButtonTypeWebApp(BaseObject):
    """
    A button that opens a Web App by calling openWebApp

    :param url: An HTTP URL to pass to openWebApp
    :type url: :class:`String`
    """

    ID: typing.Literal["inlineKeyboardButtonTypeWebApp"] = field(
        default="inlineKeyboardButtonTypeWebApp", metadata={"alias": "@type"}
    )
    url: String


InlineKeyboardButtonType = typing.Union[
    InlineKeyboardButtonTypeBuy,
    InlineKeyboardButtonTypeCallback,
    InlineKeyboardButtonTypeCallbackGame,
    InlineKeyboardButtonTypeCallbackWithPassword,
    InlineKeyboardButtonTypeCopyText,
    InlineKeyboardButtonTypeLoginUrl,
    InlineKeyboardButtonTypeSwitchInline,
    InlineKeyboardButtonTypeUrl,
    InlineKeyboardButtonTypeUser,
    InlineKeyboardButtonTypeWebApp,
]


@dataclass(slots=True, kw_only=True)
class InlineQueryResultAnimation(BaseObject):
    """
    Represents an animation file

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param animation: Animation file
    :type animation: :class:`Animation`
    :param title: Animation title
    :type title: :class:`String`
    """

    ID: typing.Literal["inlineQueryResultAnimation"] = field(
        default="inlineQueryResultAnimation", metadata={"alias": "@type"}
    )
    id: String
    animation: Animation
    title: String


@dataclass(slots=True, kw_only=True)
class InlineQueryResultArticle(BaseObject):
    """
    Represents a link to an article or web page

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param url: URL of the result, if it exists
    :type url: :class:`String`
    :param title: Title of the result
    :type title: :class:`String`
    :param description: A short description of the result
    :type description: :class:`String`
    :param thumbnail: Result thumbnail in JPEG format; may be null, defaults to None
    :type thumbnail: :class:`Thumbnail`, optional
    """

    ID: typing.Literal["inlineQueryResultArticle"] = field(
        default="inlineQueryResultArticle", metadata={"alias": "@type"}
    )
    id: String
    url: String
    title: String
    description: String
    thumbnail: typing.Optional[Thumbnail] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InlineQueryResultAudio(BaseObject):
    """
    Represents an audio file

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param audio: Audio file
    :type audio: :class:`Audio`
    """

    ID: typing.Literal["inlineQueryResultAudio"] = field(default="inlineQueryResultAudio", metadata={"alias": "@type"})
    id: String
    audio: Audio


@dataclass(slots=True, kw_only=True)
class InlineQueryResultContact(BaseObject):
    """
    Represents a user contact

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param contact: A user contact
    :type contact: :class:`Contact`
    :param thumbnail: Result thumbnail in JPEG format; may be null, defaults to None
    :type thumbnail: :class:`Thumbnail`, optional
    """

    ID: typing.Literal["inlineQueryResultContact"] = field(
        default="inlineQueryResultContact", metadata={"alias": "@type"}
    )
    id: String
    contact: Contact
    thumbnail: typing.Optional[Thumbnail] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InlineQueryResultDocument(BaseObject):
    """
    Represents a document

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param document: Document
    :type document: :class:`Document`
    :param title: Document title
    :type title: :class:`String`
    :param description: Document description
    :type description: :class:`String`
    """

    ID: typing.Literal["inlineQueryResultDocument"] = field(
        default="inlineQueryResultDocument", metadata={"alias": "@type"}
    )
    id: String
    document: Document
    title: String
    description: String


@dataclass(slots=True, kw_only=True)
class InlineQueryResultGame(BaseObject):
    """
    Represents information about a game

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param game: Game result
    :type game: :class:`Game`
    """

    ID: typing.Literal["inlineQueryResultGame"] = field(default="inlineQueryResultGame", metadata={"alias": "@type"})
    id: String
    game: Game


@dataclass(slots=True, kw_only=True)
class InlineQueryResultLocation(BaseObject):
    """
    Represents a point on the map

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param location: Location result
    :type location: :class:`Location`
    :param title: Title of the result
    :type title: :class:`String`
    :param thumbnail: Result thumbnail in JPEG format; may be null, defaults to None
    :type thumbnail: :class:`Thumbnail`, optional
    """

    ID: typing.Literal["inlineQueryResultLocation"] = field(
        default="inlineQueryResultLocation", metadata={"alias": "@type"}
    )
    id: String
    location: Location
    title: String
    thumbnail: typing.Optional[Thumbnail] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InlineQueryResultPhoto(BaseObject):
    """
    Represents a photo

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param photo: Photo
    :type photo: :class:`Photo`
    :param title: Title of the result, if known
    :type title: :class:`String`
    :param description: A short description of the result, if known
    :type description: :class:`String`
    """

    ID: typing.Literal["inlineQueryResultPhoto"] = field(default="inlineQueryResultPhoto", metadata={"alias": "@type"})
    id: String
    photo: Photo
    title: String
    description: String


@dataclass(slots=True, kw_only=True)
class InlineQueryResultSticker(BaseObject):
    """
    Represents a sticker

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param sticker: Sticker
    :type sticker: :class:`Sticker`
    """

    ID: typing.Literal["inlineQueryResultSticker"] = field(
        default="inlineQueryResultSticker", metadata={"alias": "@type"}
    )
    id: String
    sticker: Sticker


@dataclass(slots=True, kw_only=True)
class InlineQueryResultVenue(BaseObject):
    """
    Represents information about a venue

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param venue: Venue result
    :type venue: :class:`Venue`
    :param thumbnail: Result thumbnail in JPEG format; may be null, defaults to None
    :type thumbnail: :class:`Thumbnail`, optional
    """

    ID: typing.Literal["inlineQueryResultVenue"] = field(default="inlineQueryResultVenue", metadata={"alias": "@type"})
    id: String
    venue: Venue
    thumbnail: typing.Optional[Thumbnail] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InlineQueryResultVideo(BaseObject):
    """
    Represents a video

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param video: Video
    :type video: :class:`Video`
    :param title: Title of the video
    :type title: :class:`String`
    :param description: Description of the video
    :type description: :class:`String`
    """

    ID: typing.Literal["inlineQueryResultVideo"] = field(default="inlineQueryResultVideo", metadata={"alias": "@type"})
    id: String
    video: Video
    title: String
    description: String


@dataclass(slots=True, kw_only=True)
class InlineQueryResultVoiceNote(BaseObject):
    """
    Represents a voice note

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param voice_note: Voice note
    :type voice_note: :class:`VoiceNote`
    :param title: Title of the voice note
    :type title: :class:`String`
    """

    ID: typing.Literal["inlineQueryResultVoiceNote"] = field(
        default="inlineQueryResultVoiceNote", metadata={"alias": "@type"}
    )
    id: String
    voice_note: VoiceNote
    title: String


InlineQueryResult = typing.Union[
    InlineQueryResultAnimation,
    InlineQueryResultArticle,
    InlineQueryResultAudio,
    InlineQueryResultContact,
    InlineQueryResultDocument,
    InlineQueryResultGame,
    InlineQueryResultLocation,
    InlineQueryResultPhoto,
    InlineQueryResultSticker,
    InlineQueryResultVenue,
    InlineQueryResultVideo,
    InlineQueryResultVoiceNote,
]


@dataclass(slots=True, kw_only=True)
class InlineQueryResults(BaseObject):
    """
    Represents the results of the inline query. Use sendInlineQueryResultMessage to send the result of the query

    :param inline_query_id: Unique identifier of the inline query
    :type inline_query_id: :class:`Int64`
    :param results: Results of the query
    :type results: :class:`Vector[InlineQueryResult]`
    :param button: Button to be shown above inline query results; may be null, defaults to None
    :type button: :class:`InlineQueryResultsButton`, optional
    :param next_offset: The offset for the next request. If empty, then there are no more results
    :type next_offset: :class:`String`
    """

    ID: typing.Literal["inlineQueryResults"] = field(default="inlineQueryResults", metadata={"alias": "@type"})
    inline_query_id: Int64
    results: Vector[InlineQueryResult]
    button: typing.Optional[InlineQueryResultsButton] = field(default=None)
    next_offset: String = field(default="")


@dataclass(slots=True, kw_only=True)
class InlineQueryResultsButton(BaseObject):
    """
    Represents a button to be shown above inline query results

    :param text: The text of the button
    :type text: :class:`String`
    :param type_: Type of the button
    :type type_: :class:`InlineQueryResultsButtonType`
    """

    ID: typing.Literal["inlineQueryResultsButton"] = field(
        default="inlineQueryResultsButton", metadata={"alias": "@type"}
    )
    text: String
    type_: InlineQueryResultsButtonType = field(default=MISSING, metadata={"alias": "type"})


@dataclass(slots=True, kw_only=True)
class InlineQueryResultsButtonTypeStartBot(BaseObject):
    """
    Describes the button that opens a private chat with the bot and sends a start message to the bot with the given parameter

    :param parameter: The parameter for the bot start message
    :type parameter: :class:`String`
    """

    ID: typing.Literal["inlineQueryResultsButtonTypeStartBot"] = field(
        default="inlineQueryResultsButtonTypeStartBot", metadata={"alias": "@type"}
    )
    parameter: String


@dataclass(slots=True, kw_only=True)
class InlineQueryResultsButtonTypeWebApp(BaseObject):
    """
    Describes the button that opens a Web App by calling getWebAppUrl

    :param url: An HTTP URL to pass to getWebAppUrl
    :type url: :class:`String`
    """

    ID: typing.Literal["inlineQueryResultsButtonTypeWebApp"] = field(
        default="inlineQueryResultsButtonTypeWebApp", metadata={"alias": "@type"}
    )
    url: String


InlineQueryResultsButtonType = typing.Union[
    InlineQueryResultsButtonTypeStartBot,
    InlineQueryResultsButtonTypeWebApp,
]


@dataclass(slots=True, kw_only=True)
class InputBackgroundLocal(BaseObject):
    """
    A background from a local file

    :param background: Background file to use. Only inputFileLocal and inputFileGenerated are supported. The file must be in JPEG format for wallpapers and in PNG format for patterns
    :type background: :class:`InputFile`
    """

    ID: typing.Literal["inputBackgroundLocal"] = field(default="inputBackgroundLocal", metadata={"alias": "@type"})
    background: InputFile


@dataclass(slots=True, kw_only=True)
class InputBackgroundPrevious(BaseObject):
    """
    A background previously set in the chat; for chat backgrounds only

    :param message_id: Identifier of the message with the background
    :type message_id: :class:`Int53`
    """

    ID: typing.Literal["inputBackgroundPrevious"] = field(
        default="inputBackgroundPrevious", metadata={"alias": "@type"}
    )
    message_id: Int53


@dataclass(slots=True, kw_only=True)
class InputBackgroundRemote(BaseObject):
    """
    A background from the server

    :param background_id: The background identifier
    :type background_id: :class:`Int64`
    """

    ID: typing.Literal["inputBackgroundRemote"] = field(default="inputBackgroundRemote", metadata={"alias": "@type"})
    background_id: Int64


InputBackground = typing.Union[
    InputBackgroundLocal,
    InputBackgroundPrevious,
    InputBackgroundRemote,
]


@dataclass(slots=True, kw_only=True)
class InputBusinessChatLink(BaseObject):
    """
    Describes a business chat link to create or edit

    :param text: Message draft text that will be added to the input field
    :type text: :class:`FormattedText`
    :param title: Link title
    :type title: :class:`String`
    """

    ID: typing.Literal["inputBusinessChatLink"] = field(default="inputBusinessChatLink", metadata={"alias": "@type"})
    text: FormattedText
    title: String


@dataclass(slots=True, kw_only=True)
class InputBusinessStartPage(BaseObject):
    """
    Describes settings for a business account start page to set

    :param title: Title text of the start page; 0-getOption("business_start_page_title_length_max") characters
    :type title: :class:`String`
    :param message: Message text of the start page; 0-getOption("business_start_page_message_length_max") characters
    :type message: :class:`String`
    :param sticker: Greeting sticker of the start page; pass null if none. The sticker must belong to a sticker set and must not be a custom emoji, defaults to None
    :type sticker: :class:`InputFile`, optional
    """

    ID: typing.Literal["inputBusinessStartPage"] = field(default="inputBusinessStartPage", metadata={"alias": "@type"})
    title: String
    message: String
    sticker: typing.Optional[InputFile] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputChatPhotoAnimation(BaseObject):
    """
    An animation in MPEG4 format; must be square, at most 10 seconds long, have width between 160 and 1280 and be at most 2MB in size

    :param animation: Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
    :type animation: :class:`InputFile`
    :param main_frame_timestamp: Timestamp of the frame, which will be used as static chat photo
    :type main_frame_timestamp: :class:`Double`
    """

    ID: typing.Literal["inputChatPhotoAnimation"] = field(
        default="inputChatPhotoAnimation", metadata={"alias": "@type"}
    )
    animation: InputFile
    main_frame_timestamp: Double


@dataclass(slots=True, kw_only=True)
class InputChatPhotoPrevious(BaseObject):
    """
    A previously used profile photo of the current user

    :param chat_photo_id: Identifier of the current user's profile photo to reuse
    :type chat_photo_id: :class:`Int64`
    """

    ID: typing.Literal["inputChatPhotoPrevious"] = field(default="inputChatPhotoPrevious", metadata={"alias": "@type"})
    chat_photo_id: Int64


@dataclass(slots=True, kw_only=True)
class InputChatPhotoStatic(BaseObject):
    """
    A static photo in JPEG format

    :param photo: Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
    :type photo: :class:`InputFile`
    """

    ID: typing.Literal["inputChatPhotoStatic"] = field(default="inputChatPhotoStatic", metadata={"alias": "@type"})
    photo: InputFile


@dataclass(slots=True, kw_only=True)
class InputChatPhotoSticker(BaseObject):
    """
    A sticker on a custom background

    :param sticker: Information about the sticker
    :type sticker: :class:`ChatPhotoSticker`
    """

    ID: typing.Literal["inputChatPhotoSticker"] = field(default="inputChatPhotoSticker", metadata={"alias": "@type"})
    sticker: ChatPhotoSticker


InputChatPhoto = typing.Union[
    InputChatPhotoAnimation,
    InputChatPhotoPrevious,
    InputChatPhotoStatic,
    InputChatPhotoSticker,
]


@dataclass(slots=True, kw_only=True)
class InputCredentialsApplePay(BaseObject):
    """
    Applies if a user enters new credentials using Apple Pay

    :param data: JSON-encoded data with the credential identifier
    :type data: :class:`String`
    """

    ID: typing.Literal["inputCredentialsApplePay"] = field(
        default="inputCredentialsApplePay", metadata={"alias": "@type"}
    )
    data: String


@dataclass(slots=True, kw_only=True)
class InputCredentialsGooglePay(BaseObject):
    """
    Applies if a user enters new credentials using Google Pay

    :param data: JSON-encoded data with the credential identifier
    :type data: :class:`String`
    """

    ID: typing.Literal["inputCredentialsGooglePay"] = field(
        default="inputCredentialsGooglePay", metadata={"alias": "@type"}
    )
    data: String


@dataclass(slots=True, kw_only=True)
class InputCredentialsNew(BaseObject):
    """
    Applies if a user enters new credentials on a payment provider website

    :param data: JSON-encoded data with the credential identifier from the payment provider
    :type data: :class:`String`
    :param allow_save: True, if the credential identifier can be saved on the server side
    :type allow_save: :class:`Bool`
    """

    ID: typing.Literal["inputCredentialsNew"] = field(default="inputCredentialsNew", metadata={"alias": "@type"})
    data: String
    allow_save: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class InputCredentialsSaved(BaseObject):
    """
    Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password

    :param saved_credentials_id: Identifier of the saved credentials
    :type saved_credentials_id: :class:`String`
    """

    ID: typing.Literal["inputCredentialsSaved"] = field(default="inputCredentialsSaved", metadata={"alias": "@type"})
    saved_credentials_id: String


InputCredentials = typing.Union[
    InputCredentialsApplePay,
    InputCredentialsGooglePay,
    InputCredentialsNew,
    InputCredentialsSaved,
]


@dataclass(slots=True, kw_only=True)
class InputFileGenerated(BaseObject):
    """
    A file generated by the application. The application must handle updates updateFileGenerationStart and updateFileGenerationStop to generate the file when asked by TDLib

    :param original_path: Local path to a file from which the file is generated. The path doesn't have to be a valid path and is used by TDLib only to detect name and MIME type of the generated file
    :type original_path: :class:`String`
    :param conversion: String specifying the conversion applied to the original file; must be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage
    :type conversion: :class:`String`
    :param expected_size: Expected size of the generated file, in bytes; pass 0 if unknown
    :type expected_size: :class:`Int53`
    """

    ID: typing.Literal["inputFileGenerated"] = field(default="inputFileGenerated", metadata={"alias": "@type"})
    original_path: String
    conversion: String
    expected_size: Int53 = field(default=0)


@dataclass(slots=True, kw_only=True)
class InputFileId(BaseObject):
    """
    A file defined by its unique identifier

    :param id: Unique file identifier
    :type id: :class:`Int32`
    """

    ID: typing.Literal["inputFileId"] = field(default="inputFileId", metadata={"alias": "@type"})
    id: Int32


@dataclass(slots=True, kw_only=True)
class InputFileLocal(BaseObject):
    """
    A file defined by a local path

    :param path: Local path to the file
    :type path: :class:`String`
    """

    ID: typing.Literal["inputFileLocal"] = field(default="inputFileLocal", metadata={"alias": "@type"})
    path: String


@dataclass(slots=True, kw_only=True)
class InputFileRemote(BaseObject):
    """
    A file defined by its remote identifier. The remote identifier is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib. For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application

    :param id: Remote file identifier
    :type id: :class:`String`
    """

    ID: typing.Literal["inputFileRemote"] = field(default="inputFileRemote", metadata={"alias": "@type"})
    id: String


InputFile = typing.Union[
    InputFileGenerated,
    InputFileId,
    InputFileLocal,
    InputFileRemote,
]


@dataclass(slots=True, kw_only=True)
class InputIdentityDocument(BaseObject):
    """
    An identity document to be saved to Telegram Passport

    :param number: Document number; 1-24 characters
    :type number: :class:`String`
    :param front_side: Front side of the document
    :type front_side: :class:`InputFile`
    :param translation: List of files containing a certified English translation of the document
    :type translation: :class:`Vector[InputFile]`
    :param expiration_date: Document expiration date; pass null if not applicable, defaults to None
    :type expiration_date: :class:`Date`, optional
    :param reverse_side: Reverse side of the document; only for driver license and identity card; pass null otherwise, defaults to None
    :type reverse_side: :class:`InputFile`, optional
    :param selfie: Selfie with the document; pass null if unavailable, defaults to None
    :type selfie: :class:`InputFile`, optional
    """

    ID: typing.Literal["inputIdentityDocument"] = field(default="inputIdentityDocument", metadata={"alias": "@type"})
    number: String = field(default=MISSING, metadata={"min_length": 1, "max_length": 24})
    front_side: InputFile
    translation: Vector[InputFile]
    expiration_date: typing.Optional[Date] = field(default=None)
    reverse_side: typing.Optional[InputFile] = field(default=None)
    selfie: typing.Optional[InputFile] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputInlineQueryResultAnimation(BaseObject):
    """
    Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4 AVC video

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param title: Title of the query result
    :type title: :class:`String`
    :param thumbnail_url: URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists
    :type thumbnail_url: :class:`String`
    :param video_url: The URL of the video file (file size must not exceed 1MB)
    :type video_url: :class:`String`
    :param video_mime_type: MIME type of the video file. Must be one of "image/gif" and "video/mp4"
    :type video_mime_type: :class:`String`
    :param video_duration: Duration of the video, in seconds
    :type video_duration: :class:`Int32`
    :param video_width: Width of the video
    :type video_width: :class:`Int32`
    :param video_height: Height of the video
    :type video_height: :class:`Int32`
    :param input_message_content: The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
    :type input_message_content: :class:`InputMessageContent`
    :param thumbnail_mime_type: MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif" and "video/mp4"
    :type thumbnail_mime_type: :class:`String`
    :param reply_markup: The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    """

    ID: typing.Literal["inputInlineQueryResultAnimation"] = field(
        default="inputInlineQueryResultAnimation", metadata={"alias": "@type"}
    )
    id: String
    title: String
    thumbnail_url: String
    video_url: String
    video_mime_type: String
    video_duration: Int32
    video_width: Int32
    video_height: Int32
    input_message_content: InputMessageContent
    thumbnail_mime_type: String = field(default="")
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputInlineQueryResultArticle(BaseObject):
    """
    Represents a link to an article or web page

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param url: URL of the result, if it exists
    :type url: :class:`String`
    :param title: Title of the result
    :type title: :class:`String`
    :param description: A short description of the result
    :type description: :class:`String`
    :param thumbnail_url: URL of the result thumbnail, if it exists
    :type thumbnail_url: :class:`String`
    :param thumbnail_width: Thumbnail width, if known
    :type thumbnail_width: :class:`Int32`
    :param thumbnail_height: Thumbnail height, if known
    :type thumbnail_height: :class:`Int32`
    :param input_message_content: The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
    :type input_message_content: :class:`InputMessageContent`
    :param reply_markup: The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    """

    ID: typing.Literal["inputInlineQueryResultArticle"] = field(
        default="inputInlineQueryResultArticle", metadata={"alias": "@type"}
    )
    id: String
    url: String
    title: String
    description: String
    thumbnail_url: String
    thumbnail_width: Int32
    thumbnail_height: Int32
    input_message_content: InputMessageContent
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputInlineQueryResultAudio(BaseObject):
    """
    Represents a link to an MP3 audio file

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param title: Title of the audio file
    :type title: :class:`String`
    :param performer: Performer of the audio file
    :type performer: :class:`String`
    :param audio_url: The URL of the audio file
    :type audio_url: :class:`String`
    :param audio_duration: Audio file duration, in seconds
    :type audio_duration: :class:`Int32`
    :param input_message_content: The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
    :type input_message_content: :class:`InputMessageContent`
    :param reply_markup: The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    """

    ID: typing.Literal["inputInlineQueryResultAudio"] = field(
        default="inputInlineQueryResultAudio", metadata={"alias": "@type"}
    )
    id: String
    title: String
    performer: String
    audio_url: String
    audio_duration: Int32
    input_message_content: InputMessageContent
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputInlineQueryResultContact(BaseObject):
    """
    Represents a user contact

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param contact: User contact
    :type contact: :class:`Contact`
    :param thumbnail_url: URL of the result thumbnail, if it exists
    :type thumbnail_url: :class:`String`
    :param thumbnail_width: Thumbnail width, if known
    :type thumbnail_width: :class:`Int32`
    :param thumbnail_height: Thumbnail height, if known
    :type thumbnail_height: :class:`Int32`
    :param input_message_content: The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
    :type input_message_content: :class:`InputMessageContent`
    :param reply_markup: The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    """

    ID: typing.Literal["inputInlineQueryResultContact"] = field(
        default="inputInlineQueryResultContact", metadata={"alias": "@type"}
    )
    id: String
    contact: Contact
    thumbnail_url: String
    thumbnail_width: Int32
    thumbnail_height: Int32
    input_message_content: InputMessageContent
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputInlineQueryResultDocument(BaseObject):
    """
    Represents a link to a file

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param title: Title of the resulting file
    :type title: :class:`String`
    :param description: Short description of the result, if known
    :type description: :class:`String`
    :param document_url: URL of the file
    :type document_url: :class:`String`
    :param mime_type: MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed
    :type mime_type: :class:`String`
    :param thumbnail_url: The URL of the file thumbnail, if it exists
    :type thumbnail_url: :class:`String`
    :param thumbnail_width: Width of the thumbnail
    :type thumbnail_width: :class:`Int32`
    :param thumbnail_height: Height of the thumbnail
    :type thumbnail_height: :class:`Int32`
    :param input_message_content: The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
    :type input_message_content: :class:`InputMessageContent`
    :param reply_markup: The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    """

    ID: typing.Literal["inputInlineQueryResultDocument"] = field(
        default="inputInlineQueryResultDocument", metadata={"alias": "@type"}
    )
    id: String
    title: String
    description: String
    document_url: String
    mime_type: String
    thumbnail_url: String
    thumbnail_width: Int32
    thumbnail_height: Int32
    input_message_content: InputMessageContent
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputInlineQueryResultGame(BaseObject):
    """
    Represents a game

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param game_short_name: Short name of the game
    :type game_short_name: :class:`String`
    :param reply_markup: The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    """

    ID: typing.Literal["inputInlineQueryResultGame"] = field(
        default="inputInlineQueryResultGame", metadata={"alias": "@type"}
    )
    id: String
    game_short_name: String
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputInlineQueryResultLocation(BaseObject):
    """
    Represents a point on the map

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param location: Location result
    :type location: :class:`Location`
    :param live_period: Amount of time relative to the message sent time until the location can be updated, in seconds
    :type live_period: :class:`Int32`
    :param title: Title of the result
    :type title: :class:`String`
    :param thumbnail_url: URL of the result thumbnail, if it exists
    :type thumbnail_url: :class:`String`
    :param thumbnail_width: Thumbnail width, if known
    :type thumbnail_width: :class:`Int32`
    :param thumbnail_height: Thumbnail height, if known
    :type thumbnail_height: :class:`Int32`
    :param input_message_content: The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
    :type input_message_content: :class:`InputMessageContent`
    :param reply_markup: The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    """

    ID: typing.Literal["inputInlineQueryResultLocation"] = field(
        default="inputInlineQueryResultLocation", metadata={"alias": "@type"}
    )
    id: String
    location: Location
    live_period: Int32
    title: String
    thumbnail_url: String
    thumbnail_width: Int32
    thumbnail_height: Int32
    input_message_content: InputMessageContent
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputInlineQueryResultPhoto(BaseObject):
    """
    Represents link to a JPEG image

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param title: Title of the result, if known
    :type title: :class:`String`
    :param description: A short description of the result, if known
    :type description: :class:`String`
    :param thumbnail_url: URL of the photo thumbnail, if it exists
    :type thumbnail_url: :class:`String`
    :param photo_url: The URL of the JPEG photo (photo size must not exceed 5MB)
    :type photo_url: :class:`String`
    :param photo_width: Width of the photo
    :type photo_width: :class:`Int32`
    :param photo_height: Height of the photo
    :type photo_height: :class:`Int32`
    :param input_message_content: The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
    :type input_message_content: :class:`InputMessageContent`
    :param reply_markup: The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    """

    ID: typing.Literal["inputInlineQueryResultPhoto"] = field(
        default="inputInlineQueryResultPhoto", metadata={"alias": "@type"}
    )
    id: String
    title: String
    description: String
    thumbnail_url: String
    photo_url: String
    photo_width: Int32
    photo_height: Int32
    input_message_content: InputMessageContent
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputInlineQueryResultSticker(BaseObject):
    """
    Represents a link to a WEBP, TGS, or WEBM sticker

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param thumbnail_url: URL of the sticker thumbnail, if it exists
    :type thumbnail_url: :class:`String`
    :param sticker_url: The URL of the WEBP, TGS, or WEBM sticker (sticker file size must not exceed 5MB)
    :type sticker_url: :class:`String`
    :param sticker_width: Width of the sticker
    :type sticker_width: :class:`Int32`
    :param sticker_height: Height of the sticker
    :type sticker_height: :class:`Int32`
    :param input_message_content: The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
    :type input_message_content: :class:`InputMessageContent`
    :param reply_markup: The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    """

    ID: typing.Literal["inputInlineQueryResultSticker"] = field(
        default="inputInlineQueryResultSticker", metadata={"alias": "@type"}
    )
    id: String
    thumbnail_url: String
    sticker_url: String
    sticker_width: Int32
    sticker_height: Int32
    input_message_content: InputMessageContent
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputInlineQueryResultVenue(BaseObject):
    """
    Represents information about a venue

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param venue: Venue result
    :type venue: :class:`Venue`
    :param thumbnail_url: URL of the result thumbnail, if it exists
    :type thumbnail_url: :class:`String`
    :param thumbnail_width: Thumbnail width, if known
    :type thumbnail_width: :class:`Int32`
    :param thumbnail_height: Thumbnail height, if known
    :type thumbnail_height: :class:`Int32`
    :param input_message_content: The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
    :type input_message_content: :class:`InputMessageContent`
    :param reply_markup: The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    """

    ID: typing.Literal["inputInlineQueryResultVenue"] = field(
        default="inputInlineQueryResultVenue", metadata={"alias": "@type"}
    )
    id: String
    venue: Venue
    thumbnail_url: String
    thumbnail_width: Int32
    thumbnail_height: Int32
    input_message_content: InputMessageContent
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputInlineQueryResultVideo(BaseObject):
    """
    Represents a link to a page containing an embedded video player or a video file

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param title: Title of the result
    :type title: :class:`String`
    :param description: A short description of the result, if known
    :type description: :class:`String`
    :param thumbnail_url: The URL of the video thumbnail (JPEG), if it exists
    :type thumbnail_url: :class:`String`
    :param video_url: URL of the embedded video player or video file
    :type video_url: :class:`String`
    :param mime_type: MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported
    :type mime_type: :class:`String`
    :param video_width: Width of the video
    :type video_width: :class:`Int32`
    :param video_height: Height of the video
    :type video_height: :class:`Int32`
    :param video_duration: Video duration, in seconds
    :type video_duration: :class:`Int32`
    :param input_message_content: The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
    :type input_message_content: :class:`InputMessageContent`
    :param reply_markup: The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    """

    ID: typing.Literal["inputInlineQueryResultVideo"] = field(
        default="inputInlineQueryResultVideo", metadata={"alias": "@type"}
    )
    id: String
    title: String
    description: String
    thumbnail_url: String
    video_url: String
    mime_type: String
    video_width: Int32
    video_height: Int32
    video_duration: Int32
    input_message_content: InputMessageContent
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputInlineQueryResultVoiceNote(BaseObject):
    """
    Represents a link to an opus-encoded audio file within an OGG container, single channel audio

    :param id: Unique identifier of the query result
    :type id: :class:`String`
    :param title: Title of the voice note
    :type title: :class:`String`
    :param voice_note_url: The URL of the voice note file
    :type voice_note_url: :class:`String`
    :param voice_note_duration: Duration of the voice note, in seconds
    :type voice_note_duration: :class:`Int32`
    :param input_message_content: The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
    :type input_message_content: :class:`InputMessageContent`
    :param reply_markup: The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    """

    ID: typing.Literal["inputInlineQueryResultVoiceNote"] = field(
        default="inputInlineQueryResultVoiceNote", metadata={"alias": "@type"}
    )
    id: String
    title: String
    voice_note_url: String
    voice_note_duration: Int32
    input_message_content: InputMessageContent
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)


InputInlineQueryResult = typing.Union[
    InputInlineQueryResultAnimation,
    InputInlineQueryResultArticle,
    InputInlineQueryResultAudio,
    InputInlineQueryResultContact,
    InputInlineQueryResultDocument,
    InputInlineQueryResultGame,
    InputInlineQueryResultLocation,
    InputInlineQueryResultPhoto,
    InputInlineQueryResultSticker,
    InputInlineQueryResultVenue,
    InputInlineQueryResultVideo,
    InputInlineQueryResultVoiceNote,
]


@dataclass(slots=True, kw_only=True)
class InputInvoiceMessage(BaseObject):
    """
    An invoice from a message of the type messageInvoice or paid media purchase from messagePaidMedia

    :param chat_id: Chat identifier of the message
    :type chat_id: :class:`Int53`
    :param message_id: Message identifier. Use messageProperties.can_be_paid to check whether the message can be used in the method
    :type message_id: :class:`Int53`
    """

    ID: typing.Literal["inputInvoiceMessage"] = field(default="inputInvoiceMessage", metadata={"alias": "@type"})
    chat_id: Int53
    message_id: Int53


@dataclass(slots=True, kw_only=True)
class InputInvoiceName(BaseObject):
    """
    An invoice from a link of the type internalLinkTypeInvoice

    :param name: Name of the invoice
    :type name: :class:`String`
    """

    ID: typing.Literal["inputInvoiceName"] = field(default="inputInvoiceName", metadata={"alias": "@type"})
    name: String


@dataclass(slots=True, kw_only=True)
class InputInvoiceTelegram(BaseObject):
    """
    An invoice for a payment toward Telegram; must not be used in the in-store apps

    :param purpose: Transaction purpose
    :type purpose: :class:`TelegramPaymentPurpose`
    """

    ID: typing.Literal["inputInvoiceTelegram"] = field(default="inputInvoiceTelegram", metadata={"alias": "@type"})
    purpose: TelegramPaymentPurpose


InputInvoice = typing.Union[
    InputInvoiceMessage,
    InputInvoiceName,
    InputInvoiceTelegram,
]


@dataclass(slots=True, kw_only=True)
class InputMessageAnimation(BaseObject):
    """
    An animation message (GIF-style).

    :param animation: Animation file to be sent
    :type animation: :class:`InputFile`
    :param added_sticker_file_ids: File identifiers of the stickers added to the animation, if applicable
    :type added_sticker_file_ids: :class:`Vector[Int32]`
    :param duration: Duration of the animation, in seconds
    :type duration: :class:`Int32`
    :param width: Width of the animation; may be replaced by the server
    :type width: :class:`Int32`
    :param height: Height of the animation; may be replaced by the server
    :type height: :class:`Int32`
    :param show_caption_above_media: True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation; not supported in secret chats
    :type show_caption_above_media: :class:`Bool`
    :param has_spoiler: True, if the animation preview must be covered by a spoiler animation; not supported in secret chats
    :type has_spoiler: :class:`Bool`
    :param thumbnail: Animation thumbnail; pass null to skip thumbnail uploading, defaults to None
    :type thumbnail: :class:`InputThumbnail`, optional
    :param caption: Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters, defaults to None
    :type caption: :class:`FormattedText`, optional
    """

    ID: typing.Literal["inputMessageAnimation"] = field(default="inputMessageAnimation", metadata={"alias": "@type"})
    animation: InputFile
    added_sticker_file_ids: Vector[Int32]
    duration: Int32
    width: Int32
    height: Int32
    show_caption_above_media: Bool = field(default=False)
    has_spoiler: Bool = field(default=False)
    thumbnail: typing.Optional[InputThumbnail] = field(default=None)
    caption: typing.Optional[FormattedText] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputMessageAudio(BaseObject):
    """
    An audio message

    :param audio: Audio file to be sent
    :type audio: :class:`InputFile`
    :param duration: Duration of the audio, in seconds; may be replaced by the server
    :type duration: :class:`Int32`
    :param title: Title of the audio; 0-64 characters; may be replaced by the server
    :type title: :class:`String`
    :param performer: Performer of the audio; 0-64 characters, may be replaced by the server
    :type performer: :class:`String`
    :param album_cover_thumbnail: Thumbnail of the cover for the album; pass null to skip thumbnail uploading, defaults to None
    :type album_cover_thumbnail: :class:`InputThumbnail`, optional
    :param caption: Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters, defaults to None
    :type caption: :class:`FormattedText`, optional
    """

    ID: typing.Literal["inputMessageAudio"] = field(default="inputMessageAudio", metadata={"alias": "@type"})
    audio: InputFile
    duration: Int32
    title: String = field(default="", metadata={"max_length": 64})
    performer: String = field(default="", metadata={"max_length": 64})
    album_cover_thumbnail: typing.Optional[InputThumbnail] = field(default=None)
    caption: typing.Optional[FormattedText] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputMessageContact(BaseObject):
    """
    A message containing a user contact

    :param contact: Contact to send
    :type contact: :class:`Contact`
    """

    ID: typing.Literal["inputMessageContact"] = field(default="inputMessageContact", metadata={"alias": "@type"})
    contact: Contact


@dataclass(slots=True, kw_only=True)
class InputMessageDice(BaseObject):
    """
    A dice message

    :param emoji: Emoji on which the dice throw animation is based
    :type emoji: :class:`String`
    :param clear_draft: True, if the chat message draft must be deleted
    :type clear_draft: :class:`Bool`
    """

    ID: typing.Literal["inputMessageDice"] = field(default="inputMessageDice", metadata={"alias": "@type"})
    emoji: String
    clear_draft: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class InputMessageDocument(BaseObject):
    """
    A document message (general file)

    :param document: Document to be sent
    :type document: :class:`InputFile`
    :param disable_content_type_detection: Pass true to disable automatic file type detection and send the document as a file. Always true for files sent to secret chats
    :type disable_content_type_detection: :class:`Bool`
    :param thumbnail: Document thumbnail; pass null to skip thumbnail uploading, defaults to None
    :type thumbnail: :class:`InputThumbnail`, optional
    :param caption: Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters, defaults to None
    :type caption: :class:`FormattedText`, optional
    """

    ID: typing.Literal["inputMessageDocument"] = field(default="inputMessageDocument", metadata={"alias": "@type"})
    document: InputFile
    disable_content_type_detection: Bool = field(default=False)
    thumbnail: typing.Optional[InputThumbnail] = field(default=None)
    caption: typing.Optional[FormattedText] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputMessageForwarded(BaseObject):
    """
    A forwarded message

    :param from_chat_id: Identifier for the chat this forwarded message came from
    :type from_chat_id: :class:`Int53`
    :param message_id: Identifier of the message to forward. A message can be forwarded only if messageProperties.can_be_forwarded
    :type message_id: :class:`Int53`
    :param new_video_start_timestamp: The new video start timestamp; ignored if replace_video_start_timestamp == false
    :type new_video_start_timestamp: :class:`Int32`
    :param in_game_share: Pass true if a game message is being shared from a launched game; applies only to game messages
    :type in_game_share: :class:`Bool`
    :param replace_video_start_timestamp: Pass true to replace video start timestamp in the forwarded message
    :type replace_video_start_timestamp: :class:`Bool`
    :param copy_options: Options to be used to copy content of the message without reference to the original sender; pass null to forward the message as usual, defaults to None
    :type copy_options: :class:`MessageCopyOptions`, optional
    """

    ID: typing.Literal["inputMessageForwarded"] = field(default="inputMessageForwarded", metadata={"alias": "@type"})
    from_chat_id: Int53
    message_id: Int53
    new_video_start_timestamp: Int32
    in_game_share: Bool = field(default=False)
    replace_video_start_timestamp: Bool = field(default=False)
    copy_options: typing.Optional[MessageCopyOptions] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputMessageGame(BaseObject):
    """
    A message with a game; not supported for channels or secret chats

    :param bot_user_id: User identifier of the bot that owns the game
    :type bot_user_id: :class:`Int53`
    :param game_short_name: Short name of the game
    :type game_short_name: :class:`String`
    """

    ID: typing.Literal["inputMessageGame"] = field(default="inputMessageGame", metadata={"alias": "@type"})
    bot_user_id: Int53
    game_short_name: String


@dataclass(slots=True, kw_only=True)
class InputMessageInvoice(BaseObject):
    """
    A message with an invoice; can be used only by bots

    :param invoice: Invoice
    :type invoice: :class:`Invoice`
    :param title: Product title; 1-32 characters
    :type title: :class:`String`
    :param photo_url: Product photo URL; optional
    :type photo_url: :class:`String`
    :param photo_size: Product photo size
    :type photo_size: :class:`Int32`
    :param photo_width: Product photo width
    :type photo_width: :class:`Int32`
    :param photo_height: Product photo height
    :type photo_height: :class:`Int32`
    :param payload: The invoice payload
    :type payload: :class:`Bytes`
    :param provider_data: JSON-encoded data about the invoice, which will be shared with the payment provider
    :type provider_data: :class:`String`
    :param description: Product description; 0-255 characters
    :type description: :class:`String`
    :param provider_token: Payment provider token; may be empty for payments in Telegram Stars
    :type provider_token: :class:`String`
    :param start_parameter: Unique invoice bot deep link parameter for the generation of this invoice. If empty, it would be possible to pay directly from forwards of the invoice message
    :type start_parameter: :class:`String`
    :param paid_media: The content of paid media attached to the invoice; pass null if none, defaults to None
    :type paid_media: :class:`InputPaidMedia`, optional
    :param paid_media_caption: Paid media caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters, defaults to None
    :type paid_media_caption: :class:`FormattedText`, optional
    """

    ID: typing.Literal["inputMessageInvoice"] = field(default="inputMessageInvoice", metadata={"alias": "@type"})
    invoice: Invoice
    title: String = field(default=MISSING, metadata={"min_length": 1, "max_length": 32})
    photo_url: String
    photo_size: Int32
    photo_width: Int32
    photo_height: Int32
    payload: Bytes
    provider_data: String
    description: String = field(default="", metadata={"max_length": 255})
    provider_token: String = field(default="")
    start_parameter: String = field(default="")
    paid_media: typing.Optional[InputPaidMedia] = field(default=None)
    paid_media_caption: typing.Optional[FormattedText] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputMessageLocation(BaseObject):
    """
    A message with a location

    :param location: Location to be sent
    :type location: :class:`Location`
    :param live_period: Period for which the location can be updated, in seconds; must be between 60 and 86400 for a temporary live location, 0x7FFFFFFF for permanent live location, and 0 otherwise
    :type live_period: :class:`Int32`
    :param heading: For live locations, a direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
    :type heading: :class:`Int32`
    :param proximity_alert_radius: For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in channels and Saved Messages
    :type proximity_alert_radius: :class:`Int32`
    """

    ID: typing.Literal["inputMessageLocation"] = field(default="inputMessageLocation", metadata={"alias": "@type"})
    location: Location
    live_period: Int32
    heading: Int32 = field(default=0)
    proximity_alert_radius: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class InputMessagePaidMedia(BaseObject):
    """
    A message with paid media; can be used only in channel chats with supergroupFullInfo.has_paid_media_allowed

    :param star_count: The number of Telegram Stars that must be paid to see the media; 1-getOption("paid_media_message_star_count_max")
    :type star_count: :class:`Int53`
    :param paid_media: The content of the paid media
    :type paid_media: :class:`Vector[InputPaidMedia]`
    :param payload: Bot-provided data for the paid media; bots only
    :type payload: :class:`String`
    :param show_caption_above_media: True, if the caption must be shown above the media; otherwise, the caption must be shown below the media; not supported in secret chats
    :type show_caption_above_media: :class:`Bool`
    :param caption: Message caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters, defaults to None
    :type caption: :class:`FormattedText`, optional
    """

    ID: typing.Literal["inputMessagePaidMedia"] = field(default="inputMessagePaidMedia", metadata={"alias": "@type"})
    star_count: Int53
    paid_media: Vector[InputPaidMedia]
    payload: String
    show_caption_above_media: Bool = field(default=False)
    caption: typing.Optional[FormattedText] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputMessagePhoto(BaseObject):
    """
    A photo message

    :param photo: Photo to send. The photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height ratio must be at most 20
    :type photo: :class:`InputFile`
    :param added_sticker_file_ids: File identifiers of the stickers added to the photo, if applicable
    :type added_sticker_file_ids: :class:`Vector[Int32]`
    :param width: Photo width
    :type width: :class:`Int32`
    :param height: Photo height
    :type height: :class:`Int32`
    :param show_caption_above_media: True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo; not supported in secret chats
    :type show_caption_above_media: :class:`Bool`
    :param has_spoiler: True, if the photo preview must be covered by a spoiler animation; not supported in secret chats
    :type has_spoiler: :class:`Bool`
    :param thumbnail: Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail is sent to the other party only in secret chats, defaults to None
    :type thumbnail: :class:`InputThumbnail`, optional
    :param caption: Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters, defaults to None
    :type caption: :class:`FormattedText`, optional
    :param self_destruct_type: Photo self-destruct type; pass null if none; private chats only, defaults to None
    :type self_destruct_type: :class:`MessageSelfDestructType`, optional
    """

    ID: typing.Literal["inputMessagePhoto"] = field(default="inputMessagePhoto", metadata={"alias": "@type"})
    photo: InputFile
    added_sticker_file_ids: Vector[Int32]
    width: Int32
    height: Int32
    show_caption_above_media: Bool = field(default=False)
    has_spoiler: Bool = field(default=False)
    thumbnail: typing.Optional[InputThumbnail] = field(default=None)
    caption: typing.Optional[FormattedText] = field(default=None)
    self_destruct_type: typing.Optional[MessageSelfDestructType] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputMessagePoll(BaseObject):
    """
    A message with a poll. Polls can't be sent to secret chats. Polls can be sent only to a private chat with a bot

    :param question: Poll question; 1-255 characters (up to 300 characters for bots). Only custom emoji entities are allowed to be added and only by Premium users
    :type question: :class:`FormattedText`
    :param options: List of poll answer options, 2-10 strings 1-100 characters each. Only custom emoji entities are allowed to be added and only by Premium users
    :type options: :class:`Vector[FormattedText]`
    :param type_: Type of the poll
    :type type_: :class:`PollType`
    :param open_period: Amount of time the poll will be active after creation, in seconds; for bots only
    :type open_period: :class:`Int32`
    :param close_date: Point in time (Unix timestamp) when the poll will automatically be closed; for bots only
    :type close_date: :class:`Int32`
    :param is_anonymous: True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded to channels
    :type is_anonymous: :class:`Bool`
    :param is_closed: True, if the poll needs to be sent already closed; for bots only
    :type is_closed: :class:`Bool`
    """

    ID: typing.Literal["inputMessagePoll"] = field(default="inputMessagePoll", metadata={"alias": "@type"})
    question: FormattedText
    options: Vector[FormattedText]
    type_: PollType = field(default=MISSING, metadata={"alias": "type"})
    open_period: Int32
    close_date: Int32
    is_anonymous: Bool = field(default=False)
    is_closed: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class InputMessageSticker(BaseObject):
    """
    A sticker message

    :param sticker: Sticker to be sent
    :type sticker: :class:`InputFile`
    :param width: Sticker width
    :type width: :class:`Int32`
    :param height: Sticker height
    :type height: :class:`Int32`
    :param emoji: Emoji used to choose the sticker
    :type emoji: :class:`String`
    :param thumbnail: Sticker thumbnail; pass null to skip thumbnail uploading, defaults to None
    :type thumbnail: :class:`InputThumbnail`, optional
    """

    ID: typing.Literal["inputMessageSticker"] = field(default="inputMessageSticker", metadata={"alias": "@type"})
    sticker: InputFile
    width: Int32
    height: Int32
    emoji: String
    thumbnail: typing.Optional[InputThumbnail] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputMessageStory(BaseObject):
    """
    A message with a forwarded story. Stories can't be sent to secret chats. A story can be forwarded only if story.can_be_forwarded

    :param story_sender_chat_id: Identifier of the chat that posted the story
    :type story_sender_chat_id: :class:`Int53`
    :param story_id: Story identifier
    :type story_id: :class:`Int32`
    """

    ID: typing.Literal["inputMessageStory"] = field(default="inputMessageStory", metadata={"alias": "@type"})
    story_sender_chat_id: Int53
    story_id: Int32


@dataclass(slots=True, kw_only=True)
class InputMessageText(BaseObject):
    """
    A text message

    :param text: Formatted text to be sent; 0-getOption("message_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, ExpandableBlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually
    :type text: :class:`FormattedText`
    :param clear_draft: True, if a chat message draft must be deleted
    :type clear_draft: :class:`Bool`
    :param link_preview_options: Options to be used for generation of a link preview; may be null if none; pass null to use default link preview options, defaults to None
    :type link_preview_options: :class:`LinkPreviewOptions`, optional
    """

    ID: typing.Literal["inputMessageText"] = field(default="inputMessageText", metadata={"alias": "@type"})
    text: FormattedText
    clear_draft: Bool = field(default=False)
    link_preview_options: typing.Optional[LinkPreviewOptions] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputMessageVenue(BaseObject):
    """
    A message with information about a venue

    :param venue: Venue to send
    :type venue: :class:`Venue`
    """

    ID: typing.Literal["inputMessageVenue"] = field(default="inputMessageVenue", metadata={"alias": "@type"})
    venue: Venue


@dataclass(slots=True, kw_only=True)
class InputMessageVideo(BaseObject):
    """
    A video message

    :param video: Video to be sent. The video is expected to be re-encoded to MPEG4 format with H.264 codec by the sender
    :type video: :class:`InputFile`
    :param start_timestamp: Timestamp from which the video playing must start, in seconds
    :type start_timestamp: :class:`Int32`
    :param added_sticker_file_ids: File identifiers of the stickers added to the video, if applicable
    :type added_sticker_file_ids: :class:`Vector[Int32]`
    :param duration: Duration of the video, in seconds
    :type duration: :class:`Int32`
    :param width: Video width
    :type width: :class:`Int32`
    :param height: Video height
    :type height: :class:`Int32`
    :param supports_streaming: True, if the video is expected to be streamed
    :type supports_streaming: :class:`Bool`
    :param show_caption_above_media: True, if the caption must be shown above the video; otherwise, the caption must be shown below the video; not supported in secret chats
    :type show_caption_above_media: :class:`Bool`
    :param has_spoiler: True, if the video preview must be covered by a spoiler animation; not supported in secret chats
    :type has_spoiler: :class:`Bool`
    :param thumbnail: Video thumbnail; pass null to skip thumbnail uploading, defaults to None
    :type thumbnail: :class:`InputThumbnail`, optional
    :param cover: Cover of the video; pass null to skip cover uploading; not supported in secret chats and for self-destructing messages, defaults to None
    :type cover: :class:`InputFile`, optional
    :param caption: Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters, defaults to None
    :type caption: :class:`FormattedText`, optional
    :param self_destruct_type: Video self-destruct type; pass null if none; private chats only, defaults to None
    :type self_destruct_type: :class:`MessageSelfDestructType`, optional
    """

    ID: typing.Literal["inputMessageVideo"] = field(default="inputMessageVideo", metadata={"alias": "@type"})
    video: InputFile
    start_timestamp: Int32
    added_sticker_file_ids: Vector[Int32]
    duration: Int32
    width: Int32
    height: Int32
    supports_streaming: Bool = field(default=False)
    show_caption_above_media: Bool = field(default=False)
    has_spoiler: Bool = field(default=False)
    thumbnail: typing.Optional[InputThumbnail] = field(default=None)
    cover: typing.Optional[InputFile] = field(default=None)
    caption: typing.Optional[FormattedText] = field(default=None)
    self_destruct_type: typing.Optional[MessageSelfDestructType] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputMessageVideoNote(BaseObject):
    """
    A video note message

    :param video_note: Video note to be sent. The video is expected to be encoded to MPEG4 format with H.264 codec and have no data outside of the visible circle
    :type video_note: :class:`InputFile`
    :param duration: Duration of the video, in seconds; 0-60
    :type duration: :class:`Int32`
    :param length: Video width and height; must be positive and not greater than 640
    :type length: :class:`Int32`
    :param thumbnail: Video thumbnail; may be null if empty; pass null to skip thumbnail uploading, defaults to None
    :type thumbnail: :class:`InputThumbnail`, optional
    :param self_destruct_type: Video note self-destruct type; may be null if none; pass null if none; private chats only, defaults to None
    :type self_destruct_type: :class:`MessageSelfDestructType`, optional
    """

    ID: typing.Literal["inputMessageVideoNote"] = field(default="inputMessageVideoNote", metadata={"alias": "@type"})
    video_note: InputFile
    duration: Int32
    length: Int32
    thumbnail: typing.Optional[InputThumbnail] = field(default=None)
    self_destruct_type: typing.Optional[MessageSelfDestructType] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputMessageVoiceNote(BaseObject):
    """
    A voice note message

    :param voice_note: Voice note to be sent. The voice note must be encoded with the Opus codec and stored inside an OGG container with a single audio channel, or be in MP3 or M4A format as regular audio
    :type voice_note: :class:`InputFile`
    :param duration: Duration of the voice note, in seconds
    :type duration: :class:`Int32`
    :param waveform: Waveform representation of the voice note in 5-bit format
    :type waveform: :class:`Bytes`
    :param caption: Voice note caption; may be null if empty; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters, defaults to None
    :type caption: :class:`FormattedText`, optional
    :param self_destruct_type: Voice note self-destruct type; may be null if none; pass null if none; private chats only, defaults to None
    :type self_destruct_type: :class:`MessageSelfDestructType`, optional
    """

    ID: typing.Literal["inputMessageVoiceNote"] = field(default="inputMessageVoiceNote", metadata={"alias": "@type"})
    voice_note: InputFile
    duration: Int32
    waveform: Bytes
    caption: typing.Optional[FormattedText] = field(default=None)
    self_destruct_type: typing.Optional[MessageSelfDestructType] = field(default=None)


InputMessageContent = typing.Union[
    InputMessageAnimation,
    InputMessageAudio,
    InputMessageContact,
    InputMessageDice,
    InputMessageDocument,
    InputMessageForwarded,
    InputMessageGame,
    InputMessageInvoice,
    InputMessageLocation,
    InputMessagePaidMedia,
    InputMessagePhoto,
    InputMessagePoll,
    InputMessageSticker,
    InputMessageStory,
    InputMessageText,
    InputMessageVenue,
    InputMessageVideo,
    InputMessageVideoNote,
    InputMessageVoiceNote,
]


@dataclass(slots=True, kw_only=True)
class InputMessageReplyToExternalMessage(BaseObject):
    """
    Describes a message to be replied that is from a different chat or a forum topic; not supported in secret chats

    :param chat_id: The identifier of the chat to which the message to be replied belongs
    :type chat_id: :class:`Int53`
    :param message_id: The identifier of the message to be replied in the specified chat. A message can be replied in another chat or forum topic only if messageProperties.can_be_replied_in_another_chat
    :type message_id: :class:`Int53`
    :param quote: Quote from the message to be replied; pass null if none, defaults to None
    :type quote: :class:`InputTextQuote`, optional
    """

    ID: typing.Literal["inputMessageReplyToExternalMessage"] = field(
        default="inputMessageReplyToExternalMessage", metadata={"alias": "@type"}
    )
    chat_id: Int53
    message_id: Int53
    quote: typing.Optional[InputTextQuote] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputMessageReplyToMessage(BaseObject):
    """
    Describes a message to be replied in the same chat and forum topic

    :param message_id: The identifier of the message to be replied in the same chat and forum topic. A message can be replied in the same chat and forum topic only if messageProperties.can_be_replied
    :type message_id: :class:`Int53`
    :param quote: Quote from the message to be replied; pass null if none. Must always be null for replies in secret chats, defaults to None
    :type quote: :class:`InputTextQuote`, optional
    """

    ID: typing.Literal["inputMessageReplyToMessage"] = field(
        default="inputMessageReplyToMessage", metadata={"alias": "@type"}
    )
    message_id: Int53
    quote: typing.Optional[InputTextQuote] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputMessageReplyToStory(BaseObject):
    """
    Describes a story to be replied

    :param story_sender_chat_id: The identifier of the sender of the story. Currently, stories can be replied only in the sender's chat and channel stories can't be replied
    :type story_sender_chat_id: :class:`Int53`
    :param story_id: The identifier of the story
    :type story_id: :class:`Int32`
    """

    ID: typing.Literal["inputMessageReplyToStory"] = field(
        default="inputMessageReplyToStory", metadata={"alias": "@type"}
    )
    story_sender_chat_id: Int53
    story_id: Int32


InputMessageReplyTo = typing.Union[
    InputMessageReplyToExternalMessage,
    InputMessageReplyToMessage,
    InputMessageReplyToStory,
]


@dataclass(slots=True, kw_only=True)
class InputPaidMedia(BaseObject):
    """
    Describes a paid media to be sent

    :param type_: Type of the media
    :type type_: :class:`InputPaidMediaType`
    :param media: Photo or video to be sent
    :type media: :class:`InputFile`
    :param added_sticker_file_ids: File identifiers of the stickers added to the media, if applicable
    :type added_sticker_file_ids: :class:`Vector[Int32]`
    :param width: Media width
    :type width: :class:`Int32`
    :param height: Media height
    :type height: :class:`Int32`
    :param thumbnail: Media thumbnail; pass null to skip thumbnail uploading, defaults to None
    :type thumbnail: :class:`InputThumbnail`, optional
    """

    ID: typing.Literal["inputPaidMedia"] = field(default="inputPaidMedia", metadata={"alias": "@type"})
    type_: InputPaidMediaType = field(default=MISSING, metadata={"alias": "type"})
    media: InputFile
    added_sticker_file_ids: Vector[Int32]
    width: Int32
    height: Int32
    thumbnail: typing.Optional[InputThumbnail] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputPaidMediaTypePhoto(BaseObject):
    """
    The media is a photo. The photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height ratio must be at most 20
    """

    ID: typing.Literal["inputPaidMediaTypePhoto"] = field(
        default="inputPaidMediaTypePhoto", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InputPaidMediaTypeVideo(BaseObject):
    """
    The media is a video

    :param start_timestamp: Timestamp from which the video playing must start, in seconds
    :type start_timestamp: :class:`Int32`
    :param duration: Duration of the video, in seconds
    :type duration: :class:`Int32`
    :param supports_streaming: True, if the video is expected to be streamed
    :type supports_streaming: :class:`Bool`
    :param cover: Cover of the video; pass null to skip cover uploading, defaults to None
    :type cover: :class:`InputFile`, optional
    """

    ID: typing.Literal["inputPaidMediaTypeVideo"] = field(
        default="inputPaidMediaTypeVideo", metadata={"alias": "@type"}
    )
    start_timestamp: Int32
    duration: Int32
    supports_streaming: Bool = field(default=False)
    cover: typing.Optional[InputFile] = field(default=None)


InputPaidMediaType = typing.Union[
    InputPaidMediaTypePhoto,
    InputPaidMediaTypeVideo,
]


@dataclass(slots=True, kw_only=True)
class InputPassportElementAddress(BaseObject):
    """
    A Telegram Passport element to be saved containing the user's address

    :param address: The address to be saved
    :type address: :class:`Address`
    """

    ID: typing.Literal["inputPassportElementAddress"] = field(
        default="inputPassportElementAddress", metadata={"alias": "@type"}
    )
    address: Address


@dataclass(slots=True, kw_only=True)
class InputPassportElementBankStatement(BaseObject):
    """
    A Telegram Passport element to be saved containing the user's bank statement

    :param bank_statement: The bank statement to be saved
    :type bank_statement: :class:`InputPersonalDocument`
    """

    ID: typing.Literal["inputPassportElementBankStatement"] = field(
        default="inputPassportElementBankStatement", metadata={"alias": "@type"}
    )
    bank_statement: InputPersonalDocument


@dataclass(slots=True, kw_only=True)
class InputPassportElementDriverLicense(BaseObject):
    """
    A Telegram Passport element to be saved containing the user's driver license

    :param driver_license: The driver license to be saved
    :type driver_license: :class:`InputIdentityDocument`
    """

    ID: typing.Literal["inputPassportElementDriverLicense"] = field(
        default="inputPassportElementDriverLicense", metadata={"alias": "@type"}
    )
    driver_license: InputIdentityDocument


@dataclass(slots=True, kw_only=True)
class InputPassportElementEmailAddress(BaseObject):
    """
    A Telegram Passport element to be saved containing the user's email address

    :param email_address: The email address to be saved
    :type email_address: :class:`String`
    """

    ID: typing.Literal["inputPassportElementEmailAddress"] = field(
        default="inputPassportElementEmailAddress", metadata={"alias": "@type"}
    )
    email_address: String


@dataclass(slots=True, kw_only=True)
class InputPassportElementIdentityCard(BaseObject):
    """
    A Telegram Passport element to be saved containing the user's identity card

    :param identity_card: The identity card to be saved
    :type identity_card: :class:`InputIdentityDocument`
    """

    ID: typing.Literal["inputPassportElementIdentityCard"] = field(
        default="inputPassportElementIdentityCard", metadata={"alias": "@type"}
    )
    identity_card: InputIdentityDocument


@dataclass(slots=True, kw_only=True)
class InputPassportElementInternalPassport(BaseObject):
    """
    A Telegram Passport element to be saved containing the user's internal passport

    :param internal_passport: The internal passport to be saved
    :type internal_passport: :class:`InputIdentityDocument`
    """

    ID: typing.Literal["inputPassportElementInternalPassport"] = field(
        default="inputPassportElementInternalPassport", metadata={"alias": "@type"}
    )
    internal_passport: InputIdentityDocument


@dataclass(slots=True, kw_only=True)
class InputPassportElementPassport(BaseObject):
    """
    A Telegram Passport element to be saved containing the user's passport

    :param passport: The passport to be saved
    :type passport: :class:`InputIdentityDocument`
    """

    ID: typing.Literal["inputPassportElementPassport"] = field(
        default="inputPassportElementPassport", metadata={"alias": "@type"}
    )
    passport: InputIdentityDocument


@dataclass(slots=True, kw_only=True)
class InputPassportElementPassportRegistration(BaseObject):
    """
    A Telegram Passport element to be saved containing the user's passport registration

    :param passport_registration: The passport registration page to be saved
    :type passport_registration: :class:`InputPersonalDocument`
    """

    ID: typing.Literal["inputPassportElementPassportRegistration"] = field(
        default="inputPassportElementPassportRegistration", metadata={"alias": "@type"}
    )
    passport_registration: InputPersonalDocument


@dataclass(slots=True, kw_only=True)
class InputPassportElementPersonalDetails(BaseObject):
    """
    A Telegram Passport element to be saved containing the user's personal details

    :param personal_details: Personal details of the user
    :type personal_details: :class:`PersonalDetails`
    """

    ID: typing.Literal["inputPassportElementPersonalDetails"] = field(
        default="inputPassportElementPersonalDetails", metadata={"alias": "@type"}
    )
    personal_details: PersonalDetails


@dataclass(slots=True, kw_only=True)
class InputPassportElementPhoneNumber(BaseObject):
    """
    A Telegram Passport element to be saved containing the user's phone number

    :param phone_number: The phone number to be saved
    :type phone_number: :class:`String`
    """

    ID: typing.Literal["inputPassportElementPhoneNumber"] = field(
        default="inputPassportElementPhoneNumber", metadata={"alias": "@type"}
    )
    phone_number: String


@dataclass(slots=True, kw_only=True)
class InputPassportElementRentalAgreement(BaseObject):
    """
    A Telegram Passport element to be saved containing the user's rental agreement

    :param rental_agreement: The rental agreement to be saved
    :type rental_agreement: :class:`InputPersonalDocument`
    """

    ID: typing.Literal["inputPassportElementRentalAgreement"] = field(
        default="inputPassportElementRentalAgreement", metadata={"alias": "@type"}
    )
    rental_agreement: InputPersonalDocument


@dataclass(slots=True, kw_only=True)
class InputPassportElementTemporaryRegistration(BaseObject):
    """
    A Telegram Passport element to be saved containing the user's temporary registration

    :param temporary_registration: The temporary registration document to be saved
    :type temporary_registration: :class:`InputPersonalDocument`
    """

    ID: typing.Literal["inputPassportElementTemporaryRegistration"] = field(
        default="inputPassportElementTemporaryRegistration", metadata={"alias": "@type"}
    )
    temporary_registration: InputPersonalDocument


@dataclass(slots=True, kw_only=True)
class InputPassportElementUtilityBill(BaseObject):
    """
    A Telegram Passport element to be saved containing the user's utility bill

    :param utility_bill: The utility bill to be saved
    :type utility_bill: :class:`InputPersonalDocument`
    """

    ID: typing.Literal["inputPassportElementUtilityBill"] = field(
        default="inputPassportElementUtilityBill", metadata={"alias": "@type"}
    )
    utility_bill: InputPersonalDocument


InputPassportElement = typing.Union[
    InputPassportElementAddress,
    InputPassportElementBankStatement,
    InputPassportElementDriverLicense,
    InputPassportElementEmailAddress,
    InputPassportElementIdentityCard,
    InputPassportElementInternalPassport,
    InputPassportElementPassport,
    InputPassportElementPassportRegistration,
    InputPassportElementPersonalDetails,
    InputPassportElementPhoneNumber,
    InputPassportElementRentalAgreement,
    InputPassportElementTemporaryRegistration,
    InputPassportElementUtilityBill,
]


@dataclass(slots=True, kw_only=True)
class InputPassportElementError(BaseObject):
    """
    Contains the description of an error in a Telegram Passport element; for bots only

    :param type_: Type of Telegram Passport element that has the error
    :type type_: :class:`PassportElementType`
    :param message: Error message
    :type message: :class:`String`
    :param source: Error source
    :type source: :class:`InputPassportElementErrorSource`
    """

    ID: typing.Literal["inputPassportElementError"] = field(
        default="inputPassportElementError", metadata={"alias": "@type"}
    )
    type_: PassportElementType = field(default=MISSING, metadata={"alias": "type"})
    message: String
    source: InputPassportElementErrorSource


@dataclass(slots=True, kw_only=True)
class InputPassportElementErrorSourceDataField(BaseObject):
    """
    A data field contains an error. The error is considered resolved when the field's value changes

    :param field_name: Field name
    :type field_name: :class:`String`
    :param data_hash: Current data hash
    :type data_hash: :class:`Bytes`
    """

    ID: typing.Literal["inputPassportElementErrorSourceDataField"] = field(
        default="inputPassportElementErrorSourceDataField", metadata={"alias": "@type"}
    )
    field_name: String
    data_hash: Bytes


@dataclass(slots=True, kw_only=True)
class InputPassportElementErrorSourceFile(BaseObject):
    """
    The file contains an error. The error is considered resolved when the file changes

    :param file_hash: Current hash of the file which has the error
    :type file_hash: :class:`Bytes`
    """

    ID: typing.Literal["inputPassportElementErrorSourceFile"] = field(
        default="inputPassportElementErrorSourceFile", metadata={"alias": "@type"}
    )
    file_hash: Bytes


@dataclass(slots=True, kw_only=True)
class InputPassportElementErrorSourceFiles(BaseObject):
    """
    The list of attached files contains an error. The error is considered resolved when the file list changes

    :param file_hashes: Current hashes of all attached files
    :type file_hashes: :class:`Vector[Bytes]`
    """

    ID: typing.Literal["inputPassportElementErrorSourceFiles"] = field(
        default="inputPassportElementErrorSourceFiles", metadata={"alias": "@type"}
    )
    file_hashes: Vector[Bytes]


@dataclass(slots=True, kw_only=True)
class InputPassportElementErrorSourceFrontSide(BaseObject):
    """
    The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes

    :param file_hash: Current hash of the file containing the front side
    :type file_hash: :class:`Bytes`
    """

    ID: typing.Literal["inputPassportElementErrorSourceFrontSide"] = field(
        default="inputPassportElementErrorSourceFrontSide", metadata={"alias": "@type"}
    )
    file_hash: Bytes


@dataclass(slots=True, kw_only=True)
class InputPassportElementErrorSourceReverseSide(BaseObject):
    """
    The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes

    :param file_hash: Current hash of the file containing the reverse side
    :type file_hash: :class:`Bytes`
    """

    ID: typing.Literal["inputPassportElementErrorSourceReverseSide"] = field(
        default="inputPassportElementErrorSourceReverseSide", metadata={"alias": "@type"}
    )
    file_hash: Bytes


@dataclass(slots=True, kw_only=True)
class InputPassportElementErrorSourceSelfie(BaseObject):
    """
    The selfie contains an error. The error is considered resolved when the file with the selfie changes

    :param file_hash: Current hash of the file containing the selfie
    :type file_hash: :class:`Bytes`
    """

    ID: typing.Literal["inputPassportElementErrorSourceSelfie"] = field(
        default="inputPassportElementErrorSourceSelfie", metadata={"alias": "@type"}
    )
    file_hash: Bytes


@dataclass(slots=True, kw_only=True)
class InputPassportElementErrorSourceTranslationFile(BaseObject):
    """
    One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes

    :param file_hash: Current hash of the file containing the translation
    :type file_hash: :class:`Bytes`
    """

    ID: typing.Literal["inputPassportElementErrorSourceTranslationFile"] = field(
        default="inputPassportElementErrorSourceTranslationFile", metadata={"alias": "@type"}
    )
    file_hash: Bytes


@dataclass(slots=True, kw_only=True)
class InputPassportElementErrorSourceTranslationFiles(BaseObject):
    """
    The translation of the document contains an error. The error is considered resolved when the list of files changes

    :param file_hashes: Current hashes of all files with the translation
    :type file_hashes: :class:`Vector[Bytes]`
    """

    ID: typing.Literal["inputPassportElementErrorSourceTranslationFiles"] = field(
        default="inputPassportElementErrorSourceTranslationFiles", metadata={"alias": "@type"}
    )
    file_hashes: Vector[Bytes]


@dataclass(slots=True, kw_only=True)
class InputPassportElementErrorSourceUnspecified(BaseObject):
    """
    The element contains an error in an unspecified place. The error will be considered resolved when new data is added

    :param element_hash: Current hash of the entire element
    :type element_hash: :class:`Bytes`
    """

    ID: typing.Literal["inputPassportElementErrorSourceUnspecified"] = field(
        default="inputPassportElementErrorSourceUnspecified", metadata={"alias": "@type"}
    )
    element_hash: Bytes


InputPassportElementErrorSource = typing.Union[
    InputPassportElementErrorSourceDataField,
    InputPassportElementErrorSourceFile,
    InputPassportElementErrorSourceFiles,
    InputPassportElementErrorSourceFrontSide,
    InputPassportElementErrorSourceReverseSide,
    InputPassportElementErrorSourceSelfie,
    InputPassportElementErrorSourceTranslationFile,
    InputPassportElementErrorSourceTranslationFiles,
    InputPassportElementErrorSourceUnspecified,
]


@dataclass(slots=True, kw_only=True)
class InputPersonalDocument(BaseObject):
    """
    A personal document to be saved to Telegram Passport

    :param files: List of files containing the pages of the document
    :type files: :class:`Vector[InputFile]`
    :param translation: List of files containing a certified English translation of the document
    :type translation: :class:`Vector[InputFile]`
    """

    ID: typing.Literal["inputPersonalDocument"] = field(default="inputPersonalDocument", metadata={"alias": "@type"})
    files: Vector[InputFile]
    translation: Vector[InputFile]


@dataclass(slots=True, kw_only=True)
class InputSticker(BaseObject):
    """
    A sticker to be added to a sticker set

    :param sticker: File with the sticker; must fit in a 512x512 square. For WEBP stickers the file must be in WEBP or PNG format, which will be converted to WEBP server-side. See https://core.telegram.org/animated_stickers#technical-requirements for technical requirements
    :type sticker: :class:`InputFile`
    :param format_: Format of the sticker
    :type format_: :class:`StickerFormat`
    :param emojis: String with 1-20 emoji corresponding to the sticker
    :type emojis: :class:`String`
    :param keywords: List of up to 20 keywords with total length up to 64 characters, which can be used to find the sticker
    :type keywords: :class:`Vector[String]`
    :param mask_position: Position where the mask is placed; pass null if not specified, defaults to None
    :type mask_position: :class:`MaskPosition`, optional
    """

    ID: typing.Literal["inputSticker"] = field(default="inputSticker", metadata={"alias": "@type"})
    sticker: InputFile
    format_: StickerFormat = field(default=MISSING, metadata={"alias": "format"})
    emojis: String
    keywords: Vector[String]
    mask_position: typing.Optional[MaskPosition] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputStoryArea(BaseObject):
    """
    Describes a clickable rectangle area on a story media to be added

    :param position: Position of the area
    :type position: :class:`StoryAreaPosition`
    :param type_: Type of the area
    :type type_: :class:`InputStoryAreaType`
    """

    ID: typing.Literal["inputStoryArea"] = field(default="inputStoryArea", metadata={"alias": "@type"})
    position: StoryAreaPosition
    type_: InputStoryAreaType = field(default=MISSING, metadata={"alias": "type"})


@dataclass(slots=True, kw_only=True)
class InputStoryAreaTypeFoundVenue(BaseObject):
    """
    An area pointing to a venue found by the bot getOption("venue_search_bot_username")

    :param query_id: Identifier of the inline query, used to found the venue
    :type query_id: :class:`Int64`
    :param result_id: Identifier of the inline query result
    :type result_id: :class:`String`
    """

    ID: typing.Literal["inputStoryAreaTypeFoundVenue"] = field(
        default="inputStoryAreaTypeFoundVenue", metadata={"alias": "@type"}
    )
    query_id: Int64
    result_id: String


@dataclass(slots=True, kw_only=True)
class InputStoryAreaTypeLink(BaseObject):
    """
    An area pointing to a HTTP or tg:// link

    :param url: HTTP or tg:// URL to be opened when the area is clicked
    :type url: :class:`String`
    """

    ID: typing.Literal["inputStoryAreaTypeLink"] = field(default="inputStoryAreaTypeLink", metadata={"alias": "@type"})
    url: String


@dataclass(slots=True, kw_only=True)
class InputStoryAreaTypeLocation(BaseObject):
    """
    An area pointing to a location

    :param location: The location
    :type location: :class:`Location`
    :param address: Address of the location; pass null if unknown, defaults to None
    :type address: :class:`LocationAddress`, optional
    """

    ID: typing.Literal["inputStoryAreaTypeLocation"] = field(
        default="inputStoryAreaTypeLocation", metadata={"alias": "@type"}
    )
    location: Location
    address: typing.Optional[LocationAddress] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InputStoryAreaTypeMessage(BaseObject):
    """
    An area pointing to a message

    :param chat_id: Identifier of the chat with the message. Currently, the chat must be a supergroup or a channel chat
    :type chat_id: :class:`Int53`
    :param message_id: Identifier of the message. Use messageProperties.can_be_shared_in_story to check whether the message is suitable
    :type message_id: :class:`Int53`
    """

    ID: typing.Literal["inputStoryAreaTypeMessage"] = field(
        default="inputStoryAreaTypeMessage", metadata={"alias": "@type"}
    )
    chat_id: Int53
    message_id: Int53


@dataclass(slots=True, kw_only=True)
class InputStoryAreaTypePreviousVenue(BaseObject):
    """
    An area pointing to a venue already added to the story

    :param venue_provider: Provider of the venue
    :type venue_provider: :class:`String`
    :param venue_id: Identifier of the venue in the provider database
    :type venue_id: :class:`String`
    """

    ID: typing.Literal["inputStoryAreaTypePreviousVenue"] = field(
        default="inputStoryAreaTypePreviousVenue", metadata={"alias": "@type"}
    )
    venue_provider: String
    venue_id: String


@dataclass(slots=True, kw_only=True)
class InputStoryAreaTypeSuggestedReaction(BaseObject):
    """
    An area pointing to a suggested reaction

    :param reaction_type: Type of the reaction
    :type reaction_type: :class:`ReactionType`
    :param is_dark: True, if reaction has a dark background
    :type is_dark: :class:`Bool`
    :param is_flipped: True, if reaction corner is flipped
    :type is_flipped: :class:`Bool`
    """

    ID: typing.Literal["inputStoryAreaTypeSuggestedReaction"] = field(
        default="inputStoryAreaTypeSuggestedReaction", metadata={"alias": "@type"}
    )
    reaction_type: ReactionType
    is_dark: Bool = field(default=False)
    is_flipped: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class InputStoryAreaTypeUpgradedGift(BaseObject):
    """
    An area with an upgraded gift

    :param gift_name: Unique name of the upgraded gift
    :type gift_name: :class:`String`
    """

    ID: typing.Literal["inputStoryAreaTypeUpgradedGift"] = field(
        default="inputStoryAreaTypeUpgradedGift", metadata={"alias": "@type"}
    )
    gift_name: String


@dataclass(slots=True, kw_only=True)
class InputStoryAreaTypeWeather(BaseObject):
    """
    An area with information about weather

    :param temperature: Temperature, in degree Celsius
    :type temperature: :class:`Double`
    :param emoji: Emoji representing the weather
    :type emoji: :class:`String`
    :param background_color: A color of the area background in the ARGB format
    :type background_color: :class:`Int32`
    """

    ID: typing.Literal["inputStoryAreaTypeWeather"] = field(
        default="inputStoryAreaTypeWeather", metadata={"alias": "@type"}
    )
    temperature: Double
    emoji: String
    background_color: Int32


InputStoryAreaType = typing.Union[
    InputStoryAreaTypeFoundVenue,
    InputStoryAreaTypeLink,
    InputStoryAreaTypeLocation,
    InputStoryAreaTypeMessage,
    InputStoryAreaTypePreviousVenue,
    InputStoryAreaTypeSuggestedReaction,
    InputStoryAreaTypeUpgradedGift,
    InputStoryAreaTypeWeather,
]


@dataclass(slots=True, kw_only=True)
class InputStoryAreas(BaseObject):
    """
    Contains a list of story areas to be added

    :param areas: List of input story areas. Currently, a story can have up to 10 inputStoryAreaTypeLocation, inputStoryAreaTypeFoundVenue, and inputStoryAreaTypePreviousVenue areas, up to getOption("story_suggested_reaction_area_count_max") inputStoryAreaTypeSuggestedReaction areas, up to 1 inputStoryAreaTypeMessage area, up to getOption("story_link_area_count_max") inputStoryAreaTypeLink areas if the current user is a Telegram Premium user, up to 3 inputStoryAreaTypeWeather areas, and up to 1 inputStoryAreaTypeUpgradedGift area
    :type areas: :class:`Vector[InputStoryArea]`
    """

    ID: typing.Literal["inputStoryAreas"] = field(default="inputStoryAreas", metadata={"alias": "@type"})
    areas: Vector[InputStoryArea]


@dataclass(slots=True, kw_only=True)
class InputStoryContentPhoto(BaseObject):
    """
    A photo story

    :param photo: Photo to send. The photo must be at most 10 MB in size. The photo size must be 1080x1920
    :type photo: :class:`InputFile`
    :param added_sticker_file_ids: File identifiers of the stickers added to the photo, if applicable
    :type added_sticker_file_ids: :class:`Vector[Int32]`
    """

    ID: typing.Literal["inputStoryContentPhoto"] = field(default="inputStoryContentPhoto", metadata={"alias": "@type"})
    photo: InputFile
    added_sticker_file_ids: Vector[Int32]


@dataclass(slots=True, kw_only=True)
class InputStoryContentVideo(BaseObject):
    """
    A video story

    :param video: Video to be sent. The video size must be 720x1280. The video must be streamable and stored in MPEG4 format, after encoding with H.265 codec and key frames added each second
    :type video: :class:`InputFile`
    :param added_sticker_file_ids: File identifiers of the stickers added to the video, if applicable
    :type added_sticker_file_ids: :class:`Vector[Int32]`
    :param duration: Precise duration of the video, in seconds; 0-60
    :type duration: :class:`Double`
    :param cover_frame_timestamp: Timestamp of the frame, which will be used as video thumbnail
    :type cover_frame_timestamp: :class:`Double`
    :param is_animation: True, if the video has no sound
    :type is_animation: :class:`Bool`
    """

    ID: typing.Literal["inputStoryContentVideo"] = field(default="inputStoryContentVideo", metadata={"alias": "@type"})
    video: InputFile
    added_sticker_file_ids: Vector[Int32]
    duration: Double
    cover_frame_timestamp: Double
    is_animation: Bool = field(default=False)


InputStoryContent = typing.Union[
    InputStoryContentPhoto,
    InputStoryContentVideo,
]


@dataclass(slots=True, kw_only=True)
class InputTextQuote(BaseObject):
    """
    Describes manually chosen quote from another message

    :param text: Text of the quote; 0-getOption("message_reply_quote_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed to be kept and must be kept in the quote
    :type text: :class:`FormattedText`
    :param position: Quote position in the original message in UTF-16 code units
    :type position: :class:`Int32`
    """

    ID: typing.Literal["inputTextQuote"] = field(default="inputTextQuote", metadata={"alias": "@type"})
    text: FormattedText
    position: Int32


@dataclass(slots=True, kw_only=True)
class InputThumbnail(BaseObject):
    """
    A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers, and less than 200 KB in size

    :param thumbnail: Thumbnail file to send. Sending thumbnails by file_id is currently not supported
    :type thumbnail: :class:`InputFile`
    :param width: Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown
    :type width: :class:`Int32`
    :param height: Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown
    :type height: :class:`Int32`
    """

    ID: typing.Literal["inputThumbnail"] = field(default="inputThumbnail", metadata={"alias": "@type"})
    thumbnail: InputFile
    width: Int32 = field(default=0)
    height: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeActiveSessions(BaseObject):
    """
    The link is a link to the Devices section of the application. Use getActiveSessions to get the list of active sessions and show them to the user
    """

    ID: typing.Literal["internalLinkTypeActiveSessions"] = field(
        default="internalLinkTypeActiveSessions", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeAttachmentMenuBot(BaseObject):
    """
    The link is a link to an attachment menu bot to be opened in the specified or a chosen chat. Process given target_chat to open the chat. Then, call searchPublicChat with the given bot username, check that the user is a bot and can be added to attachment menu. Then, use getAttachmentMenuBot to receive information about the bot. If the bot isn't added to attachment menu, then show a disclaimer about Mini Apps being third-party applications, ask the user to accept their Terms of service and confirm adding the bot to side and attachment menu. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add the bot. If the attachment menu bot can't be used in the opened chat, show an error to the user. If the bot is added to attachment menu and can be used in the chat, then use openWebApp with the given URL

    :param target_chat: Target chat to be opened
    :type target_chat: :class:`TargetChat`
    :param bot_username: Username of the bot
    :type bot_username: :class:`String`
    :param url: URL to be passed to openWebApp
    :type url: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeAttachmentMenuBot"] = field(
        default="internalLinkTypeAttachmentMenuBot", metadata={"alias": "@type"}
    )
    target_chat: TargetChat
    bot_username: String
    url: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeAuthenticationCode(BaseObject):
    """
    The link contains an authentication code. Call checkAuthenticationCode with the code if the current authorization state is authorizationStateWaitCode

    :param code: The authentication code
    :type code: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeAuthenticationCode"] = field(
        default="internalLinkTypeAuthenticationCode", metadata={"alias": "@type"}
    )
    code: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeBackground(BaseObject):
    """
    The link is a link to a background. Call searchBackground with the given background name to process the link. If background is found and the user wants to apply it, then call setDefaultBackground

    :param background_name: Name of the background
    :type background_name: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeBackground"] = field(
        default="internalLinkTypeBackground", metadata={"alias": "@type"}
    )
    background_name: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeBotAddToChannel(BaseObject):
    """
    The link is a link to a Telegram bot, which is expected to be added to a channel chat as an administrator. Call searchPublicChat with the given bot username and check that the user is a bot, ask the current user to select a channel chat to add the bot to as an administrator. Then, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator, check that the current user can edit its administrator rights and combine received rights with the requested administrator rights. Then, show confirmation box to the user, and call setChatMemberStatus with the chosen chat and confirmed rights

    :param bot_username: Username of the bot
    :type bot_username: :class:`String`
    :param administrator_rights: Expected administrator rights for the bot
    :type administrator_rights: :class:`ChatAdministratorRights`
    """

    ID: typing.Literal["internalLinkTypeBotAddToChannel"] = field(
        default="internalLinkTypeBotAddToChannel", metadata={"alias": "@type"}
    )
    bot_username: String
    administrator_rights: ChatAdministratorRights


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeBotStart(BaseObject):
    """
    The link is a link to a chat with a Telegram bot. Call searchPublicChat with the given bot username, check that the user is a bot, show START button in the chat with the bot, and then call sendBotStartMessage with the given start parameter after the button is pressed

    :param bot_username: Username of the bot
    :type bot_username: :class:`String`
    :param start_parameter: The parameter to be passed to sendBotStartMessage
    :type start_parameter: :class:`String`
    :param autostart: True, if sendBotStartMessage must be called automatically without showing the START button
    :type autostart: :class:`Bool`
    """

    ID: typing.Literal["internalLinkTypeBotStart"] = field(
        default="internalLinkTypeBotStart", metadata={"alias": "@type"}
    )
    bot_username: String
    start_parameter: String
    autostart: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeBotStartInGroup(BaseObject):
    """
    The link is a link to a Telegram bot, which is expected to be added to a group chat. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to groups, ask the current user to select a basic group or a supergroup chat to add the bot to, taking into account that bots can be added to a public supergroup only by administrators of the supergroup. If administrator rights are provided by the link, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator, check that the current user can edit its administrator rights, combine received rights with the requested administrator rights, show confirmation box to the user, and call setChatMemberStatus with the chosen chat and confirmed administrator rights. Before call to setChatMemberStatus it may be required to upgrade the chosen basic group chat to a supergroup chat. Then, if start_parameter isn't empty, call sendBotStartMessage with the given start parameter and the chosen chat; otherwise, just send /start message with bot's username added to the chat

    :param bot_username: Username of the bot
    :type bot_username: :class:`String`
    :param start_parameter: The parameter to be passed to sendBotStartMessage
    :type start_parameter: :class:`String`
    :param administrator_rights: Expected administrator rights for the bot; may be null, defaults to None
    :type administrator_rights: :class:`ChatAdministratorRights`, optional
    """

    ID: typing.Literal["internalLinkTypeBotStartInGroup"] = field(
        default="internalLinkTypeBotStartInGroup", metadata={"alias": "@type"}
    )
    bot_username: String
    start_parameter: String
    administrator_rights: typing.Optional[ChatAdministratorRights] = field(default=None)


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeBusinessChat(BaseObject):
    """
    The link is a link to a business chat. Use getBusinessChatLinkInfo with the provided link name to get information about the link, then open received private chat and replace chat draft with the provided text

    :param link_name: Name of the link
    :type link_name: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeBusinessChat"] = field(
        default="internalLinkTypeBusinessChat", metadata={"alias": "@type"}
    )
    link_name: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeBuyStars(BaseObject):
    """
    The link is a link to the Telegram Star purchase section of the application

    :param star_count: The number of Telegram Stars that must be owned by the user
    :type star_count: :class:`Int53`
    :param purpose: Purpose of Telegram Star purchase. Arbitrary string specified by the server, for example, "subs" if the Telegram Stars are required to extend channel subscriptions
    :type purpose: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeBuyStars"] = field(
        default="internalLinkTypeBuyStars", metadata={"alias": "@type"}
    )
    star_count: Int53
    purpose: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeChangePhoneNumber(BaseObject):
    """
    The link is a link to the change phone number section of the application
    """

    ID: typing.Literal["internalLinkTypeChangePhoneNumber"] = field(
        default="internalLinkTypeChangePhoneNumber", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeChatAffiliateProgram(BaseObject):
    """
    The link is an affiliate program link. Call searchChatAffiliateProgram with the given username and referrer to process the link

    :param username: Username to be passed to searchChatAffiliateProgram
    :type username: :class:`String`
    :param referrer: Referrer to be passed to searchChatAffiliateProgram
    :type referrer: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeChatAffiliateProgram"] = field(
        default="internalLinkTypeChatAffiliateProgram", metadata={"alias": "@type"}
    )
    username: String
    referrer: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeChatBoost(BaseObject):
    """
    The link is a link to boost a Telegram chat. Call getChatBoostLinkInfo with the given URL to process the link. If the chat is found, then call getChatBoostStatus and getAvailableChatBoostSlots to get the current boost status and check whether the chat can be boosted. If the user wants to boost the chat and the chat can be boosted, then call boostChat

    :param url: URL to be passed to getChatBoostLinkInfo
    :type url: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeChatBoost"] = field(
        default="internalLinkTypeChatBoost", metadata={"alias": "@type"}
    )
    url: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeChatFolderInvite(BaseObject):
    """
    The link is an invite link to a chat folder. Call checkChatFolderInviteLink with the given invite link to process the link. If the link is valid and the user wants to join the chat folder, then call addChatFolderByInviteLink

    :param invite_link: Internal representation of the invite link
    :type invite_link: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeChatFolderInvite"] = field(
        default="internalLinkTypeChatFolderInvite", metadata={"alias": "@type"}
    )
    invite_link: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeChatFolderSettings(BaseObject):
    """
    The link is a link to the folder section of the application settings
    """

    ID: typing.Literal["internalLinkTypeChatFolderSettings"] = field(
        default="internalLinkTypeChatFolderSettings", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeChatInvite(BaseObject):
    """
    The link is a chat invite link. Call checkChatInviteLink with the given invite link to process the link. If the link is valid and the user wants to join the chat, then call joinChatByInviteLink

    :param invite_link: Internal representation of the invite link
    :type invite_link: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeChatInvite"] = field(
        default="internalLinkTypeChatInvite", metadata={"alias": "@type"}
    )
    invite_link: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeDefaultMessageAutoDeleteTimerSettings(BaseObject):
    """
    The link is a link to the default message auto-delete timer settings section of the application settings
    """

    ID: typing.Literal["internalLinkTypeDefaultMessageAutoDeleteTimerSettings"] = field(
        default="internalLinkTypeDefaultMessageAutoDeleteTimerSettings", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeEditProfileSettings(BaseObject):
    """
    The link is a link to the edit profile section of the application settings
    """

    ID: typing.Literal["internalLinkTypeEditProfileSettings"] = field(
        default="internalLinkTypeEditProfileSettings", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeGame(BaseObject):
    """
    The link is a link to a game. Call searchPublicChat with the given bot username, check that the user is a bot, ask the current user to select a chat to send the game, and then call sendMessage with inputMessageGame

    :param bot_username: Username of the bot that owns the game
    :type bot_username: :class:`String`
    :param game_short_name: Short name of the game
    :type game_short_name: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeGame"] = field(default="internalLinkTypeGame", metadata={"alias": "@type"})
    bot_username: String
    game_short_name: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeInstantView(BaseObject):
    """
    The link must be opened in an Instant View. Call getWebPageInstantView with the given URL to process the link. If Instant View is found, then show it, otherwise, open the fallback URL in an external browser

    :param url: URL to be passed to getWebPageInstantView
    :type url: :class:`String`
    :param fallback_url: An URL to open if getWebPageInstantView fails
    :type fallback_url: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeInstantView"] = field(
        default="internalLinkTypeInstantView", metadata={"alias": "@type"}
    )
    url: String
    fallback_url: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeInvoice(BaseObject):
    """
    The link is a link to an invoice. Call getPaymentForm with the given invoice name to process the link

    :param invoice_name: Name of the invoice
    :type invoice_name: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeInvoice"] = field(
        default="internalLinkTypeInvoice", metadata={"alias": "@type"}
    )
    invoice_name: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeLanguagePack(BaseObject):
    """
    The link is a link to a language pack. Call getLanguagePackInfo with the given language pack identifier to process the link. If the language pack is found and the user wants to apply it, then call setOption for the option "language_pack_id"

    :param language_pack_id: Language pack identifier
    :type language_pack_id: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeLanguagePack"] = field(
        default="internalLinkTypeLanguagePack", metadata={"alias": "@type"}
    )
    language_pack_id: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeLanguageSettings(BaseObject):
    """
    The link is a link to the language section of the application settings
    """

    ID: typing.Literal["internalLinkTypeLanguageSettings"] = field(
        default="internalLinkTypeLanguageSettings", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeMainWebApp(BaseObject):
    """
    The link is a link to the main Web App of a bot. Call searchPublicChat with the given bot username, check that the user is a bot and has the main Web App. If the bot can be added to attachment menu, then use getAttachmentMenuBot to receive information about the bot, then if the bot isn't added to side menu, show a disclaimer about Mini Apps being third-party applications, ask the user to accept their Terms of service and confirm adding the bot to side and attachment menu, then if the user accepts the terms and confirms adding, use toggleBotIsAddedToAttachmentMenu to add the bot. Then, use getMainWebApp with the given start parameter and mode and open the returned URL as a Web App

    :param bot_username: Username of the bot
    :type bot_username: :class:`String`
    :param start_parameter: Start parameter to be passed to getMainWebApp
    :type start_parameter: :class:`String`
    :param mode: The mode to be passed to getMainWebApp
    :type mode: :class:`WebAppOpenMode`
    """

    ID: typing.Literal["internalLinkTypeMainWebApp"] = field(
        default="internalLinkTypeMainWebApp", metadata={"alias": "@type"}
    )
    bot_username: String
    start_parameter: String
    mode: WebAppOpenMode


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeMessage(BaseObject):
    """
    The link is a link to a Telegram message or a forum topic. Call getMessageLinkInfo with the given URL to process the link, and then open received forum topic or chat and show the message there

    :param url: URL to be passed to getMessageLinkInfo
    :type url: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeMessage"] = field(
        default="internalLinkTypeMessage", metadata={"alias": "@type"}
    )
    url: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeMessageDraft(BaseObject):
    """
    The link contains a message draft text. A share screen needs to be shown to the user, then the chosen chat must be opened and the text is added to the input field

    :param text: Message draft text
    :type text: :class:`FormattedText`
    :param contains_link: True, if the first line of the text contains a link. If true, the input field needs to be focused and the text after the link must be selected
    :type contains_link: :class:`Bool`
    """

    ID: typing.Literal["internalLinkTypeMessageDraft"] = field(
        default="internalLinkTypeMessageDraft", metadata={"alias": "@type"}
    )
    text: FormattedText
    contains_link: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class InternalLinkTypePassportDataRequest(BaseObject):
    """
    The link contains a request of Telegram passport data. Call getPassportAuthorizationForm with the given parameters to process the link if the link was received from outside of the application; otherwise, ignore it

    :param bot_user_id: User identifier of the service's bot; the corresponding user may be unknown yet
    :type bot_user_id: :class:`Int53`
    :param scope: Telegram Passport element types requested by the service
    :type scope: :class:`String`
    :param public_key: Service's public key
    :type public_key: :class:`String`
    :param nonce: Unique request identifier provided by the service
    :type nonce: :class:`String`
    :param callback_url: An HTTP URL to open once the request is finished, canceled, or failed with the parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=... respectively. If empty, then onActivityResult method must be used to return response on Android, or the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel must be opened otherwise
    :type callback_url: :class:`String`
    """

    ID: typing.Literal["internalLinkTypePassportDataRequest"] = field(
        default="internalLinkTypePassportDataRequest", metadata={"alias": "@type"}
    )
    bot_user_id: Int53
    scope: String
    public_key: String
    nonce: String
    callback_url: String = field(default="")


@dataclass(slots=True, kw_only=True)
class InternalLinkTypePhoneNumberConfirmation(BaseObject):
    """
    The link can be used to confirm ownership of a phone number to prevent account deletion. Call sendPhoneNumberCode with the given phone number and with phoneNumberCodeTypeConfirmOwnership with the given hash to process the link. If succeeded, call checkPhoneNumberCode to check entered by the user code, or resendPhoneNumberCode to resend it

    :param hash_: Hash value from the link
    :type hash_: :class:`String`
    :param phone_number: Phone number value from the link
    :type phone_number: :class:`String`
    """

    ID: typing.Literal["internalLinkTypePhoneNumberConfirmation"] = field(
        default="internalLinkTypePhoneNumberConfirmation", metadata={"alias": "@type"}
    )
    hash_: String = field(default=MISSING, metadata={"alias": "hash"})
    phone_number: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypePremiumFeatures(BaseObject):
    """
    The link is a link to the Premium features screen of the application from which the user can subscribe to Telegram Premium. Call getPremiumFeatures with the given referrer to process the link

    :param referrer: Referrer specified in the link
    :type referrer: :class:`String`
    """

    ID: typing.Literal["internalLinkTypePremiumFeatures"] = field(
        default="internalLinkTypePremiumFeatures", metadata={"alias": "@type"}
    )
    referrer: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypePremiumGift(BaseObject):
    """
    The link is a link to the screen for gifting Telegram Premium subscriptions to friends via inputInvoiceTelegram with telegramPaymentPurposePremiumGiftCodes payments or in-store purchases

    :param referrer: Referrer specified in the link
    :type referrer: :class:`String`
    """

    ID: typing.Literal["internalLinkTypePremiumGift"] = field(
        default="internalLinkTypePremiumGift", metadata={"alias": "@type"}
    )
    referrer: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypePremiumGiftCode(BaseObject):
    """
    The link is a link with a Telegram Premium gift code. Call checkPremiumGiftCode with the given code to process the link. If the code is valid and the user wants to apply it, then call applyPremiumGiftCode

    :param code: The Telegram Premium gift code
    :type code: :class:`String`
    """

    ID: typing.Literal["internalLinkTypePremiumGiftCode"] = field(
        default="internalLinkTypePremiumGiftCode", metadata={"alias": "@type"}
    )
    code: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypePrivacyAndSecuritySettings(BaseObject):
    """
    The link is a link to the privacy and security section of the application settings
    """

    ID: typing.Literal["internalLinkTypePrivacyAndSecuritySettings"] = field(
        default="internalLinkTypePrivacyAndSecuritySettings", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeProxy(BaseObject):
    """
    The link is a link to a proxy. Call addProxy with the given parameters to process the link and add the proxy

    :param server: Proxy server domain or IP address
    :type server: :class:`String`
    :param port: Proxy server port
    :type port: :class:`Int32`
    :param type_: Type of the proxy
    :type type_: :class:`ProxyType`
    """

    ID: typing.Literal["internalLinkTypeProxy"] = field(default="internalLinkTypeProxy", metadata={"alias": "@type"})
    server: String
    port: Int32
    type_: ProxyType = field(default=MISSING, metadata={"alias": "type"})


@dataclass(slots=True, kw_only=True)
class InternalLinkTypePublicChat(BaseObject):
    """
    The link is a link to a chat by its username. Call searchPublicChat with the given chat username to process the link. If the chat is found, open its profile information screen or the chat itself. If draft text isn't empty and the chat is a private chat with a regular user, then put the draft text in the input field

    :param chat_username: Username of the chat
    :type chat_username: :class:`String`
    :param draft_text: Draft text for message to send in the chat
    :type draft_text: :class:`String`
    :param open_profile: True, if chat profile information screen must be opened; otherwise, the chat itself must be opened
    :type open_profile: :class:`Bool`
    """

    ID: typing.Literal["internalLinkTypePublicChat"] = field(
        default="internalLinkTypePublicChat", metadata={"alias": "@type"}
    )
    chat_username: String
    draft_text: String
    open_profile: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeQrCodeAuthentication(BaseObject):
    """
    The link can be used to login the current user on another device, but it must be scanned from QR-code using in-app camera. An alert similar to "This code can be used to allow someone to log in to your Telegram account. To confirm Telegram login, please go to Settings > Devices > Scan QR and scan the code" needs to be shown
    """

    ID: typing.Literal["internalLinkTypeQrCodeAuthentication"] = field(
        default="internalLinkTypeQrCodeAuthentication", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeRestorePurchases(BaseObject):
    """
    The link forces restore of App Store purchases when opened. For official iOS application only
    """

    ID: typing.Literal["internalLinkTypeRestorePurchases"] = field(
        default="internalLinkTypeRestorePurchases", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeSettings(BaseObject):
    """
    The link is a link to application settings
    """

    ID: typing.Literal["internalLinkTypeSettings"] = field(
        default="internalLinkTypeSettings", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeStickerSet(BaseObject):
    """
    The link is a link to a sticker set. Call searchStickerSet with the given sticker set name to process the link and show the sticker set. If the sticker set is found and the user wants to add it, then call changeStickerSet

    :param sticker_set_name: Name of the sticker set
    :type sticker_set_name: :class:`String`
    :param expect_custom_emoji: True, if the sticker set is expected to contain custom emoji
    :type expect_custom_emoji: :class:`Bool`
    """

    ID: typing.Literal["internalLinkTypeStickerSet"] = field(
        default="internalLinkTypeStickerSet", metadata={"alias": "@type"}
    )
    sticker_set_name: String
    expect_custom_emoji: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeStory(BaseObject):
    """
    The link is a link to a story. Call searchPublicChat with the given sender username, then call getStory with the received chat identifier and the given story identifier, then show the story if received

    :param story_sender_username: Username of the sender of the story
    :type story_sender_username: :class:`String`
    :param story_id: Story identifier
    :type story_id: :class:`Int32`
    """

    ID: typing.Literal["internalLinkTypeStory"] = field(default="internalLinkTypeStory", metadata={"alias": "@type"})
    story_sender_username: String
    story_id: Int32


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeTheme(BaseObject):
    """
    The link is a link to a cloud theme. TDLib has no theme support yet

    :param theme_name: Name of the theme
    :type theme_name: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeTheme"] = field(default="internalLinkTypeTheme", metadata={"alias": "@type"})
    theme_name: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeThemeSettings(BaseObject):
    """
    The link is a link to the theme section of the application settings
    """

    ID: typing.Literal["internalLinkTypeThemeSettings"] = field(
        default="internalLinkTypeThemeSettings", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeUnknownDeepLink(BaseObject):
    """
    The link is an unknown tg: link. Call getDeepLinkInfo to process the link

    :param link: Link to be passed to getDeepLinkInfo
    :type link: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeUnknownDeepLink"] = field(
        default="internalLinkTypeUnknownDeepLink", metadata={"alias": "@type"}
    )
    link: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeUnsupportedProxy(BaseObject):
    """
    The link is a link to an unsupported proxy. An alert can be shown to the user
    """

    ID: typing.Literal["internalLinkTypeUnsupportedProxy"] = field(
        default="internalLinkTypeUnsupportedProxy", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeUpgradedGift(BaseObject):
    """
    The link is a link to an upgraded gift. Call getUpgradedGift with the given name to process the link

    :param name: Name of the unique gift
    :type name: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeUpgradedGift"] = field(
        default="internalLinkTypeUpgradedGift", metadata={"alias": "@type"}
    )
    name: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeUserPhoneNumber(BaseObject):
    """
    The link is a link to a user by its phone number. Call searchUserByPhoneNumber with the given phone number to process the link. If the user is found, then call createPrivateChat and open user's profile information screen or the chat itself. If draft text isn't empty, then put the draft text in the input field

    :param phone_number: Phone number of the user
    :type phone_number: :class:`String`
    :param draft_text: Draft text for message to send in the chat
    :type draft_text: :class:`String`
    :param open_profile: True, if user's profile information screen must be opened; otherwise, the chat itself must be opened
    :type open_profile: :class:`Bool`
    """

    ID: typing.Literal["internalLinkTypeUserPhoneNumber"] = field(
        default="internalLinkTypeUserPhoneNumber", metadata={"alias": "@type"}
    )
    phone_number: String
    draft_text: String
    open_profile: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeUserToken(BaseObject):
    """
    The link is a link to a user by a temporary token. Call searchUserByToken with the given token to process the link. If the user is found, then call createPrivateChat and open the chat

    :param token: The token
    :type token: :class:`String`
    """

    ID: typing.Literal["internalLinkTypeUserToken"] = field(
        default="internalLinkTypeUserToken", metadata={"alias": "@type"}
    )
    token: String


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeVideoChat(BaseObject):
    """
    The link is a link to a video chat. Call searchPublicChat with the given chat username, and then joinGroupCall with the given invite hash to process the link

    :param chat_username: Username of the chat with the video chat
    :type chat_username: :class:`String`
    :param invite_hash: If non-empty, invite hash to be used to join the video chat without being muted by administrators
    :type invite_hash: :class:`String`
    :param is_live_stream: True, if the video chat is expected to be a live stream in a channel or a broadcast group
    :type is_live_stream: :class:`Bool`
    """

    ID: typing.Literal["internalLinkTypeVideoChat"] = field(
        default="internalLinkTypeVideoChat", metadata={"alias": "@type"}
    )
    chat_username: String
    invite_hash: String = field(default="")
    is_live_stream: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class InternalLinkTypeWebApp(BaseObject):
    """
    The link is a link to a Web App. Call searchPublicChat with the given bot username, check that the user is a bot. If the bot is restricted for the current user, then show an error message. Otherwise, call searchWebApp with the received bot and the given web_app_short_name. Process received foundWebApp by showing a confirmation dialog if needed. If the bot can be added to attachment or side menu, but isn't added yet, then show a disclaimer about Mini Apps being third-party applications instead of the dialog and ask the user to accept their Terms of service. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add the bot. Then, call getWebAppLinkUrl and open the returned URL as a Web App

    :param bot_username: Username of the bot that owns the Web App
    :type bot_username: :class:`String`
    :param web_app_short_name: Short name of the Web App
    :type web_app_short_name: :class:`String`
    :param start_parameter: Start parameter to be passed to getWebAppLinkUrl
    :type start_parameter: :class:`String`
    :param mode: The mode in which the Web App must be opened
    :type mode: :class:`WebAppOpenMode`
    """

    ID: typing.Literal["internalLinkTypeWebApp"] = field(default="internalLinkTypeWebApp", metadata={"alias": "@type"})
    bot_username: String
    web_app_short_name: String
    start_parameter: String
    mode: WebAppOpenMode


InternalLinkType = typing.Union[
    InternalLinkTypeActiveSessions,
    InternalLinkTypeAttachmentMenuBot,
    InternalLinkTypeAuthenticationCode,
    InternalLinkTypeBackground,
    InternalLinkTypeBotAddToChannel,
    InternalLinkTypeBotStart,
    InternalLinkTypeBotStartInGroup,
    InternalLinkTypeBusinessChat,
    InternalLinkTypeBuyStars,
    InternalLinkTypeChangePhoneNumber,
    InternalLinkTypeChatAffiliateProgram,
    InternalLinkTypeChatBoost,
    InternalLinkTypeChatFolderInvite,
    InternalLinkTypeChatFolderSettings,
    InternalLinkTypeChatInvite,
    InternalLinkTypeDefaultMessageAutoDeleteTimerSettings,
    InternalLinkTypeEditProfileSettings,
    InternalLinkTypeGame,
    InternalLinkTypeInstantView,
    InternalLinkTypeInvoice,
    InternalLinkTypeLanguagePack,
    InternalLinkTypeLanguageSettings,
    InternalLinkTypeMainWebApp,
    InternalLinkTypeMessage,
    InternalLinkTypeMessageDraft,
    InternalLinkTypePassportDataRequest,
    InternalLinkTypePhoneNumberConfirmation,
    InternalLinkTypePremiumFeatures,
    InternalLinkTypePremiumGift,
    InternalLinkTypePremiumGiftCode,
    InternalLinkTypePrivacyAndSecuritySettings,
    InternalLinkTypeProxy,
    InternalLinkTypePublicChat,
    InternalLinkTypeQrCodeAuthentication,
    InternalLinkTypeRestorePurchases,
    InternalLinkTypeSettings,
    InternalLinkTypeStickerSet,
    InternalLinkTypeStory,
    InternalLinkTypeTheme,
    InternalLinkTypeThemeSettings,
    InternalLinkTypeUnknownDeepLink,
    InternalLinkTypeUnsupportedProxy,
    InternalLinkTypeUpgradedGift,
    InternalLinkTypeUserPhoneNumber,
    InternalLinkTypeUserToken,
    InternalLinkTypeVideoChat,
    InternalLinkTypeWebApp,
]


@dataclass(slots=True, kw_only=True)
class InviteLinkChatTypeBasicGroup(BaseObject):
    """
    The link is an invite link for a basic group
    """

    ID: typing.Literal["inviteLinkChatTypeBasicGroup"] = field(
        default="inviteLinkChatTypeBasicGroup", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InviteLinkChatTypeChannel(BaseObject):
    """
    The link is an invite link for a channel
    """

    ID: typing.Literal["inviteLinkChatTypeChannel"] = field(
        default="inviteLinkChatTypeChannel", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class InviteLinkChatTypeSupergroup(BaseObject):
    """
    The link is an invite link for a supergroup
    """

    ID: typing.Literal["inviteLinkChatTypeSupergroup"] = field(
        default="inviteLinkChatTypeSupergroup", metadata={"alias": "@type"}
    )


InviteLinkChatType = typing.Union[
    InviteLinkChatTypeBasicGroup,
    InviteLinkChatTypeChannel,
    InviteLinkChatTypeSupergroup,
]


@dataclass(slots=True, kw_only=True)
class Invoice(BaseObject):
    """
    Product invoice

    :param currency: ISO 4217 currency code
    :type currency: :class:`String`
    :param price_parts: A list of objects used to calculate the total price of the product
    :type price_parts: :class:`Vector[LabeledPricePart]`
    :param max_tip_amount: The maximum allowed amount of tip in the smallest units of the currency
    :type max_tip_amount: :class:`Int53`
    :param suggested_tip_amounts: Suggested amounts of tip in the smallest units of the currency
    :type suggested_tip_amounts: :class:`Vector[Int53]`
    :param subscription_period: The number of seconds between consecutive Telegram Star debiting for subscription invoices; 0 if the invoice doesn't create subscription
    :type subscription_period: :class:`Int32`
    :param recurring_payment_terms_of_service_url: An HTTP URL with terms of service for recurring payments. If non-empty, the invoice payment will result in recurring payments and the user must accept the terms of service before allowed to pay
    :type recurring_payment_terms_of_service_url: :class:`String`
    :param terms_of_service_url: An HTTP URL with terms of service for non-recurring payments. If non-empty, then the user must accept the terms of service before allowed to pay
    :type terms_of_service_url: :class:`String`
    :param is_test: True, if the payment is a test payment
    :type is_test: :class:`Bool`
    :param need_name: True, if the user's name is needed for payment
    :type need_name: :class:`Bool`
    :param need_phone_number: True, if the user's phone number is needed for payment
    :type need_phone_number: :class:`Bool`
    :param need_email_address: True, if the user's email address is needed for payment
    :type need_email_address: :class:`Bool`
    :param need_shipping_address: True, if the user's shipping address is needed for payment
    :type need_shipping_address: :class:`Bool`
    :param send_phone_number_to_provider: True, if the user's phone number will be sent to the provider
    :type send_phone_number_to_provider: :class:`Bool`
    :param send_email_address_to_provider: True, if the user's email address will be sent to the provider
    :type send_email_address_to_provider: :class:`Bool`
    :param is_flexible: True, if the total price depends on the shipping method
    :type is_flexible: :class:`Bool`
    """

    ID: typing.Literal["invoice"] = field(default="invoice", metadata={"alias": "@type"})
    currency: String
    price_parts: Vector[LabeledPricePart]
    max_tip_amount: Int53
    suggested_tip_amounts: Vector[Int53]
    subscription_period: Int32 = field(default=0)
    recurring_payment_terms_of_service_url: String = field(default="")
    terms_of_service_url: String = field(default="")
    is_test: Bool = field(default=False)
    need_name: Bool = field(default=False)
    need_phone_number: Bool = field(default=False)
    need_email_address: Bool = field(default=False)
    need_shipping_address: Bool = field(default=False)
    send_phone_number_to_provider: Bool = field(default=False)
    send_email_address_to_provider: Bool = field(default=False)
    is_flexible: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class JsonValueArray(BaseObject):
    """
    Represents a JSON array

    :param values: The list of array elements
    :type values: :class:`Vector[JsonValue]`
    """

    ID: typing.Literal["jsonValueArray"] = field(default="jsonValueArray", metadata={"alias": "@type"})
    values: Vector[JsonValue]


@dataclass(slots=True, kw_only=True)
class JsonValueBoolean(BaseObject):
    """
    Represents a boolean JSON value

    :param value: The value
    :type value: :class:`Bool`
    """

    ID: typing.Literal["jsonValueBoolean"] = field(default="jsonValueBoolean", metadata={"alias": "@type"})
    value: Bool


@dataclass(slots=True, kw_only=True)
class JsonValueNull(BaseObject):
    """
    Represents a null JSON value
    """

    ID: typing.Literal["jsonValueNull"] = field(default="jsonValueNull", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class JsonValueNumber(BaseObject):
    """
    Represents a numeric JSON value

    :param value: The value
    :type value: :class:`Double`
    """

    ID: typing.Literal["jsonValueNumber"] = field(default="jsonValueNumber", metadata={"alias": "@type"})
    value: Double


@dataclass(slots=True, kw_only=True)
class JsonValueObject(BaseObject):
    """
    Represents a JSON object

    :param members: The list of object members
    :type members: :class:`Vector[JsonObjectMember]`
    """

    ID: typing.Literal["jsonValueObject"] = field(default="jsonValueObject", metadata={"alias": "@type"})
    members: Vector[JsonObjectMember]


@dataclass(slots=True, kw_only=True)
class JsonValueString(BaseObject):
    """
    Represents a string JSON value

    :param value: The value
    :type value: :class:`String`
    """

    ID: typing.Literal["jsonValueString"] = field(default="jsonValueString", metadata={"alias": "@type"})
    value: String


JsonValue = typing.Union[
    JsonValueArray,
    JsonValueBoolean,
    JsonValueNull,
    JsonValueNumber,
    JsonValueObject,
    JsonValueString,
]


@dataclass(slots=True, kw_only=True)
class JsonObjectMember(BaseObject):
    """
    Represents one member of a JSON object

    :param key: Member's key
    :type key: :class:`String`
    :param value: Member's value
    :type value: :class:`JsonValue`
    """

    ID: typing.Literal["jsonObjectMember"] = field(default="jsonObjectMember", metadata={"alias": "@type"})
    key: String
    value: JsonValue


@dataclass(slots=True, kw_only=True)
class KeyboardButton(BaseObject):
    """
    Represents a single button in a bot keyboard

    :param text: Text of the button
    :type text: :class:`String`
    :param type_: Type of the button
    :type type_: :class:`KeyboardButtonType`
    """

    ID: typing.Literal["keyboardButton"] = field(default="keyboardButton", metadata={"alias": "@type"})
    text: String
    type_: KeyboardButtonType = field(default=MISSING, metadata={"alias": "type"})


@dataclass(slots=True, kw_only=True)
class KeyboardButtonTypeRequestChat(BaseObject):
    """
    A button that requests a chat to be shared by the current user; available only in private chats. Use the method shareChatWithBot to complete the request

    :param id: Unique button identifier
    :type id: :class:`Int32`
    :param user_administrator_rights: Expected user administrator rights in the chat; may be null if they aren't restricted, defaults to None
    :type user_administrator_rights: :class:`ChatAdministratorRights`, optional
    :param bot_administrator_rights: Expected bot administrator rights in the chat; may be null if they aren't restricted, defaults to None
    :type bot_administrator_rights: :class:`ChatAdministratorRights`, optional
    :param chat_is_channel: True, if the chat must be a channel; otherwise, a basic group or a supergroup chat is shared
    :type chat_is_channel: :class:`Bool`
    :param restrict_chat_is_forum: True, if the chat must or must not be a forum supergroup
    :type restrict_chat_is_forum: :class:`Bool`
    :param chat_is_forum: True, if the chat must be a forum supergroup; otherwise, the chat must not be a forum supergroup. Ignored if restrict_chat_is_forum is false
    :type chat_is_forum: :class:`Bool`
    :param restrict_chat_has_username: True, if the chat must or must not have a username
    :type restrict_chat_has_username: :class:`Bool`
    :param chat_has_username: True, if the chat must have a username; otherwise, the chat must not have a username. Ignored if restrict_chat_has_username is false
    :type chat_has_username: :class:`Bool`
    :param chat_is_created: True, if the chat must be created by the current user
    :type chat_is_created: :class:`Bool`
    :param bot_is_member: True, if the bot must be a member of the chat; for basic group and supergroup chats only
    :type bot_is_member: :class:`Bool`
    :param request_title: Pass true to request title of the chat; bots only
    :type request_title: :class:`Bool`
    :param request_username: Pass true to request username of the chat; bots only
    :type request_username: :class:`Bool`
    :param request_photo: Pass true to request photo of the chat; bots only
    :type request_photo: :class:`Bool`
    """

    ID: typing.Literal["keyboardButtonTypeRequestChat"] = field(
        default="keyboardButtonTypeRequestChat", metadata={"alias": "@type"}
    )
    id: Int32
    user_administrator_rights: typing.Optional[ChatAdministratorRights] = field(default=None)
    bot_administrator_rights: typing.Optional[ChatAdministratorRights] = field(default=None)
    chat_is_channel: Bool = field(default=False)
    restrict_chat_is_forum: Bool = field(default=False)
    chat_is_forum: Bool = field(default=False)
    restrict_chat_has_username: Bool = field(default=False)
    chat_has_username: Bool = field(default=False)
    chat_is_created: Bool = field(default=False)
    bot_is_member: Bool = field(default=False)
    request_title: Bool = field(default=False)
    request_username: Bool = field(default=False)
    request_photo: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class KeyboardButtonTypeRequestLocation(BaseObject):
    """
    A button that sends the user's location when pressed; available only in private chats
    """

    ID: typing.Literal["keyboardButtonTypeRequestLocation"] = field(
        default="keyboardButtonTypeRequestLocation", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class KeyboardButtonTypeRequestPhoneNumber(BaseObject):
    """
    A button that sends the user's phone number when pressed; available only in private chats
    """

    ID: typing.Literal["keyboardButtonTypeRequestPhoneNumber"] = field(
        default="keyboardButtonTypeRequestPhoneNumber", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class KeyboardButtonTypeRequestPoll(BaseObject):
    """
    A button that allows the user to create and send a poll when pressed; available only in private chats

    :param force_regular: If true, only regular polls must be allowed to create
    :type force_regular: :class:`Bool`
    :param force_quiz: If true, only polls in quiz mode must be allowed to create
    :type force_quiz: :class:`Bool`
    """

    ID: typing.Literal["keyboardButtonTypeRequestPoll"] = field(
        default="keyboardButtonTypeRequestPoll", metadata={"alias": "@type"}
    )
    force_regular: Bool = field(default=False)
    force_quiz: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class KeyboardButtonTypeRequestUsers(BaseObject):
    """
    A button that requests users to be shared by the current user; available only in private chats. Use the method shareUsersWithBot to complete the request

    :param id: Unique button identifier
    :type id: :class:`Int32`
    :param max_quantity: The maximum number of users to share
    :type max_quantity: :class:`Int32`
    :param restrict_user_is_bot: True, if the shared users must or must not be bots
    :type restrict_user_is_bot: :class:`Bool`
    :param user_is_bot: True, if the shared users must be bots; otherwise, the shared users must not be bots. Ignored if restrict_user_is_bot is false
    :type user_is_bot: :class:`Bool`
    :param restrict_user_is_premium: True, if the shared users must or must not be Telegram Premium users
    :type restrict_user_is_premium: :class:`Bool`
    :param user_is_premium: True, if the shared users must be Telegram Premium users; otherwise, the shared users must not be Telegram Premium users. Ignored if restrict_user_is_premium is false
    :type user_is_premium: :class:`Bool`
    :param request_name: Pass true to request name of the users; bots only
    :type request_name: :class:`Bool`
    :param request_username: Pass true to request username of the users; bots only
    :type request_username: :class:`Bool`
    :param request_photo: Pass true to request photo of the users; bots only
    :type request_photo: :class:`Bool`
    """

    ID: typing.Literal["keyboardButtonTypeRequestUsers"] = field(
        default="keyboardButtonTypeRequestUsers", metadata={"alias": "@type"}
    )
    id: Int32
    max_quantity: Int32
    restrict_user_is_bot: Bool = field(default=False)
    user_is_bot: Bool = field(default=False)
    restrict_user_is_premium: Bool = field(default=False)
    user_is_premium: Bool = field(default=False)
    request_name: Bool = field(default=False)
    request_username: Bool = field(default=False)
    request_photo: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class KeyboardButtonTypeText(BaseObject):
    """
    A simple button, with text that must be sent when the button is pressed
    """

    ID: typing.Literal["keyboardButtonTypeText"] = field(default="keyboardButtonTypeText", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class KeyboardButtonTypeWebApp(BaseObject):
    """
    A button that opens a Web App by calling getWebAppUrl

    :param url: An HTTP URL to pass to getWebAppUrl
    :type url: :class:`String`
    """

    ID: typing.Literal["keyboardButtonTypeWebApp"] = field(
        default="keyboardButtonTypeWebApp", metadata={"alias": "@type"}
    )
    url: String


KeyboardButtonType = typing.Union[
    KeyboardButtonTypeRequestChat,
    KeyboardButtonTypeRequestLocation,
    KeyboardButtonTypeRequestPhoneNumber,
    KeyboardButtonTypeRequestPoll,
    KeyboardButtonTypeRequestUsers,
    KeyboardButtonTypeText,
    KeyboardButtonTypeWebApp,
]


@dataclass(slots=True, kw_only=True)
class LabeledPricePart(BaseObject):
    """
    Portion of the price of a product (e.g., "delivery cost", "tax amount")

    :param label: Label for this portion of the product price
    :type label: :class:`String`
    :param amount: Currency amount in the smallest units of the currency
    :type amount: :class:`Int53`
    """

    ID: typing.Literal["labeledPricePart"] = field(default="labeledPricePart", metadata={"alias": "@type"})
    label: String
    amount: Int53


@dataclass(slots=True, kw_only=True)
class LanguagePackInfo(BaseObject):
    """
    Contains information about a language pack

    :param id: Unique language pack identifier
    :type id: :class:`String`
    :param name: Language name
    :type name: :class:`String`
    :param native_name: Name of the language in that language
    :type native_name: :class:`String`
    :param plural_code: A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
    :type plural_code: :class:`String`
    :param total_string_count: Total number of non-deleted strings from the language pack
    :type total_string_count: :class:`Int32`
    :param translated_string_count: Total number of translated strings from the language pack
    :type translated_string_count: :class:`Int32`
    :param local_string_count: Total number of non-deleted strings from the language pack available locally
    :type local_string_count: :class:`Int32`
    :param translation_url: Link to language translation interface; empty for custom local language packs
    :type translation_url: :class:`String`
    :param base_language_pack_id: Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it must be fetched from base language pack. Unsupported in custom language packs
    :type base_language_pack_id: :class:`String`
    :param is_official: True, if the language pack is official
    :type is_official: :class:`Bool`
    :param is_rtl: True, if the language pack strings are RTL
    :type is_rtl: :class:`Bool`
    :param is_beta: True, if the language pack is a beta language pack
    :type is_beta: :class:`Bool`
    :param is_installed: True, if the language pack is installed by the current user
    :type is_installed: :class:`Bool`
    """

    ID: typing.Literal["languagePackInfo"] = field(default="languagePackInfo", metadata={"alias": "@type"})
    id: String
    name: String
    native_name: String
    plural_code: String
    total_string_count: Int32
    translated_string_count: Int32
    local_string_count: Int32
    translation_url: String
    base_language_pack_id: String = field(default="")
    is_official: Bool = field(default=False)
    is_rtl: Bool = field(default=False)
    is_beta: Bool = field(default=False)
    is_installed: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class LanguagePackString(BaseObject):
    """
    Represents one language pack string

    :param key: String key
    :type key: :class:`String`
    :param value: String value; pass null if the string needs to be taken from the built-in English language pack, defaults to None
    :type value: :class:`LanguagePackStringValue`, optional
    """

    ID: typing.Literal["languagePackString"] = field(default="languagePackString", metadata={"alias": "@type"})
    key: String
    value: typing.Optional[LanguagePackStringValue] = field(default=None)


@dataclass(slots=True, kw_only=True)
class LanguagePackStringValueDeleted(BaseObject):
    """
    A deleted language pack string, the value must be taken from the built-in English language pack
    """

    ID: typing.Literal["languagePackStringValueDeleted"] = field(
        default="languagePackStringValueDeleted", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class LanguagePackStringValueOrdinary(BaseObject):
    """
    An ordinary language pack string

    :param value: String value
    :type value: :class:`String`
    """

    ID: typing.Literal["languagePackStringValueOrdinary"] = field(
        default="languagePackStringValueOrdinary", metadata={"alias": "@type"}
    )
    value: String


@dataclass(slots=True, kw_only=True)
class LanguagePackStringValuePluralized(BaseObject):
    """
    A language pack string which has different forms based on the number of some object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information

    :param zero_value: Value for zero objects
    :type zero_value: :class:`String`
    :param one_value: Value for one object
    :type one_value: :class:`String`
    :param two_value: Value for two objects
    :type two_value: :class:`String`
    :param few_value: Value for few objects
    :type few_value: :class:`String`
    :param many_value: Value for many objects
    :type many_value: :class:`String`
    :param other_value: Default value
    :type other_value: :class:`String`
    """

    ID: typing.Literal["languagePackStringValuePluralized"] = field(
        default="languagePackStringValuePluralized", metadata={"alias": "@type"}
    )
    zero_value: String
    one_value: String
    two_value: String
    few_value: String
    many_value: String
    other_value: String


LanguagePackStringValue = typing.Union[
    LanguagePackStringValueDeleted,
    LanguagePackStringValueOrdinary,
    LanguagePackStringValuePluralized,
]


@dataclass(slots=True, kw_only=True)
class LanguagePackStrings(BaseObject):
    """
    Contains a list of language pack strings

    :param strings: A list of language pack strings
    :type strings: :class:`Vector[LanguagePackString]`
    """

    ID: typing.Literal["languagePackStrings"] = field(default="languagePackStrings", metadata={"alias": "@type"})
    strings: Vector[LanguagePackString]


@dataclass(slots=True, kw_only=True)
class LinkPreview(BaseObject):
    """
    Describes a link preview

    :param url: Original URL of the link
    :type url: :class:`String`
    :param display_url: URL to display
    :type display_url: :class:`String`
    :param site_name: Short name of the site (e.g., Google Docs, App Store)
    :type site_name: :class:`String`
    :param title: Title of the content
    :type title: :class:`String`
    :param description: Description of the content
    :type description: :class:`FormattedText`
    :param author: Author of the content
    :type author: :class:`String`
    :param type_: Type of the link preview
    :type type_: :class:`LinkPreviewType`
    :param has_large_media: True, if size of media in the preview can be changed
    :type has_large_media: :class:`Bool`
    :param show_large_media: True, if large media preview must be shown; otherwise, the media preview must be shown small and only the first frame must be shown for videos
    :type show_large_media: :class:`Bool`
    :param show_media_above_description: True, if media must be shown above link preview description; otherwise, the media must be shown below the description
    :type show_media_above_description: :class:`Bool`
    :param skip_confirmation: True, if there is no need to show an ordinary open URL confirmation, when opening the URL from the preview, because the URL is shown in the message text in clear
    :type skip_confirmation: :class:`Bool`
    :param show_above_text: True, if the link preview must be shown above message text; otherwise, the link preview must be shown below the message text
    :type show_above_text: :class:`Bool`
    :param instant_view_version: Version of instant view (currently, can be 1 or 2) for the web page; 0 if none, defaults to None
    :type instant_view_version: :class:`Int32`, optional
    """

    ID: typing.Literal["linkPreview"] = field(default="linkPreview", metadata={"alias": "@type"})
    url: String
    display_url: String
    site_name: String
    title: String
    description: FormattedText
    author: String
    type_: LinkPreviewType = field(default=MISSING, metadata={"alias": "type"})
    has_large_media: Bool = field(default=False)
    show_large_media: Bool = field(default=False)
    show_media_above_description: Bool = field(default=False)
    skip_confirmation: Bool = field(default=False)
    show_above_text: Bool = field(default=False)
    instant_view_version: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class LinkPreviewAlbumMediaPhoto(BaseObject):
    """
    The media is a photo

    :param photo: Photo description
    :type photo: :class:`Photo`
    """

    ID: typing.Literal["linkPreviewAlbumMediaPhoto"] = field(
        default="linkPreviewAlbumMediaPhoto", metadata={"alias": "@type"}
    )
    photo: Photo


@dataclass(slots=True, kw_only=True)
class LinkPreviewAlbumMediaVideo(BaseObject):
    """
    The media is a video

    :param video: Video description
    :type video: :class:`Video`
    """

    ID: typing.Literal["linkPreviewAlbumMediaVideo"] = field(
        default="linkPreviewAlbumMediaVideo", metadata={"alias": "@type"}
    )
    video: Video


LinkPreviewAlbumMedia = typing.Union[
    LinkPreviewAlbumMediaPhoto,
    LinkPreviewAlbumMediaVideo,
]


@dataclass(slots=True, kw_only=True)
class LinkPreviewOptions(BaseObject):
    """
    Options to be used for generation of a link preview

    :param is_disabled: True, if link preview must be disabled
    :type is_disabled: :class:`Bool`
    :param url: URL to use for link preview. If empty, then the first URL found in the message text will be used
    :type url: :class:`String`
    :param force_small_media: True, if shown media preview must be small; ignored in secret chats or if the URL isn't explicitly specified
    :type force_small_media: :class:`Bool`
    :param force_large_media: True, if shown media preview must be large; ignored in secret chats or if the URL isn't explicitly specified
    :type force_large_media: :class:`Bool`
    :param show_above_text: True, if link preview must be shown above message text; otherwise, the link preview will be shown below the message text; ignored in secret chats
    :type show_above_text: :class:`Bool`
    """

    ID: typing.Literal["linkPreviewOptions"] = field(default="linkPreviewOptions", metadata={"alias": "@type"})
    is_disabled: Bool = field(default=False)
    url: String = field(default="")
    force_small_media: Bool = field(default=False)
    force_large_media: Bool = field(default=False)
    show_above_text: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeAlbum(BaseObject):
    """
    The link is a link to a media album consisting of photos and videos

    :param media: The list of album media
    :type media: :class:`Vector[LinkPreviewAlbumMedia]`
    :param caption: Album caption
    :type caption: :class:`String`
    """

    ID: typing.Literal["linkPreviewTypeAlbum"] = field(default="linkPreviewTypeAlbum", metadata={"alias": "@type"})
    media: Vector[LinkPreviewAlbumMedia]
    caption: String


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeAnimation(BaseObject):
    """
    The link is a link to an animation

    :param animation: The animation
    :type animation: :class:`Animation`
    """

    ID: typing.Literal["linkPreviewTypeAnimation"] = field(
        default="linkPreviewTypeAnimation", metadata={"alias": "@type"}
    )
    animation: Animation


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeApp(BaseObject):
    """
    The link is a link to an app at App Store or Google Play

    :param photo: Photo for the app
    :type photo: :class:`Photo`
    """

    ID: typing.Literal["linkPreviewTypeApp"] = field(default="linkPreviewTypeApp", metadata={"alias": "@type"})
    photo: Photo


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeArticle(BaseObject):
    """
    The link is a link to a web site

    :param photo: Article's main photo; may be null, defaults to None
    :type photo: :class:`Photo`, optional
    """

    ID: typing.Literal["linkPreviewTypeArticle"] = field(default="linkPreviewTypeArticle", metadata={"alias": "@type"})
    photo: typing.Optional[Photo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeAudio(BaseObject):
    """
    The link is a link to an audio

    :param audio: The audio description
    :type audio: :class:`Audio`
    """

    ID: typing.Literal["linkPreviewTypeAudio"] = field(default="linkPreviewTypeAudio", metadata={"alias": "@type"})
    audio: Audio


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeBackground(BaseObject):
    """
    The link is a link to a background. Link preview title and description are available only for filled backgrounds

    :param document: Document with the background; may be null for filled backgrounds, defaults to None
    :type document: :class:`Document`, optional
    :param background_type: Type of the background; may be null if unknown, defaults to None
    :type background_type: :class:`BackgroundType`, optional
    """

    ID: typing.Literal["linkPreviewTypeBackground"] = field(
        default="linkPreviewTypeBackground", metadata={"alias": "@type"}
    )
    document: typing.Optional[Document] = field(default=None)
    background_type: typing.Optional[BackgroundType] = field(default=None)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeChannelBoost(BaseObject):
    """
    The link is a link to boost a channel chat

    :param photo: Photo of the chat; may be null, defaults to None
    :type photo: :class:`ChatPhoto`, optional
    """

    ID: typing.Literal["linkPreviewTypeChannelBoost"] = field(
        default="linkPreviewTypeChannelBoost", metadata={"alias": "@type"}
    )
    photo: typing.Optional[ChatPhoto] = field(default=None)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeChat(BaseObject):
    """
    The link is a link to a chat

    :param type_: Type of the chat
    :type type_: :class:`InviteLinkChatType`
    :param photo: Photo of the chat; may be null, defaults to None
    :type photo: :class:`ChatPhoto`, optional
    :param creates_join_request: True, if the link only creates join request
    :type creates_join_request: :class:`Bool`
    """

    ID: typing.Literal["linkPreviewTypeChat"] = field(default="linkPreviewTypeChat", metadata={"alias": "@type"})
    type_: InviteLinkChatType = field(default=MISSING, metadata={"alias": "type"})
    photo: typing.Optional[ChatPhoto] = field(default=None)
    creates_join_request: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeDocument(BaseObject):
    """
    The link is a link to a general file

    :param document: The document description
    :type document: :class:`Document`
    """

    ID: typing.Literal["linkPreviewTypeDocument"] = field(
        default="linkPreviewTypeDocument", metadata={"alias": "@type"}
    )
    document: Document


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeEmbeddedAnimationPlayer(BaseObject):
    """
    The link is a link to an animation player

    :param url: URL of the external animation player
    :type url: :class:`String`
    :param duration: Duration of the animation, in seconds
    :type duration: :class:`Int32`
    :param width: Expected width of the embedded player
    :type width: :class:`Int32`
    :param height: Expected height of the embedded player
    :type height: :class:`Int32`
    :param thumbnail: Thumbnail of the animation; may be null if unknown, defaults to None
    :type thumbnail: :class:`Photo`, optional
    """

    ID: typing.Literal["linkPreviewTypeEmbeddedAnimationPlayer"] = field(
        default="linkPreviewTypeEmbeddedAnimationPlayer", metadata={"alias": "@type"}
    )
    url: String
    duration: Int32
    width: Int32
    height: Int32
    thumbnail: typing.Optional[Photo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeEmbeddedAudioPlayer(BaseObject):
    """
    The link is a link to an audio player

    :param url: URL of the external audio player
    :type url: :class:`String`
    :param duration: Duration of the audio, in seconds
    :type duration: :class:`Int32`
    :param width: Expected width of the embedded player
    :type width: :class:`Int32`
    :param height: Expected height of the embedded player
    :type height: :class:`Int32`
    :param thumbnail: Thumbnail of the audio; may be null if unknown, defaults to None
    :type thumbnail: :class:`Photo`, optional
    """

    ID: typing.Literal["linkPreviewTypeEmbeddedAudioPlayer"] = field(
        default="linkPreviewTypeEmbeddedAudioPlayer", metadata={"alias": "@type"}
    )
    url: String
    duration: Int32
    width: Int32
    height: Int32
    thumbnail: typing.Optional[Photo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeEmbeddedVideoPlayer(BaseObject):
    """
    The link is a link to a video player

    :param url: URL of the external video player
    :type url: :class:`String`
    :param duration: Duration of the video, in seconds
    :type duration: :class:`Int32`
    :param width: Expected width of the embedded player
    :type width: :class:`Int32`
    :param height: Expected height of the embedded player
    :type height: :class:`Int32`
    :param thumbnail: Thumbnail of the video; may be null if unknown, defaults to None
    :type thumbnail: :class:`Photo`, optional
    """

    ID: typing.Literal["linkPreviewTypeEmbeddedVideoPlayer"] = field(
        default="linkPreviewTypeEmbeddedVideoPlayer", metadata={"alias": "@type"}
    )
    url: String
    duration: Int32
    width: Int32
    height: Int32
    thumbnail: typing.Optional[Photo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeExternalAudio(BaseObject):
    """
    The link is a link to an audio file

    :param url: URL of the audio file
    :type url: :class:`String`
    :param mime_type: MIME type of the audio file
    :type mime_type: :class:`String`
    :param duration: Duration of the audio, in seconds; 0 if unknown, defaults to None
    :type duration: :class:`Int32`, optional
    """

    ID: typing.Literal["linkPreviewTypeExternalAudio"] = field(
        default="linkPreviewTypeExternalAudio", metadata={"alias": "@type"}
    )
    url: String
    mime_type: String
    duration: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeExternalVideo(BaseObject):
    """
    The link is a link to a video file

    :param url: URL of the video file
    :type url: :class:`String`
    :param mime_type: MIME type of the video file
    :type mime_type: :class:`String`
    :param width: Expected width of the video preview; 0 if unknown, defaults to None
    :type width: :class:`Int32`, optional
    :param height: Expected height of the video preview; 0 if unknown, defaults to None
    :type height: :class:`Int32`, optional
    :param duration: Duration of the video, in seconds; 0 if unknown, defaults to None
    :type duration: :class:`Int32`, optional
    """

    ID: typing.Literal["linkPreviewTypeExternalVideo"] = field(
        default="linkPreviewTypeExternalVideo", metadata={"alias": "@type"}
    )
    url: String
    mime_type: String
    width: typing.Optional[Int32] = field(default=0)
    height: typing.Optional[Int32] = field(default=0)
    duration: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeInvoice(BaseObject):
    """
    The link is a link to an invoice
    """

    ID: typing.Literal["linkPreviewTypeInvoice"] = field(default="linkPreviewTypeInvoice", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeMessage(BaseObject):
    """
    The link is a link to a text or a poll Telegram message
    """

    ID: typing.Literal["linkPreviewTypeMessage"] = field(default="linkPreviewTypeMessage", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypePhoto(BaseObject):
    """
    The link is a link to a photo

    :param photo: The photo
    :type photo: :class:`Photo`
    """

    ID: typing.Literal["linkPreviewTypePhoto"] = field(default="linkPreviewTypePhoto", metadata={"alias": "@type"})
    photo: Photo


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypePremiumGiftCode(BaseObject):
    """
    The link is a link to a Telegram Premium gift code
    """

    ID: typing.Literal["linkPreviewTypePremiumGiftCode"] = field(
        default="linkPreviewTypePremiumGiftCode", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeShareableChatFolder(BaseObject):
    """
    The link is a link to a shareable chat folder
    """

    ID: typing.Literal["linkPreviewTypeShareableChatFolder"] = field(
        default="linkPreviewTypeShareableChatFolder", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeSticker(BaseObject):
    """
    The link is a link to a sticker

    :param sticker: The sticker. It can be an arbitrary WEBP image and can have dimensions bigger than 512
    :type sticker: :class:`Sticker`
    """

    ID: typing.Literal["linkPreviewTypeSticker"] = field(default="linkPreviewTypeSticker", metadata={"alias": "@type"})
    sticker: Sticker


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeStickerSet(BaseObject):
    """
    The link is a link to a sticker set

    :param stickers: Up to 4 stickers from the sticker set
    :type stickers: :class:`Vector[Sticker]`
    """

    ID: typing.Literal["linkPreviewTypeStickerSet"] = field(
        default="linkPreviewTypeStickerSet", metadata={"alias": "@type"}
    )
    stickers: Vector[Sticker]


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeStory(BaseObject):
    """
    The link is a link to a story. Link preview description is unavailable

    :param story_sender_chat_id: The identifier of the chat that posted the story
    :type story_sender_chat_id: :class:`Int53`
    :param story_id: Story identifier
    :type story_id: :class:`Int32`
    """

    ID: typing.Literal["linkPreviewTypeStory"] = field(default="linkPreviewTypeStory", metadata={"alias": "@type"})
    story_sender_chat_id: Int53
    story_id: Int32


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeSupergroupBoost(BaseObject):
    """
    The link is a link to boost a supergroup chat

    :param photo: Photo of the chat; may be null, defaults to None
    :type photo: :class:`ChatPhoto`, optional
    """

    ID: typing.Literal["linkPreviewTypeSupergroupBoost"] = field(
        default="linkPreviewTypeSupergroupBoost", metadata={"alias": "@type"}
    )
    photo: typing.Optional[ChatPhoto] = field(default=None)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeTheme(BaseObject):
    """
    The link is a link to a cloud theme. TDLib has no theme support yet

    :param documents: The list of files with theme description
    :type documents: :class:`Vector[Document]`
    :param settings: Settings for the cloud theme; may be null if unknown, defaults to None
    :type settings: :class:`ThemeSettings`, optional
    """

    ID: typing.Literal["linkPreviewTypeTheme"] = field(default="linkPreviewTypeTheme", metadata={"alias": "@type"})
    documents: Vector[Document]
    settings: typing.Optional[ThemeSettings] = field(default=None)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeUnsupported(BaseObject):
    """
    The link preview type is unsupported yet
    """

    ID: typing.Literal["linkPreviewTypeUnsupported"] = field(
        default="linkPreviewTypeUnsupported", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeUpgradedGift(BaseObject):
    """
    The link is a link to an upgraded gift

    :param gift: The gift
    :type gift: :class:`UpgradedGift`
    """

    ID: typing.Literal["linkPreviewTypeUpgradedGift"] = field(
        default="linkPreviewTypeUpgradedGift", metadata={"alias": "@type"}
    )
    gift: UpgradedGift


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeUser(BaseObject):
    """
    The link is a link to a user

    :param photo: Photo of the user; may be null if none, defaults to None
    :type photo: :class:`ChatPhoto`, optional
    :param is_bot: True, if the user is a bot
    :type is_bot: :class:`Bool`
    """

    ID: typing.Literal["linkPreviewTypeUser"] = field(default="linkPreviewTypeUser", metadata={"alias": "@type"})
    photo: typing.Optional[ChatPhoto] = field(default=None)
    is_bot: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeVideo(BaseObject):
    """
    The link is a link to a video

    :param video: The video description
    :type video: :class:`Video`
    :param start_timestamp: Timestamp from which the video playing must start, in seconds
    :type start_timestamp: :class:`Int32`
    :param cover: Cover of the video; may be null if none, defaults to None
    :type cover: :class:`Photo`, optional
    """

    ID: typing.Literal["linkPreviewTypeVideo"] = field(default="linkPreviewTypeVideo", metadata={"alias": "@type"})
    video: Video
    start_timestamp: Int32
    cover: typing.Optional[Photo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeVideoChat(BaseObject):
    """
    The link is a link to a video chat

    :param photo: Photo of the chat with the video chat; may be null if none, defaults to None
    :type photo: :class:`ChatPhoto`, optional
    :param is_live_stream: True, if the video chat is expected to be a live stream in a channel or a broadcast group
    :type is_live_stream: :class:`Bool`
    """

    ID: typing.Literal["linkPreviewTypeVideoChat"] = field(
        default="linkPreviewTypeVideoChat", metadata={"alias": "@type"}
    )
    photo: typing.Optional[ChatPhoto] = field(default=None)
    is_live_stream: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeVideoNote(BaseObject):
    """
    The link is a link to a video note message

    :param video_note: The video note
    :type video_note: :class:`VideoNote`
    """

    ID: typing.Literal["linkPreviewTypeVideoNote"] = field(
        default="linkPreviewTypeVideoNote", metadata={"alias": "@type"}
    )
    video_note: VideoNote


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeVoiceNote(BaseObject):
    """
    The link is a link to a voice note message

    :param voice_note: The voice note
    :type voice_note: :class:`VoiceNote`
    """

    ID: typing.Literal["linkPreviewTypeVoiceNote"] = field(
        default="linkPreviewTypeVoiceNote", metadata={"alias": "@type"}
    )
    voice_note: VoiceNote


@dataclass(slots=True, kw_only=True)
class LinkPreviewTypeWebApp(BaseObject):
    """
    The link is a link to a Web App

    :param photo: Web App photo; may be null if none, defaults to None
    :type photo: :class:`Photo`, optional
    """

    ID: typing.Literal["linkPreviewTypeWebApp"] = field(default="linkPreviewTypeWebApp", metadata={"alias": "@type"})
    photo: typing.Optional[Photo] = field(default=None)


LinkPreviewType = typing.Union[
    LinkPreviewTypeAlbum,
    LinkPreviewTypeAnimation,
    LinkPreviewTypeApp,
    LinkPreviewTypeArticle,
    LinkPreviewTypeAudio,
    LinkPreviewTypeBackground,
    LinkPreviewTypeChannelBoost,
    LinkPreviewTypeChat,
    LinkPreviewTypeDocument,
    LinkPreviewTypeEmbeddedAnimationPlayer,
    LinkPreviewTypeEmbeddedAudioPlayer,
    LinkPreviewTypeEmbeddedVideoPlayer,
    LinkPreviewTypeExternalAudio,
    LinkPreviewTypeExternalVideo,
    LinkPreviewTypeInvoice,
    LinkPreviewTypeMessage,
    LinkPreviewTypePhoto,
    LinkPreviewTypePremiumGiftCode,
    LinkPreviewTypeShareableChatFolder,
    LinkPreviewTypeSticker,
    LinkPreviewTypeStickerSet,
    LinkPreviewTypeStory,
    LinkPreviewTypeSupergroupBoost,
    LinkPreviewTypeTheme,
    LinkPreviewTypeUnsupported,
    LinkPreviewTypeUpgradedGift,
    LinkPreviewTypeUser,
    LinkPreviewTypeVideo,
    LinkPreviewTypeVideoChat,
    LinkPreviewTypeVideoNote,
    LinkPreviewTypeVoiceNote,
    LinkPreviewTypeWebApp,
]


@dataclass(slots=True, kw_only=True)
class LocalFile(BaseObject):
    """
    Represents a local file

    :param download_offset: Download will be started from this offset. downloaded_prefix_size is calculated from this offset
    :type download_offset: :class:`Int53`
    :param downloaded_prefix_size: If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix in bytes
    :type downloaded_prefix_size: :class:`Int53`
    :param downloaded_size: Total downloaded file size, in bytes. Can be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage
    :type downloaded_size: :class:`Int53`
    :param path: Local path to the locally available file part; may be empty
    :type path: :class:`String`
    :param can_be_downloaded: True, if it is possible to download or generate the file
    :type can_be_downloaded: :class:`Bool`
    :param can_be_deleted: True, if the file can be deleted
    :type can_be_deleted: :class:`Bool`
    :param is_downloading_active: True, if the file is currently being downloaded (or a local copy is being generated by some other means)
    :type is_downloading_active: :class:`Bool`
    :param is_downloading_completed: True, if the local copy is fully available
    :type is_downloading_completed: :class:`Bool`
    """

    ID: typing.Literal["localFile"] = field(default="localFile", metadata={"alias": "@type"})
    download_offset: Int53
    downloaded_prefix_size: Int53
    downloaded_size: Int53
    path: String = field(default="")
    can_be_downloaded: Bool = field(default=False)
    can_be_deleted: Bool = field(default=False)
    is_downloading_active: Bool = field(default=False)
    is_downloading_completed: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class LocalizationTargetInfo(BaseObject):
    """
    Contains information about the current localization target

    :param language_packs: List of available language packs for this application
    :type language_packs: :class:`Vector[LanguagePackInfo]`
    """

    ID: typing.Literal["localizationTargetInfo"] = field(default="localizationTargetInfo", metadata={"alias": "@type"})
    language_packs: Vector[LanguagePackInfo]


@dataclass(slots=True, kw_only=True)
class Location(BaseObject):
    """
    Describes a location on planet Earth

    :param latitude: Latitude of the location in degrees; as defined by the sender
    :type latitude: :class:`Double`
    :param longitude: Longitude of the location, in degrees; as defined by the sender
    :type longitude: :class:`Double`
    :param horizontal_accuracy: The estimated horizontal accuracy of the location, in meters; as defined by the sender. 0 if unknown
    :type horizontal_accuracy: :class:`Double`
    """

    ID: typing.Literal["location"] = field(default="location", metadata={"alias": "@type"})
    latitude: Double
    longitude: Double
    horizontal_accuracy: Double = field(default=0)


@dataclass(slots=True, kw_only=True)
class LocationAddress(BaseObject):
    """
    Describes an address of a location

    :param country_code: A two-letter ISO 3166-1 alpha-2 country code
    :type country_code: :class:`String`
    :param state: State, if applicable; empty if unknown, defaults to None
    :type state: :class:`String`, optional
    :param city: City; empty if unknown, defaults to None
    :type city: :class:`String`, optional
    :param street: The address; empty if unknown, defaults to None
    :type street: :class:`String`, optional
    """

    ID: typing.Literal["locationAddress"] = field(default="locationAddress", metadata={"alias": "@type"})
    country_code: String
    state: typing.Optional[String] = field(default="")
    city: typing.Optional[String] = field(default="")
    street: typing.Optional[String] = field(default="")


@dataclass(slots=True, kw_only=True)
class LogStreamDefault(BaseObject):
    """
    The log is written to stderr or an OS specific log
    """

    ID: typing.Literal["logStreamDefault"] = field(default="logStreamDefault", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class LogStreamEmpty(BaseObject):
    """
    The log is written nowhere
    """

    ID: typing.Literal["logStreamEmpty"] = field(default="logStreamEmpty", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class LogStreamFile(BaseObject):
    """
    The log is written to a file

    :param path: Path to the file to where the internal TDLib log will be written
    :type path: :class:`String`
    :param max_file_size: The maximum size of the file to where the internal TDLib log is written before the file will automatically be rotated, in bytes
    :type max_file_size: :class:`Int53`
    :param redirect_stderr: Pass true to additionally redirect stderr to the log file. Ignored on Windows
    :type redirect_stderr: :class:`Bool`
    """

    ID: typing.Literal["logStreamFile"] = field(default="logStreamFile", metadata={"alias": "@type"})
    path: String
    max_file_size: Int53
    redirect_stderr: Bool = field(default=False)


LogStream = typing.Union[
    LogStreamDefault,
    LogStreamEmpty,
    LogStreamFile,
]


@dataclass(slots=True, kw_only=True)
class LogTags(BaseObject):
    """
    Contains a list of available TDLib internal log tags

    :param tags: List of log tags
    :type tags: :class:`Vector[String]`
    """

    ID: typing.Literal["logTags"] = field(default="logTags", metadata={"alias": "@type"})
    tags: Vector[String]


@dataclass(slots=True, kw_only=True)
class LogVerbosityLevel(BaseObject):
    """
    Contains a TDLib internal log verbosity level

    :param verbosity_level: Log verbosity level
    :type verbosity_level: :class:`Int32`
    """

    ID: typing.Literal["logVerbosityLevel"] = field(default="logVerbosityLevel", metadata={"alias": "@type"})
    verbosity_level: Int32


@dataclass(slots=True, kw_only=True)
class LoginUrlInfoOpen(BaseObject):
    """
    An HTTP URL needs to be open

    :param url: The URL to open
    :type url: :class:`String`
    :param skip_confirmation: True, if there is no need to show an ordinary open URL confirmation
    :type skip_confirmation: :class:`Bool`
    """

    ID: typing.Literal["loginUrlInfoOpen"] = field(default="loginUrlInfoOpen", metadata={"alias": "@type"})
    url: String
    skip_confirmation: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class LoginUrlInfoRequestConfirmation(BaseObject):
    """
    An authorization confirmation dialog needs to be shown to the user

    :param url: An HTTP URL to be opened
    :type url: :class:`String`
    :param domain: A domain of the URL
    :type domain: :class:`String`
    :param bot_user_id: User identifier of a bot linked with the website
    :type bot_user_id: :class:`Int53`
    :param request_write_access: True, if the user must be asked for the permission to the bot to send them messages
    :type request_write_access: :class:`Bool`
    """

    ID: typing.Literal["loginUrlInfoRequestConfirmation"] = field(
        default="loginUrlInfoRequestConfirmation", metadata={"alias": "@type"}
    )
    url: String
    domain: String
    bot_user_id: Int53
    request_write_access: Bool = field(default=False)


LoginUrlInfo = typing.Union[
    LoginUrlInfoOpen,
    LoginUrlInfoRequestConfirmation,
]


@dataclass(slots=True, kw_only=True)
class MainWebApp(BaseObject):
    """
    Contains information about the main Web App of a bot

    :param url: URL of the Web App to open
    :type url: :class:`String`
    :param mode: The mode in which the Web App must be opened
    :type mode: :class:`WebAppOpenMode`
    """

    ID: typing.Literal["mainWebApp"] = field(default="mainWebApp", metadata={"alias": "@type"})
    url: String
    mode: WebAppOpenMode


@dataclass(slots=True, kw_only=True)
class MaskPointChin(BaseObject):
    """
    The mask is placed relatively to the chin
    """

    ID: typing.Literal["maskPointChin"] = field(default="maskPointChin", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class MaskPointEyes(BaseObject):
    """
    The mask is placed relatively to the eyes
    """

    ID: typing.Literal["maskPointEyes"] = field(default="maskPointEyes", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class MaskPointForehead(BaseObject):
    """
    The mask is placed relatively to the forehead
    """

    ID: typing.Literal["maskPointForehead"] = field(default="maskPointForehead", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class MaskPointMouth(BaseObject):
    """
    The mask is placed relatively to the mouth
    """

    ID: typing.Literal["maskPointMouth"] = field(default="maskPointMouth", metadata={"alias": "@type"})


MaskPoint = typing.Union[
    MaskPointChin,
    MaskPointEyes,
    MaskPointForehead,
    MaskPointMouth,
]


@dataclass(slots=True, kw_only=True)
class MaskPosition(BaseObject):
    """
    Position on a photo where a mask is placed

    :param point: Part of the face, relative to which the mask is placed
    :type point: :class:`MaskPoint`
    :param x_shift: Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)
    :type x_shift: :class:`Double`
    :param y_shift: Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position)
    :type y_shift: :class:`Double`
    :param scale: Mask scaling coefficient. (For example, 2.0 means a doubled size)
    :type scale: :class:`Double`
    """

    ID: typing.Literal["maskPosition"] = field(default="maskPosition", metadata={"alias": "@type"})
    point: MaskPoint
    x_shift: Double
    y_shift: Double
    scale: Double


@dataclass(slots=True, kw_only=True)
class Message(BaseObject):
    """
    Describes a message

    :param id: Message identifier; unique for the chat to which the message belongs
    :type id: :class:`Int53`
    :param sender_id: Identifier of the sender of the message
    :type sender_id: :class:`MessageSender`
    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param unread_reactions: Information about unread reactions added to the message
    :type unread_reactions: :class:`Vector[UnreadReaction]`
    :param message_thread_id: If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
    :type message_thread_id: :class:`Int53`
    :param via_bot_user_id: If non-zero, the user identifier of the inline bot through which this message was sent
    :type via_bot_user_id: :class:`Int53`
    :param sender_business_bot_user_id: If non-zero, the user identifier of the business bot that sent this message
    :type sender_business_bot_user_id: :class:`Int53`
    :param author_signature: For channel posts and anonymous group messages, optional author signature
    :type author_signature: :class:`String`
    :param content: Content of the message
    :type content: :class:`MessageContent`
    :param sending_state: The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent, defaults to None
    :type sending_state: :class:`MessageSendingState`, optional
    :param scheduling_state: The scheduling state of the message; may be null if the message isn't scheduled, defaults to None
    :type scheduling_state: :class:`MessageSchedulingState`, optional
    :param forward_info: Information about the initial message sender; may be null if none or unknown, defaults to None
    :type forward_info: :class:`MessageForwardInfo`, optional
    :param import_info: Information about the initial message for messages created with importMessages; may be null if the message isn't imported, defaults to None
    :type import_info: :class:`MessageImportInfo`, optional
    :param interaction_info: Information about interactions with the message; may be null if none, defaults to None
    :type interaction_info: :class:`MessageInteractionInfo`, optional
    :param fact_check: Information about fact-check added to the message; may be null if none, defaults to None
    :type fact_check: :class:`FactCheck`, optional
    :param reply_to: Information about the message or the story this message is replying to; may be null if none, defaults to None
    :type reply_to: :class:`MessageReplyTo`, optional
    :param self_destruct_type: The message's self-destruct type; may be null if none, defaults to None
    :type self_destruct_type: :class:`MessageSelfDestructType`, optional
    :param reply_markup: Reply markup for the message; may be null if none, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    :param is_outgoing: True, if the message is outgoing
    :type is_outgoing: :class:`Bool`
    :param is_pinned: True, if the message is pinned
    :type is_pinned: :class:`Bool`
    :param is_from_offline: True, if the message was sent because of a scheduled action by the message sender, for example, as away, or greeting service message
    :type is_from_offline: :class:`Bool`
    :param can_be_saved: True, if content of the message can be saved locally or copied using inputMessageForwarded or forwardMessages with copy options
    :type can_be_saved: :class:`Bool`
    :param has_timestamped_media: True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message
    :type has_timestamped_media: :class:`Bool`
    :param is_channel_post: True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
    :type is_channel_post: :class:`Bool`
    :param is_topic_message: True, if the message is a forum topic message
    :type is_topic_message: :class:`Bool`
    :param contains_unread_mention: True, if the message contains an unread mention for the current user
    :type contains_unread_mention: :class:`Bool`
    :param date: Point in time (Unix timestamp) when the message was sent; 0 for scheduled messages
    :type date: :class:`Int32`
    :param edit_date: Point in time (Unix timestamp) when the message was last edited; 0 for scheduled messages
    :type edit_date: :class:`Int32`
    :param saved_messages_topic_id: Identifier of the Saved Messages topic for the message; 0 for messages not from Saved Messages
    :type saved_messages_topic_id: :class:`Int53`
    :param self_destruct_in: Time left before the message self-destruct timer expires, in seconds; 0 if self-destruction isn't scheduled yet
    :type self_destruct_in: :class:`Double`
    :param auto_delete_in: Time left before the message will be automatically deleted by message_auto_delete_time setting of the chat, in seconds; 0 if never
    :type auto_delete_in: :class:`Double`
    :param has_sensitive_content: True, if media content of the message must be hidden with 18+ spoiler
    :type has_sensitive_content: :class:`Bool`
    :param restriction_reason: If non-empty, contains a human-readable description of the reason why access to this message must be restricted
    :type restriction_reason: :class:`String`
    :param sender_boost_count: Number of times the sender of the message boosted the supergroup at the time the message was sent; 0 if none or unknown. For messages sent by the current user, supergroupFullInfo.my_boost_count must be used instead, defaults to None
    :type sender_boost_count: :class:`Int32`, optional
    :param media_album_id: Unique identifier of an album this message belongs to; 0 if none. Only audios, documents, photos and videos can be grouped together in albums, defaults to None
    :type media_album_id: :class:`Int64`, optional
    :param effect_id: Unique identifier of the effect added to the message; 0 if none, defaults to None
    :type effect_id: :class:`Int64`, optional
    """

    ID: typing.Literal["message"] = field(default="message", metadata={"alias": "@type"})
    id: Int53
    sender_id: MessageSender
    chat_id: Int53
    unread_reactions: Vector[UnreadReaction]
    message_thread_id: Int53
    via_bot_user_id: Int53
    sender_business_bot_user_id: Int53
    author_signature: String
    content: MessageContent
    sending_state: typing.Optional[MessageSendingState] = field(default=None)
    scheduling_state: typing.Optional[MessageSchedulingState] = field(default=None)
    forward_info: typing.Optional[MessageForwardInfo] = field(default=None)
    import_info: typing.Optional[MessageImportInfo] = field(default=None)
    interaction_info: typing.Optional[MessageInteractionInfo] = field(default=None)
    fact_check: typing.Optional[FactCheck] = field(default=None)
    reply_to: typing.Optional[MessageReplyTo] = field(default=None)
    self_destruct_type: typing.Optional[MessageSelfDestructType] = field(default=None)
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)
    is_outgoing: Bool = field(default=False)
    is_pinned: Bool = field(default=False)
    is_from_offline: Bool = field(default=False)
    can_be_saved: Bool = field(default=False)
    has_timestamped_media: Bool = field(default=False)
    is_channel_post: Bool = field(default=False)
    is_topic_message: Bool = field(default=False)
    contains_unread_mention: Bool = field(default=False)
    date: Int32 = field(default=0)
    edit_date: Int32 = field(default=0)
    saved_messages_topic_id: Int53 = field(default=0)
    self_destruct_in: Double = field(default=0)
    auto_delete_in: Double = field(default=0)
    has_sensitive_content: Bool = field(default=False)
    restriction_reason: String = field(default="")
    sender_boost_count: typing.Optional[Int32] = field(default=0)
    media_album_id: typing.Optional[Int64] = field(default=0)
    effect_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class MessageAutoDeleteTime(BaseObject):
    """
    Contains default auto-delete timer setting for new chats

    :param time: Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically
    :type time: :class:`Int32`
    """

    ID: typing.Literal["messageAutoDeleteTime"] = field(default="messageAutoDeleteTime", metadata={"alias": "@type"})
    time: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class MessageCalendar(BaseObject):
    """
    Contains information about found messages, split by days according to the option "utc_time_offset"

    :param total_count: Total number of found messages
    :type total_count: :class:`Int32`
    :param days: Information about messages sent
    :type days: :class:`Vector[MessageCalendarDay]`
    """

    ID: typing.Literal["messageCalendar"] = field(default="messageCalendar", metadata={"alias": "@type"})
    total_count: Int32
    days: Vector[MessageCalendarDay]


@dataclass(slots=True, kw_only=True)
class MessageCalendarDay(BaseObject):
    """
    Contains information about found messages sent on a specific day

    :param total_count: Total number of found messages sent on the day
    :type total_count: :class:`Int32`
    :param message: First message sent on the day
    :type message: :class:`Message`
    """

    ID: typing.Literal["messageCalendarDay"] = field(default="messageCalendarDay", metadata={"alias": "@type"})
    total_count: Int32
    message: Message


@dataclass(slots=True, kw_only=True)
class MessageAnimatedEmoji(BaseObject):
    """
    A message with an animated emoji

    :param animated_emoji: The animated emoji
    :type animated_emoji: :class:`AnimatedEmoji`
    :param emoji: The corresponding emoji
    :type emoji: :class:`String`
    """

    ID: typing.Literal["messageAnimatedEmoji"] = field(default="messageAnimatedEmoji", metadata={"alias": "@type"})
    animated_emoji: AnimatedEmoji
    emoji: String


@dataclass(slots=True, kw_only=True)
class MessageAnimation(BaseObject):
    """
    An animation message (GIF-style).

    :param animation: The animation description
    :type animation: :class:`Animation`
    :param caption: Animation caption
    :type caption: :class:`FormattedText`
    :param show_caption_above_media: True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation
    :type show_caption_above_media: :class:`Bool`
    :param has_spoiler: True, if the animation preview must be covered by a spoiler animation
    :type has_spoiler: :class:`Bool`
    :param is_secret: True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
    :type is_secret: :class:`Bool`
    """

    ID: typing.Literal["messageAnimation"] = field(default="messageAnimation", metadata={"alias": "@type"})
    animation: Animation
    caption: FormattedText
    show_caption_above_media: Bool = field(default=False)
    has_spoiler: Bool = field(default=False)
    is_secret: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageAudio(BaseObject):
    """
    An audio message

    :param audio: The audio description
    :type audio: :class:`Audio`
    :param caption: Audio caption
    :type caption: :class:`FormattedText`
    """

    ID: typing.Literal["messageAudio"] = field(default="messageAudio", metadata={"alias": "@type"})
    audio: Audio
    caption: FormattedText


@dataclass(slots=True, kw_only=True)
class MessageBasicGroupChatCreate(BaseObject):
    """
    A newly created basic group

    :param title: Title of the basic group
    :type title: :class:`String`
    :param member_user_ids: User identifiers of members in the basic group
    :type member_user_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["messageBasicGroupChatCreate"] = field(
        default="messageBasicGroupChatCreate", metadata={"alias": "@type"}
    )
    title: String
    member_user_ids: Vector[Int53]


@dataclass(slots=True, kw_only=True)
class MessageBotWriteAccessAllowed(BaseObject):
    """
    The user allowed the bot to send messages

    :param reason: The reason why the bot was allowed to write messages
    :type reason: :class:`BotWriteAccessAllowReason`
    """

    ID: typing.Literal["messageBotWriteAccessAllowed"] = field(
        default="messageBotWriteAccessAllowed", metadata={"alias": "@type"}
    )
    reason: BotWriteAccessAllowReason


@dataclass(slots=True, kw_only=True)
class MessageCall(BaseObject):
    """
    A message with information about an ended call

    :param discard_reason: Reason why the call was discarded
    :type discard_reason: :class:`CallDiscardReason`
    :param duration: Call duration, in seconds
    :type duration: :class:`Int32`
    :param is_video: True, if the call was a video call
    :type is_video: :class:`Bool`
    """

    ID: typing.Literal["messageCall"] = field(default="messageCall", metadata={"alias": "@type"})
    discard_reason: CallDiscardReason
    duration: Int32
    is_video: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageChatAddMembers(BaseObject):
    """
    New chat members were added

    :param member_user_ids: User identifiers of the new members
    :type member_user_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["messageChatAddMembers"] = field(default="messageChatAddMembers", metadata={"alias": "@type"})
    member_user_ids: Vector[Int53]


@dataclass(slots=True, kw_only=True)
class MessageChatBoost(BaseObject):
    """
    The chat was boosted by the sender of the message

    :param boost_count: Number of times the chat was boosted
    :type boost_count: :class:`Int32`
    """

    ID: typing.Literal["messageChatBoost"] = field(default="messageChatBoost", metadata={"alias": "@type"})
    boost_count: Int32


@dataclass(slots=True, kw_only=True)
class MessageChatChangePhoto(BaseObject):
    """
    An updated chat photo

    :param photo: New chat photo
    :type photo: :class:`ChatPhoto`
    """

    ID: typing.Literal["messageChatChangePhoto"] = field(default="messageChatChangePhoto", metadata={"alias": "@type"})
    photo: ChatPhoto


@dataclass(slots=True, kw_only=True)
class MessageChatChangeTitle(BaseObject):
    """
    An updated chat title

    :param title: New chat title
    :type title: :class:`String`
    """

    ID: typing.Literal["messageChatChangeTitle"] = field(default="messageChatChangeTitle", metadata={"alias": "@type"})
    title: String


@dataclass(slots=True, kw_only=True)
class MessageChatDeleteMember(BaseObject):
    """
    A chat member was deleted

    :param user_id: User identifier of the deleted chat member
    :type user_id: :class:`Int53`
    """

    ID: typing.Literal["messageChatDeleteMember"] = field(
        default="messageChatDeleteMember", metadata={"alias": "@type"}
    )
    user_id: Int53


@dataclass(slots=True, kw_only=True)
class MessageChatDeletePhoto(BaseObject):
    """
    A deleted chat photo
    """

    ID: typing.Literal["messageChatDeletePhoto"] = field(default="messageChatDeletePhoto", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class MessageChatJoinByLink(BaseObject):
    """
    A new member joined the chat via an invite link
    """

    ID: typing.Literal["messageChatJoinByLink"] = field(default="messageChatJoinByLink", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class MessageChatJoinByRequest(BaseObject):
    """
    A new member was accepted to the chat by an administrator
    """

    ID: typing.Literal["messageChatJoinByRequest"] = field(
        default="messageChatJoinByRequest", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class MessageChatSetBackground(BaseObject):
    """
    A new background was set in the chat

    :param background: The new background
    :type background: :class:`ChatBackground`
    :param only_for_self: True, if the background was set only for self
    :type only_for_self: :class:`Bool`
    :param old_background_message_id: Identifier of the message with a previously set same background; 0 if none. Can be an identifier of a deleted message, defaults to None
    :type old_background_message_id: :class:`Int53`, optional
    """

    ID: typing.Literal["messageChatSetBackground"] = field(
        default="messageChatSetBackground", metadata={"alias": "@type"}
    )
    background: ChatBackground
    only_for_self: Bool = field(default=False)
    old_background_message_id: typing.Optional[Int53] = field(default=0)


@dataclass(slots=True, kw_only=True)
class MessageChatSetMessageAutoDeleteTime(BaseObject):
    """
    The auto-delete or self-destruct timer for messages in the chat has been changed

    :param message_auto_delete_time: New value auto-delete or self-destruct time, in seconds; 0 if disabled
    :type message_auto_delete_time: :class:`Int32`
    :param from_user_id: If not 0, a user identifier, which default setting was automatically applied
    :type from_user_id: :class:`Int53`
    """

    ID: typing.Literal["messageChatSetMessageAutoDeleteTime"] = field(
        default="messageChatSetMessageAutoDeleteTime", metadata={"alias": "@type"}
    )
    message_auto_delete_time: Int32 = field(default=0)
    from_user_id: Int53 = field(default=0)


@dataclass(slots=True, kw_only=True)
class MessageChatSetTheme(BaseObject):
    """
    A theme in the chat has been changed

    :param theme_name: If non-empty, name of a new theme, set for the chat. Otherwise, chat theme was reset to the default one
    :type theme_name: :class:`String`
    """

    ID: typing.Literal["messageChatSetTheme"] = field(default="messageChatSetTheme", metadata={"alias": "@type"})
    theme_name: String = field(default="")


@dataclass(slots=True, kw_only=True)
class MessageChatShared(BaseObject):
    """
    The current user shared a chat, which was requested by the bot

    :param chat: The shared chat
    :type chat: :class:`SharedChat`
    :param button_id: Identifier of the keyboard button with the request
    :type button_id: :class:`Int32`
    """

    ID: typing.Literal["messageChatShared"] = field(default="messageChatShared", metadata={"alias": "@type"})
    chat: SharedChat
    button_id: Int32


@dataclass(slots=True, kw_only=True)
class MessageChatUpgradeFrom(BaseObject):
    """
    A supergroup has been created from a basic group

    :param title: Title of the newly created supergroup
    :type title: :class:`String`
    :param basic_group_id: The identifier of the original basic group
    :type basic_group_id: :class:`Int53`
    """

    ID: typing.Literal["messageChatUpgradeFrom"] = field(default="messageChatUpgradeFrom", metadata={"alias": "@type"})
    title: String
    basic_group_id: Int53


@dataclass(slots=True, kw_only=True)
class MessageChatUpgradeTo(BaseObject):
    """
    A basic group was upgraded to a supergroup and was deactivated as the result

    :param supergroup_id: Identifier of the supergroup to which the basic group was upgraded
    :type supergroup_id: :class:`Int53`
    """

    ID: typing.Literal["messageChatUpgradeTo"] = field(default="messageChatUpgradeTo", metadata={"alias": "@type"})
    supergroup_id: Int53


@dataclass(slots=True, kw_only=True)
class MessageContact(BaseObject):
    """
    A message with a user contact

    :param contact: The contact description
    :type contact: :class:`Contact`
    """

    ID: typing.Literal["messageContact"] = field(default="messageContact", metadata={"alias": "@type"})
    contact: Contact


@dataclass(slots=True, kw_only=True)
class MessageContactRegistered(BaseObject):
    """
    A contact has registered with Telegram
    """

    ID: typing.Literal["messageContactRegistered"] = field(
        default="messageContactRegistered", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class MessageCustomServiceAction(BaseObject):
    """
    A non-standard action has happened in the chat

    :param text: Message text to be shown in the chat
    :type text: :class:`String`
    """

    ID: typing.Literal["messageCustomServiceAction"] = field(
        default="messageCustomServiceAction", metadata={"alias": "@type"}
    )
    text: String


@dataclass(slots=True, kw_only=True)
class MessageDice(BaseObject):
    """
    A dice message. The dice value is randomly generated by the server

    :param emoji: Emoji on which the dice throw animation is based
    :type emoji: :class:`String`
    :param value: The dice value. If the value is 0, the dice don't have final state yet
    :type value: :class:`Int32`
    :param success_animation_frame_number: Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded
    :type success_animation_frame_number: :class:`Int32`
    :param initial_state: The animated stickers with the initial dice animation; may be null if unknown. The update updateMessageContent will be sent when the sticker became known, defaults to None
    :type initial_state: :class:`DiceStickers`, optional
    :param final_state: The animated stickers with the final dice animation; may be null if unknown. The update updateMessageContent will be sent when the sticker became known, defaults to None
    :type final_state: :class:`DiceStickers`, optional
    """

    ID: typing.Literal["messageDice"] = field(default="messageDice", metadata={"alias": "@type"})
    emoji: String
    value: Int32
    success_animation_frame_number: Int32
    initial_state: typing.Optional[DiceStickers] = field(default=None)
    final_state: typing.Optional[DiceStickers] = field(default=None)


@dataclass(slots=True, kw_only=True)
class MessageDocument(BaseObject):
    """
    A document message (general file)

    :param document: The document description
    :type document: :class:`Document`
    :param caption: Document caption
    :type caption: :class:`FormattedText`
    """

    ID: typing.Literal["messageDocument"] = field(default="messageDocument", metadata={"alias": "@type"})
    document: Document
    caption: FormattedText


@dataclass(slots=True, kw_only=True)
class MessageExpiredPhoto(BaseObject):
    """
    A self-destructed photo message
    """

    ID: typing.Literal["messageExpiredPhoto"] = field(default="messageExpiredPhoto", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class MessageExpiredVideo(BaseObject):
    """
    A self-destructed video message
    """

    ID: typing.Literal["messageExpiredVideo"] = field(default="messageExpiredVideo", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class MessageExpiredVideoNote(BaseObject):
    """
    A self-destructed video note message
    """

    ID: typing.Literal["messageExpiredVideoNote"] = field(
        default="messageExpiredVideoNote", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class MessageExpiredVoiceNote(BaseObject):
    """
    A self-destructed voice note message
    """

    ID: typing.Literal["messageExpiredVoiceNote"] = field(
        default="messageExpiredVoiceNote", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class MessageForumTopicCreated(BaseObject):
    """
    A forum topic has been created

    :param name: Name of the topic
    :type name: :class:`String`
    :param icon: Icon of the topic
    :type icon: :class:`ForumTopicIcon`
    """

    ID: typing.Literal["messageForumTopicCreated"] = field(
        default="messageForumTopicCreated", metadata={"alias": "@type"}
    )
    name: String
    icon: ForumTopicIcon


@dataclass(slots=True, kw_only=True)
class MessageForumTopicEdited(BaseObject):
    """
    A forum topic has been edited

    :param name: If non-empty, the new name of the topic
    :type name: :class:`String`
    :param edit_icon_custom_emoji_id: True, if icon's custom_emoji_id is changed
    :type edit_icon_custom_emoji_id: :class:`Bool`
    :param icon_custom_emoji_id: New unique identifier of the custom emoji shown on the topic icon; 0 if none. Must be ignored if edit_icon_custom_emoji_id is false, defaults to None
    :type icon_custom_emoji_id: :class:`Int64`, optional
    """

    ID: typing.Literal["messageForumTopicEdited"] = field(
        default="messageForumTopicEdited", metadata={"alias": "@type"}
    )
    name: String = field(default="")
    edit_icon_custom_emoji_id: Bool = field(default=False)
    icon_custom_emoji_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class MessageForumTopicIsClosedToggled(BaseObject):
    """
    A forum topic has been closed or opened

    :param is_closed: True, if the topic was closed; otherwise, the topic was reopened
    :type is_closed: :class:`Bool`
    """

    ID: typing.Literal["messageForumTopicIsClosedToggled"] = field(
        default="messageForumTopicIsClosedToggled", metadata={"alias": "@type"}
    )
    is_closed: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageForumTopicIsHiddenToggled(BaseObject):
    """
    A General forum topic has been hidden or unhidden

    :param is_hidden: True, if the topic was hidden; otherwise, the topic was unhidden
    :type is_hidden: :class:`Bool`
    """

    ID: typing.Literal["messageForumTopicIsHiddenToggled"] = field(
        default="messageForumTopicIsHiddenToggled", metadata={"alias": "@type"}
    )
    is_hidden: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageGame(BaseObject):
    """
    A message with a game

    :param game: The game description
    :type game: :class:`Game`
    """

    ID: typing.Literal["messageGame"] = field(default="messageGame", metadata={"alias": "@type"})
    game: Game


@dataclass(slots=True, kw_only=True)
class MessageGameScore(BaseObject):
    """
    A new high score was achieved in a game

    :param game_message_id: Identifier of the message with the game, can be an identifier of a deleted message
    :type game_message_id: :class:`Int53`
    :param game_id: Identifier of the game; may be different from the games presented in the message with the game
    :type game_id: :class:`Int64`
    :param score: New score
    :type score: :class:`Int32`
    """

    ID: typing.Literal["messageGameScore"] = field(default="messageGameScore", metadata={"alias": "@type"})
    game_message_id: Int53
    game_id: Int64
    score: Int32


@dataclass(slots=True, kw_only=True)
class MessageGift(BaseObject):
    """
    A regular gift was received or sent by the current user, or the current user was notified about a channel gift

    :param gift: The gift
    :type gift: :class:`Gift`
    :param sender_id: Sender of the gift
    :type sender_id: :class:`MessageSender`
    :param received_gift_id: Unique identifier of the received gift for the current user; only for the receiver of the gift
    :type received_gift_id: :class:`String`
    :param text: Message added to the gift
    :type text: :class:`FormattedText`
    :param prepaid_upgrade_star_count: Number of Telegram Stars that were paid by the sender for the ability to upgrade the gift
    :type prepaid_upgrade_star_count: :class:`Int53`
    :param sell_star_count: Number of Telegram Stars that can be claimed by the receiver instead of the regular gift; 0 if the gift can't be sold by the receiver
    :type sell_star_count: :class:`Int53`
    :param is_private: True, if the sender and gift text are shown only to the gift receiver; otherwise, everyone will be able to see them
    :type is_private: :class:`Bool`
    :param is_saved: True, if the gift is displayed on the user's or the channel's profile page; only for the receiver of the gift
    :type is_saved: :class:`Bool`
    :param can_be_upgraded: True, if the gift can be upgraded to a unique gift; only for the receiver of the gift
    :type can_be_upgraded: :class:`Bool`
    :param was_converted: True, if the gift was converted to Telegram Stars; only for the receiver of the gift
    :type was_converted: :class:`Bool`
    :param was_upgraded: True, if the gift was upgraded to a unique gift
    :type was_upgraded: :class:`Bool`
    :param was_refunded: True, if the gift was refunded and isn't available anymore
    :type was_refunded: :class:`Bool`
    :param upgraded_received_gift_id: Identifier of the corresponding upgraded gift; may be empty if unknown. Use getReceivedGift to get information about the gift
    :type upgraded_received_gift_id: :class:`String`
    """

    ID: typing.Literal["messageGift"] = field(default="messageGift", metadata={"alias": "@type"})
    gift: Gift
    sender_id: MessageSender
    received_gift_id: String
    text: FormattedText
    prepaid_upgrade_star_count: Int53
    sell_star_count: Int53 = field(default=0)
    is_private: Bool = field(default=False)
    is_saved: Bool = field(default=False)
    can_be_upgraded: Bool = field(default=False)
    was_converted: Bool = field(default=False)
    was_upgraded: Bool = field(default=False)
    was_refunded: Bool = field(default=False)
    upgraded_received_gift_id: String = field(default="")


@dataclass(slots=True, kw_only=True)
class MessageGiftedPremium(BaseObject):
    """
    Telegram Premium was gifted to a user

    :param text: Message added to the gifted Telegram Premium by the sender
    :type text: :class:`FormattedText`
    :param currency: Currency for the paid amount
    :type currency: :class:`String`
    :param amount: The paid amount, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param month_count: Number of months the Telegram Premium subscription will be active
    :type month_count: :class:`Int32`
    :param sticker: A sticker to be shown in the message; may be null if unknown, defaults to None
    :type sticker: :class:`Sticker`, optional
    :param gifter_user_id: The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous or is outgoing
    :type gifter_user_id: :class:`Int53`
    :param receiver_user_id: The identifier of a user that received Telegram Premium; 0 if the gift is incoming
    :type receiver_user_id: :class:`Int53`
    :param cryptocurrency: Cryptocurrency used to pay for the gift; may be empty if none
    :type cryptocurrency: :class:`String`
    :param cryptocurrency_amount: The paid amount, in the smallest units of the cryptocurrency; 0 if none, defaults to None
    :type cryptocurrency_amount: :class:`Int64`, optional
    """

    ID: typing.Literal["messageGiftedPremium"] = field(default="messageGiftedPremium", metadata={"alias": "@type"})
    text: FormattedText
    currency: String
    amount: Int53
    month_count: Int32
    sticker: typing.Optional[Sticker] = field(default=None)
    gifter_user_id: Int53 = field(default=0)
    receiver_user_id: Int53 = field(default=0)
    cryptocurrency: String = field(default="")
    cryptocurrency_amount: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class MessageGiftedStars(BaseObject):
    """
    Telegram Stars were gifted to a user

    :param currency: Currency for the paid amount
    :type currency: :class:`String`
    :param amount: The paid amount, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param star_count: Number of Telegram Stars that were gifted
    :type star_count: :class:`Int53`
    :param transaction_id: Identifier of the transaction for Telegram Stars purchase; for receiver only
    :type transaction_id: :class:`String`
    :param sticker: A sticker to be shown in the message; may be null if unknown, defaults to None
    :type sticker: :class:`Sticker`, optional
    :param gifter_user_id: The identifier of a user that gifted Telegram Stars; 0 if the gift was anonymous or is outgoing
    :type gifter_user_id: :class:`Int53`
    :param receiver_user_id: The identifier of a user that received Telegram Stars; 0 if the gift is incoming
    :type receiver_user_id: :class:`Int53`
    :param cryptocurrency: Cryptocurrency used to pay for the gift; may be empty if none
    :type cryptocurrency: :class:`String`
    :param cryptocurrency_amount: The paid amount, in the smallest units of the cryptocurrency; 0 if none, defaults to None
    :type cryptocurrency_amount: :class:`Int64`, optional
    """

    ID: typing.Literal["messageGiftedStars"] = field(default="messageGiftedStars", metadata={"alias": "@type"})
    currency: String
    amount: Int53
    star_count: Int53
    transaction_id: String
    sticker: typing.Optional[Sticker] = field(default=None)
    gifter_user_id: Int53 = field(default=0)
    receiver_user_id: Int53 = field(default=0)
    cryptocurrency: String = field(default="")
    cryptocurrency_amount: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class MessageGiveaway(BaseObject):
    """
    A giveaway

    :param parameters: Giveaway parameters
    :type parameters: :class:`GiveawayParameters`
    :param winner_count: Number of users which will receive Telegram Premium subscription gift codes
    :type winner_count: :class:`Int32`
    :param prize: Prize of the giveaway
    :type prize: :class:`GiveawayPrize`
    :param sticker: A sticker to be shown in the message; may be null if unknown, defaults to None
    :type sticker: :class:`Sticker`, optional
    """

    ID: typing.Literal["messageGiveaway"] = field(default="messageGiveaway", metadata={"alias": "@type"})
    parameters: GiveawayParameters
    winner_count: Int32
    prize: GiveawayPrize
    sticker: typing.Optional[Sticker] = field(default=None)


@dataclass(slots=True, kw_only=True)
class MessageGiveawayCompleted(BaseObject):
    """
    A giveaway without public winners has been completed for the chat

    :param winner_count: Number of winners in the giveaway
    :type winner_count: :class:`Int32`
    :param unclaimed_prize_count: Number of undistributed prizes; for Telegram Premium giveaways only
    :type unclaimed_prize_count: :class:`Int32`
    :param giveaway_message_id: Identifier of the message with the giveaway; can be 0 if the message was deleted
    :type giveaway_message_id: :class:`Int53`
    :param is_star_giveaway: True, if the giveaway is a Telegram Star giveaway
    :type is_star_giveaway: :class:`Bool`
    """

    ID: typing.Literal["messageGiveawayCompleted"] = field(
        default="messageGiveawayCompleted", metadata={"alias": "@type"}
    )
    winner_count: Int32
    unclaimed_prize_count: Int32
    giveaway_message_id: Int53 = field(default=0)
    is_star_giveaway: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageGiveawayCreated(BaseObject):
    """
    A giveaway was created for the chat. Use telegramPaymentPurposePremiumGiveaway, storePaymentPurposePremiumGiveaway, telegramPaymentPurposeStarGiveaway, or storePaymentPurposeStarGiveaway to create a giveaway

    :param star_count: Number of Telegram Stars that will be shared by winners of the giveaway; 0 for Telegram Premium giveaways
    :type star_count: :class:`Int53`
    """

    ID: typing.Literal["messageGiveawayCreated"] = field(default="messageGiveawayCreated", metadata={"alias": "@type"})
    star_count: Int53 = field(default=0)


@dataclass(slots=True, kw_only=True)
class MessageGiveawayPrizeStars(BaseObject):
    """
    A Telegram Stars were received by the current user from a giveaway

    :param star_count: Number of Telegram Stars that were received
    :type star_count: :class:`Int53`
    :param transaction_id: Identifier of the transaction for Telegram Stars credit
    :type transaction_id: :class:`String`
    :param boosted_chat_id: Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway
    :type boosted_chat_id: :class:`Int53`
    :param sticker: A sticker to be shown in the message; may be null if unknown, defaults to None
    :type sticker: :class:`Sticker`, optional
    :param giveaway_message_id: Identifier of the message with the giveaway in the boosted chat; can be 0 if the message was deleted
    :type giveaway_message_id: :class:`Int53`
    :param is_unclaimed: True, if the corresponding winner wasn't chosen and the Telegram Stars were received by the owner of the boosted chat
    :type is_unclaimed: :class:`Bool`
    """

    ID: typing.Literal["messageGiveawayPrizeStars"] = field(
        default="messageGiveawayPrizeStars", metadata={"alias": "@type"}
    )
    star_count: Int53
    transaction_id: String
    boosted_chat_id: Int53
    sticker: typing.Optional[Sticker] = field(default=None)
    giveaway_message_id: Int53 = field(default=0)
    is_unclaimed: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageGiveawayWinners(BaseObject):
    """
    A giveaway with public winners has been completed for the chat

    :param boosted_chat_id: Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway
    :type boosted_chat_id: :class:`Int53`
    :param giveaway_message_id: Identifier of the message with the giveaway in the boosted chat
    :type giveaway_message_id: :class:`Int53`
    :param additional_chat_count: Number of other chats that participated in the giveaway
    :type additional_chat_count: :class:`Int32`
    :param actual_winners_selection_date: Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
    :type actual_winners_selection_date: :class:`Int32`
    :param prize: Prize of the giveaway
    :type prize: :class:`GiveawayPrize`
    :param prize_description: Additional description of the giveaway prize
    :type prize_description: :class:`String`
    :param winner_count: Total number of winners in the giveaway
    :type winner_count: :class:`Int32`
    :param winner_user_ids: Up to 100 user identifiers of the winners of the giveaway
    :type winner_user_ids: :class:`Vector[Int53]`
    :param unclaimed_prize_count: Number of undistributed prizes; for Telegram Premium giveaways only
    :type unclaimed_prize_count: :class:`Int32`
    :param only_new_members: True, if only new members of the chats were eligible for the giveaway
    :type only_new_members: :class:`Bool`
    :param was_refunded: True, if the giveaway was canceled and was fully refunded
    :type was_refunded: :class:`Bool`
    """

    ID: typing.Literal["messageGiveawayWinners"] = field(default="messageGiveawayWinners", metadata={"alias": "@type"})
    boosted_chat_id: Int53
    giveaway_message_id: Int53
    additional_chat_count: Int32
    actual_winners_selection_date: Int32
    prize: GiveawayPrize
    prize_description: String
    winner_count: Int32
    winner_user_ids: Vector[Int53]
    unclaimed_prize_count: Int32
    only_new_members: Bool = field(default=False)
    was_refunded: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageInviteVideoChatParticipants(BaseObject):
    """
    A message with information about an invitation to a video chat

    :param group_call_id: Identifier of the video chat. The video chat can be received through the method getGroupCall
    :type group_call_id: :class:`Int32`
    :param user_ids: Invited user identifiers
    :type user_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["messageInviteVideoChatParticipants"] = field(
        default="messageInviteVideoChatParticipants", metadata={"alias": "@type"}
    )
    group_call_id: Int32
    user_ids: Vector[Int53]


@dataclass(slots=True, kw_only=True)
class MessageInvoice(BaseObject):
    """
    A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart to share the invoice

    :param product_info: Information about the product
    :type product_info: :class:`ProductInfo`
    :param currency: Currency for the product price
    :type currency: :class:`String`
    :param total_amount: Product total price in the smallest units of the currency
    :type total_amount: :class:`Int53`
    :param start_parameter: Unique invoice bot start_parameter to be passed to getInternalLink
    :type start_parameter: :class:`String`
    :param receipt_message_id: The identifier of the message with the receipt, after the product has been purchased
    :type receipt_message_id: :class:`Int53`
    :param paid_media: Extended media attached to the invoice; may be null if none, defaults to None
    :type paid_media: :class:`PaidMedia`, optional
    :param paid_media_caption: Extended media caption; may be null if none, defaults to None
    :type paid_media_caption: :class:`FormattedText`, optional
    :param is_test: True, if the invoice is a test invoice
    :type is_test: :class:`Bool`
    :param need_shipping_address: True, if the shipping address must be specified
    :type need_shipping_address: :class:`Bool`
    """

    ID: typing.Literal["messageInvoice"] = field(default="messageInvoice", metadata={"alias": "@type"})
    product_info: ProductInfo
    currency: String
    total_amount: Int53
    start_parameter: String
    receipt_message_id: Int53
    paid_media: typing.Optional[PaidMedia] = field(default=None)
    paid_media_caption: typing.Optional[FormattedText] = field(default=None)
    is_test: Bool = field(default=False)
    need_shipping_address: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageLocation(BaseObject):
    """
    A message with a location

    :param location: The location description
    :type location: :class:`Location`
    :param live_period: Time relative to the message send date, for which the location can be updated, in seconds; if 0x7FFFFFFF, then location can be updated forever
    :type live_period: :class:`Int32`
    :param expires_in: Left time for which the location can be updated, in seconds. If 0, then the location can't be updated anymore. The update updateMessageContent is not sent when this field changes
    :type expires_in: :class:`Int32`
    :param heading: For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown
    :type heading: :class:`Int32`
    :param proximity_alert_radius: For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only to the message sender
    :type proximity_alert_radius: :class:`Int32`
    """

    ID: typing.Literal["messageLocation"] = field(default="messageLocation", metadata={"alias": "@type"})
    location: Location
    live_period: Int32 = field(default=0)
    expires_in: Int32 = field(default=0)
    heading: Int32 = field(default=0)
    proximity_alert_radius: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class MessagePaidMedia(BaseObject):
    """
    A message with paid media

    :param star_count: Number of Telegram Stars needed to buy access to the media in the message
    :type star_count: :class:`Int53`
    :param media: Information about the media
    :type media: :class:`Vector[PaidMedia]`
    :param caption: Media caption
    :type caption: :class:`FormattedText`
    :param show_caption_above_media: True, if the caption must be shown above the media; otherwise, the caption must be shown below the media
    :type show_caption_above_media: :class:`Bool`
    """

    ID: typing.Literal["messagePaidMedia"] = field(default="messagePaidMedia", metadata={"alias": "@type"})
    star_count: Int53
    media: Vector[PaidMedia]
    caption: FormattedText
    show_caption_above_media: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessagePassportDataReceived(BaseObject):
    """
    Telegram Passport data has been received; for bots only

    :param elements: List of received Telegram Passport elements
    :type elements: :class:`Vector[EncryptedPassportElement]`
    :param credentials: Encrypted data credentials
    :type credentials: :class:`EncryptedCredentials`
    """

    ID: typing.Literal["messagePassportDataReceived"] = field(
        default="messagePassportDataReceived", metadata={"alias": "@type"}
    )
    elements: Vector[EncryptedPassportElement]
    credentials: EncryptedCredentials


@dataclass(slots=True, kw_only=True)
class MessagePassportDataSent(BaseObject):
    """
    Telegram Passport data has been sent to a bot

    :param types: List of Telegram Passport element types sent
    :type types: :class:`Vector[PassportElementType]`
    """

    ID: typing.Literal["messagePassportDataSent"] = field(
        default="messagePassportDataSent", metadata={"alias": "@type"}
    )
    types: Vector[PassportElementType]


@dataclass(slots=True, kw_only=True)
class MessagePaymentRefunded(BaseObject):
    """
    A payment has been refunded

    :param owner_id: Identifier of the previous owner of the Telegram Stars that refunds them
    :type owner_id: :class:`MessageSender`
    :param currency: Currency for the price of the product
    :type currency: :class:`String`
    :param total_amount: Total price for the product, in the smallest units of the currency
    :type total_amount: :class:`Int53`
    :param invoice_payload: Invoice payload; only for bots
    :type invoice_payload: :class:`Bytes`
    :param telegram_payment_charge_id: Telegram payment identifier
    :type telegram_payment_charge_id: :class:`String`
    :param provider_payment_charge_id: Provider payment identifier
    :type provider_payment_charge_id: :class:`String`
    """

    ID: typing.Literal["messagePaymentRefunded"] = field(default="messagePaymentRefunded", metadata={"alias": "@type"})
    owner_id: MessageSender
    currency: String
    total_amount: Int53
    invoice_payload: Bytes
    telegram_payment_charge_id: String
    provider_payment_charge_id: String


@dataclass(slots=True, kw_only=True)
class MessagePaymentSuccessful(BaseObject):
    """
    A payment has been sent to a bot or a business account

    :param invoice_chat_id: Identifier of the chat, containing the corresponding invoice message
    :type invoice_chat_id: :class:`Int53`
    :param invoice_message_id: Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message
    :type invoice_message_id: :class:`Int53`
    :param currency: Currency for the price of the product
    :type currency: :class:`String`
    :param total_amount: Total price for the product, in the smallest units of the currency
    :type total_amount: :class:`Int53`
    :param is_recurring: True, if this is a recurring payment
    :type is_recurring: :class:`Bool`
    :param is_first_recurring: True, if this is the first recurring payment
    :type is_first_recurring: :class:`Bool`
    :param invoice_name: Name of the invoice; may be empty if unknown
    :type invoice_name: :class:`String`
    :param subscription_until_date: Point in time (Unix timestamp) when the subscription will expire; 0 if unknown or the payment isn't recurring, defaults to None
    :type subscription_until_date: :class:`Int32`, optional
    """

    ID: typing.Literal["messagePaymentSuccessful"] = field(
        default="messagePaymentSuccessful", metadata={"alias": "@type"}
    )
    invoice_chat_id: Int53
    invoice_message_id: Int53
    currency: String
    total_amount: Int53
    is_recurring: Bool = field(default=False)
    is_first_recurring: Bool = field(default=False)
    invoice_name: String = field(default="")
    subscription_until_date: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class MessagePaymentSuccessfulBot(BaseObject):
    """
    A payment has been received by the bot or the business account

    :param currency: Currency for price of the product
    :type currency: :class:`String`
    :param total_amount: Total price for the product, in the smallest units of the currency
    :type total_amount: :class:`Int53`
    :param invoice_payload: Invoice payload
    :type invoice_payload: :class:`Bytes`
    :param telegram_payment_charge_id: Telegram payment identifier
    :type telegram_payment_charge_id: :class:`String`
    :param provider_payment_charge_id: Provider payment identifier
    :type provider_payment_charge_id: :class:`String`
    :param order_info: Information about the order; may be null; for bots only, defaults to None
    :type order_info: :class:`OrderInfo`, optional
    :param is_recurring: True, if this is a recurring payment
    :type is_recurring: :class:`Bool`
    :param is_first_recurring: True, if this is the first recurring payment
    :type is_first_recurring: :class:`Bool`
    :param shipping_option_id: Identifier of the shipping option chosen by the user; may be empty if not applicable; for bots only
    :type shipping_option_id: :class:`String`
    :param subscription_until_date: Point in time (Unix timestamp) when the subscription will expire; 0 if unknown or the payment isn't recurring, defaults to None
    :type subscription_until_date: :class:`Int32`, optional
    """

    ID: typing.Literal["messagePaymentSuccessfulBot"] = field(
        default="messagePaymentSuccessfulBot", metadata={"alias": "@type"}
    )
    currency: String
    total_amount: Int53
    invoice_payload: Bytes
    telegram_payment_charge_id: String
    provider_payment_charge_id: String
    order_info: typing.Optional[OrderInfo] = field(default=None)
    is_recurring: Bool = field(default=False)
    is_first_recurring: Bool = field(default=False)
    shipping_option_id: String = field(default="")
    subscription_until_date: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class MessagePhoto(BaseObject):
    """
    A photo message

    :param photo: The photo
    :type photo: :class:`Photo`
    :param caption: Photo caption
    :type caption: :class:`FormattedText`
    :param show_caption_above_media: True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo
    :type show_caption_above_media: :class:`Bool`
    :param has_spoiler: True, if the photo preview must be covered by a spoiler animation
    :type has_spoiler: :class:`Bool`
    :param is_secret: True, if the photo must be blurred and must be shown only while tapped
    :type is_secret: :class:`Bool`
    """

    ID: typing.Literal["messagePhoto"] = field(default="messagePhoto", metadata={"alias": "@type"})
    photo: Photo
    caption: FormattedText
    show_caption_above_media: Bool = field(default=False)
    has_spoiler: Bool = field(default=False)
    is_secret: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessagePinMessage(BaseObject):
    """
    A message has been pinned

    :param message_id: Identifier of the pinned message, can be an identifier of a deleted message or 0
    :type message_id: :class:`Int53`
    """

    ID: typing.Literal["messagePinMessage"] = field(default="messagePinMessage", metadata={"alias": "@type"})
    message_id: Int53


@dataclass(slots=True, kw_only=True)
class MessagePoll(BaseObject):
    """
    A message with a poll

    :param poll: The poll description
    :type poll: :class:`Poll`
    """

    ID: typing.Literal["messagePoll"] = field(default="messagePoll", metadata={"alias": "@type"})
    poll: Poll


@dataclass(slots=True, kw_only=True)
class MessagePremiumGiftCode(BaseObject):
    """
    A Telegram Premium gift code was created for the user

    :param text: Message added to the gift
    :type text: :class:`FormattedText`
    :param month_count: Number of months the Telegram Premium subscription will be active after code activation
    :type month_count: :class:`Int32`
    :param code: The gift code
    :type code: :class:`String`
    :param creator_id: Identifier of a chat or a user that created the gift code; may be null if unknown, defaults to None
    :type creator_id: :class:`MessageSender`, optional
    :param sticker: A sticker to be shown in the message; may be null if unknown, defaults to None
    :type sticker: :class:`Sticker`, optional
    :param is_from_giveaway: True, if the gift code was created for a giveaway
    :type is_from_giveaway: :class:`Bool`
    :param is_unclaimed: True, if the winner for the corresponding Telegram Premium subscription wasn't chosen
    :type is_unclaimed: :class:`Bool`
    :param cryptocurrency: Cryptocurrency used to pay for the gift; may be empty if none or unknown
    :type cryptocurrency: :class:`String`
    :param currency: Currency for the paid amount; empty if unknown, defaults to None
    :type currency: :class:`String`, optional
    :param amount: The paid amount, in the smallest units of the currency; 0 if unknown, defaults to None
    :type amount: :class:`Int53`, optional
    :param cryptocurrency_amount: The paid amount, in the smallest units of the cryptocurrency; 0 if unknown, defaults to None
    :type cryptocurrency_amount: :class:`Int64`, optional
    """

    ID: typing.Literal["messagePremiumGiftCode"] = field(default="messagePremiumGiftCode", metadata={"alias": "@type"})
    text: FormattedText
    month_count: Int32
    code: String
    creator_id: typing.Optional[MessageSender] = field(default=None)
    sticker: typing.Optional[Sticker] = field(default=None)
    is_from_giveaway: Bool = field(default=False)
    is_unclaimed: Bool = field(default=False)
    cryptocurrency: String = field(default="")
    currency: typing.Optional[String] = field(default="")
    amount: typing.Optional[Int53] = field(default=0)
    cryptocurrency_amount: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class MessageProximityAlertTriggered(BaseObject):
    """
    A user in the chat came within proximity alert range

    :param traveler_id: The identifier of a user or chat that triggered the proximity alert
    :type traveler_id: :class:`MessageSender`
    :param watcher_id: The identifier of a user or chat that subscribed for the proximity alert
    :type watcher_id: :class:`MessageSender`
    :param distance: The distance between the users
    :type distance: :class:`Int32`
    """

    ID: typing.Literal["messageProximityAlertTriggered"] = field(
        default="messageProximityAlertTriggered", metadata={"alias": "@type"}
    )
    traveler_id: MessageSender
    watcher_id: MessageSender
    distance: Int32


@dataclass(slots=True, kw_only=True)
class MessageRefundedUpgradedGift(BaseObject):
    """
    A gift which purchase, upgrade or transfer were refunded

    :param gift: The gift
    :type gift: :class:`Gift`
    :param sender_id: Sender of the gift
    :type sender_id: :class:`MessageSender`
    :param is_upgrade: True, if the gift was obtained by upgrading of a previously received gift
    :type is_upgrade: :class:`Bool`
    """

    ID: typing.Literal["messageRefundedUpgradedGift"] = field(
        default="messageRefundedUpgradedGift", metadata={"alias": "@type"}
    )
    gift: Gift
    sender_id: MessageSender
    is_upgrade: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageScreenshotTaken(BaseObject):
    """
    A screenshot of a message in the chat has been taken
    """

    ID: typing.Literal["messageScreenshotTaken"] = field(default="messageScreenshotTaken", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class MessageSticker(BaseObject):
    """
    A sticker message

    :param sticker: The sticker description
    :type sticker: :class:`Sticker`
    :param is_premium: True, if premium animation of the sticker must be played
    :type is_premium: :class:`Bool`
    """

    ID: typing.Literal["messageSticker"] = field(default="messageSticker", metadata={"alias": "@type"})
    sticker: Sticker
    is_premium: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageStory(BaseObject):
    """
    A message with a forwarded story

    :param story_sender_chat_id: Identifier of the chat that posted the story
    :type story_sender_chat_id: :class:`Int53`
    :param story_id: Story identifier
    :type story_id: :class:`Int32`
    :param via_mention: True, if the story was automatically forwarded because of a mention of the user
    :type via_mention: :class:`Bool`
    """

    ID: typing.Literal["messageStory"] = field(default="messageStory", metadata={"alias": "@type"})
    story_sender_chat_id: Int53
    story_id: Int32
    via_mention: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageSuggestProfilePhoto(BaseObject):
    """
    A profile photo was suggested to a user in a private chat

    :param photo: The suggested chat photo. Use the method setProfilePhoto with inputChatPhotoPrevious to apply the photo
    :type photo: :class:`ChatPhoto`
    """

    ID: typing.Literal["messageSuggestProfilePhoto"] = field(
        default="messageSuggestProfilePhoto", metadata={"alias": "@type"}
    )
    photo: ChatPhoto


@dataclass(slots=True, kw_only=True)
class MessageSupergroupChatCreate(BaseObject):
    """
    A newly created supergroup or channel

    :param title: Title of the supergroup or channel
    :type title: :class:`String`
    """

    ID: typing.Literal["messageSupergroupChatCreate"] = field(
        default="messageSupergroupChatCreate", metadata={"alias": "@type"}
    )
    title: String


@dataclass(slots=True, kw_only=True)
class MessageText(BaseObject):
    """
    A text message

    :param text: Text of the message
    :type text: :class:`FormattedText`
    :param link_preview: A link preview attached to the message; may be null, defaults to None
    :type link_preview: :class:`LinkPreview`, optional
    :param link_preview_options: Options which were used for generation of the link preview; may be null if default options were used, defaults to None
    :type link_preview_options: :class:`LinkPreviewOptions`, optional
    """

    ID: typing.Literal["messageText"] = field(default="messageText", metadata={"alias": "@type"})
    text: FormattedText
    link_preview: typing.Optional[LinkPreview] = field(default=None)
    link_preview_options: typing.Optional[LinkPreviewOptions] = field(default=None)


@dataclass(slots=True, kw_only=True)
class MessageUnsupported(BaseObject):
    """
    A message content that is not supported in the current TDLib version
    """

    ID: typing.Literal["messageUnsupported"] = field(default="messageUnsupported", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class MessageUpgradedGift(BaseObject):
    """
    An upgraded gift was received or sent by the current user, or the current user was notified about a channel gift

    :param gift: The gift
    :type gift: :class:`UpgradedGift`
    :param received_gift_id: Unique identifier of the received gift for the current user; only for the receiver of the gift
    :type received_gift_id: :class:`String`
    :param transfer_star_count: Number of Telegram Stars that must be paid to transfer the upgraded gift; only for the receiver of the gift
    :type transfer_star_count: :class:`Int53`
    :param sender_id: Sender of the gift; may be null for anonymous gifts, defaults to None
    :type sender_id: :class:`MessageSender`, optional
    :param is_upgrade: True, if the gift was obtained by upgrading of a previously received gift; otherwise, this is a transferred gift
    :type is_upgrade: :class:`Bool`
    :param is_saved: True, if the gift is displayed on the user's or the channel's profile page; only for the receiver of the gift
    :type is_saved: :class:`Bool`
    :param can_be_transferred: True, if the gift can be transferred to another owner; only for the receiver of the gift
    :type can_be_transferred: :class:`Bool`
    :param was_transferred: True, if the gift was transferred to another owner; only for the receiver of the gift
    :type was_transferred: :class:`Bool`
    :param export_date: Point in time (Unix timestamp) when the gift can be transferred to the TON blockchain as an NFT; 0 if NFT export isn't possible; only for the receiver of the gift
    :type export_date: :class:`Int32`
    """

    ID: typing.Literal["messageUpgradedGift"] = field(default="messageUpgradedGift", metadata={"alias": "@type"})
    gift: UpgradedGift
    received_gift_id: String
    transfer_star_count: Int53
    sender_id: typing.Optional[MessageSender] = field(default=None)
    is_upgrade: Bool = field(default=False)
    is_saved: Bool = field(default=False)
    can_be_transferred: Bool = field(default=False)
    was_transferred: Bool = field(default=False)
    export_date: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class MessageUsersShared(BaseObject):
    """
    The current user shared users, which were requested by the bot

    :param users: The shared users
    :type users: :class:`Vector[SharedUser]`
    :param button_id: Identifier of the keyboard button with the request
    :type button_id: :class:`Int32`
    """

    ID: typing.Literal["messageUsersShared"] = field(default="messageUsersShared", metadata={"alias": "@type"})
    users: Vector[SharedUser]
    button_id: Int32


@dataclass(slots=True, kw_only=True)
class MessageVenue(BaseObject):
    """
    A message with information about a venue

    :param venue: The venue description
    :type venue: :class:`Venue`
    """

    ID: typing.Literal["messageVenue"] = field(default="messageVenue", metadata={"alias": "@type"})
    venue: Venue


@dataclass(slots=True, kw_only=True)
class MessageVideo(BaseObject):
    """
    A video message

    :param video: The video description
    :type video: :class:`Video`
    :param alternative_videos: Alternative qualities of the video
    :type alternative_videos: :class:`Vector[AlternativeVideo]`
    :param start_timestamp: Timestamp from which the video playing must start, in seconds
    :type start_timestamp: :class:`Int32`
    :param caption: Video caption
    :type caption: :class:`FormattedText`
    :param cover: Cover of the video; may be null if none, defaults to None
    :type cover: :class:`Photo`, optional
    :param show_caption_above_media: True, if the caption must be shown above the video; otherwise, the caption must be shown below the video
    :type show_caption_above_media: :class:`Bool`
    :param has_spoiler: True, if the video preview must be covered by a spoiler animation
    :type has_spoiler: :class:`Bool`
    :param is_secret: True, if the video thumbnail must be blurred and the video must be shown only while tapped
    :type is_secret: :class:`Bool`
    """

    ID: typing.Literal["messageVideo"] = field(default="messageVideo", metadata={"alias": "@type"})
    video: Video
    alternative_videos: Vector[AlternativeVideo]
    start_timestamp: Int32
    caption: FormattedText
    cover: typing.Optional[Photo] = field(default=None)
    show_caption_above_media: Bool = field(default=False)
    has_spoiler: Bool = field(default=False)
    is_secret: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageVideoChatEnded(BaseObject):
    """
    A message with information about an ended video chat

    :param duration: Call duration, in seconds
    :type duration: :class:`Int32`
    """

    ID: typing.Literal["messageVideoChatEnded"] = field(default="messageVideoChatEnded", metadata={"alias": "@type"})
    duration: Int32


@dataclass(slots=True, kw_only=True)
class MessageVideoChatScheduled(BaseObject):
    """
    A new video chat was scheduled

    :param group_call_id: Identifier of the video chat. The video chat can be received through the method getGroupCall
    :type group_call_id: :class:`Int32`
    :param start_date: Point in time (Unix timestamp) when the group call is expected to be started by an administrator
    :type start_date: :class:`Int32`
    """

    ID: typing.Literal["messageVideoChatScheduled"] = field(
        default="messageVideoChatScheduled", metadata={"alias": "@type"}
    )
    group_call_id: Int32
    start_date: Int32


@dataclass(slots=True, kw_only=True)
class MessageVideoChatStarted(BaseObject):
    """
    A newly created video chat

    :param group_call_id: Identifier of the video chat. The video chat can be received through the method getGroupCall
    :type group_call_id: :class:`Int32`
    """

    ID: typing.Literal["messageVideoChatStarted"] = field(
        default="messageVideoChatStarted", metadata={"alias": "@type"}
    )
    group_call_id: Int32


@dataclass(slots=True, kw_only=True)
class MessageVideoNote(BaseObject):
    """
    A video note message

    :param video_note: The video note description
    :type video_note: :class:`VideoNote`
    :param is_viewed: True, if at least one of the recipients has viewed the video note
    :type is_viewed: :class:`Bool`
    :param is_secret: True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
    :type is_secret: :class:`Bool`
    """

    ID: typing.Literal["messageVideoNote"] = field(default="messageVideoNote", metadata={"alias": "@type"})
    video_note: VideoNote
    is_viewed: Bool = field(default=False)
    is_secret: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageVoiceNote(BaseObject):
    """
    A voice note message

    :param voice_note: The voice note description
    :type voice_note: :class:`VoiceNote`
    :param caption: Voice note caption
    :type caption: :class:`FormattedText`
    :param is_listened: True, if at least one of the recipients has listened to the voice note
    :type is_listened: :class:`Bool`
    """

    ID: typing.Literal["messageVoiceNote"] = field(default="messageVoiceNote", metadata={"alias": "@type"})
    voice_note: VoiceNote
    caption: FormattedText
    is_listened: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageWebAppDataReceived(BaseObject):
    """
    Data from a Web App has been received; for bots only

    :param button_text: Text of the keyboardButtonTypeWebApp button, which opened the Web App
    :type button_text: :class:`String`
    :param data: The data
    :type data: :class:`String`
    """

    ID: typing.Literal["messageWebAppDataReceived"] = field(
        default="messageWebAppDataReceived", metadata={"alias": "@type"}
    )
    button_text: String
    data: String


@dataclass(slots=True, kw_only=True)
class MessageWebAppDataSent(BaseObject):
    """
    Data from a Web App has been sent to a bot

    :param button_text: Text of the keyboardButtonTypeWebApp button, which opened the Web App
    :type button_text: :class:`String`
    """

    ID: typing.Literal["messageWebAppDataSent"] = field(default="messageWebAppDataSent", metadata={"alias": "@type"})
    button_text: String


MessageContent = typing.Union[
    MessageAnimatedEmoji,
    MessageAnimation,
    MessageAudio,
    MessageBasicGroupChatCreate,
    MessageBotWriteAccessAllowed,
    MessageCall,
    MessageChatAddMembers,
    MessageChatBoost,
    MessageChatChangePhoto,
    MessageChatChangeTitle,
    MessageChatDeleteMember,
    MessageChatDeletePhoto,
    MessageChatJoinByLink,
    MessageChatJoinByRequest,
    MessageChatSetBackground,
    MessageChatSetMessageAutoDeleteTime,
    MessageChatSetTheme,
    MessageChatShared,
    MessageChatUpgradeFrom,
    MessageChatUpgradeTo,
    MessageContact,
    MessageContactRegistered,
    MessageCustomServiceAction,
    MessageDice,
    MessageDocument,
    MessageExpiredPhoto,
    MessageExpiredVideo,
    MessageExpiredVideoNote,
    MessageExpiredVoiceNote,
    MessageForumTopicCreated,
    MessageForumTopicEdited,
    MessageForumTopicIsClosedToggled,
    MessageForumTopicIsHiddenToggled,
    MessageGame,
    MessageGameScore,
    MessageGift,
    MessageGiftedPremium,
    MessageGiftedStars,
    MessageGiveaway,
    MessageGiveawayCompleted,
    MessageGiveawayCreated,
    MessageGiveawayPrizeStars,
    MessageGiveawayWinners,
    MessageInviteVideoChatParticipants,
    MessageInvoice,
    MessageLocation,
    MessagePaidMedia,
    MessagePassportDataReceived,
    MessagePassportDataSent,
    MessagePaymentRefunded,
    MessagePaymentSuccessful,
    MessagePaymentSuccessfulBot,
    MessagePhoto,
    MessagePinMessage,
    MessagePoll,
    MessagePremiumGiftCode,
    MessageProximityAlertTriggered,
    MessageRefundedUpgradedGift,
    MessageScreenshotTaken,
    MessageSticker,
    MessageStory,
    MessageSuggestProfilePhoto,
    MessageSupergroupChatCreate,
    MessageText,
    MessageUnsupported,
    MessageUpgradedGift,
    MessageUsersShared,
    MessageVenue,
    MessageVideo,
    MessageVideoChatEnded,
    MessageVideoChatScheduled,
    MessageVideoChatStarted,
    MessageVideoNote,
    MessageVoiceNote,
    MessageWebAppDataReceived,
    MessageWebAppDataSent,
]


@dataclass(slots=True, kw_only=True)
class MessageCopyOptions(BaseObject):
    """
    Options to be used when a message content is copied without reference to the original sender. Service messages, messages with messageInvoice, messagePaidMedia, messageGiveaway, or messageGiveawayWinners content can't be copied

    :param send_copy: True, if content of the message needs to be copied without reference to the original sender. Always true if the message is forwarded to a secret chat or is local. Use messageProperties.can_be_saved and messageProperties.can_be_copied_to_secret_chat to check whether the message is suitable
    :type send_copy: :class:`Bool`
    :param replace_caption: True, if media caption of the message copy needs to be replaced. Ignored if send_copy is false
    :type replace_caption: :class:`Bool`
    :param new_show_caption_above_media: True, if new caption must be shown above the media; otherwise, new caption must be shown below the media; not supported in secret chats. Ignored if replace_caption is false
    :type new_show_caption_above_media: :class:`Bool`
    :param new_caption: New message caption; pass null to copy message without caption. Ignored if replace_caption is false, defaults to None
    :type new_caption: :class:`FormattedText`, optional
    """

    ID: typing.Literal["messageCopyOptions"] = field(default="messageCopyOptions", metadata={"alias": "@type"})
    send_copy: Bool = field(default=False)
    replace_caption: Bool = field(default=False)
    new_show_caption_above_media: Bool = field(default=False)
    new_caption: typing.Optional[FormattedText] = field(default=None)


@dataclass(slots=True, kw_only=True)
class MessageEffect(BaseObject):
    """
    Contains information about an effect added to a message

    :param id: Unique identifier of the effect
    :type id: :class:`Int64`
    :param emoji: Emoji corresponding to the effect that can be used if static icon isn't available
    :type emoji: :class:`String`
    :param type_: Type of the effect
    :type type_: :class:`MessageEffectType`
    :param static_icon: Static icon for the effect in WEBP format; may be null if none, defaults to None
    :type static_icon: :class:`Sticker`, optional
    :param is_premium: True, if Telegram Premium subscription is required to use the effect
    :type is_premium: :class:`Bool`
    """

    ID: typing.Literal["messageEffect"] = field(default="messageEffect", metadata={"alias": "@type"})
    id: Int64
    emoji: String
    type_: MessageEffectType = field(default=MISSING, metadata={"alias": "type"})
    static_icon: typing.Optional[Sticker] = field(default=None)
    is_premium: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageEffectTypeEmojiReaction(BaseObject):
    """
    An effect from an emoji reaction

    :param select_animation: Select animation for the effect in TGS format
    :type select_animation: :class:`Sticker`
    :param effect_animation: Effect animation for the effect in TGS format
    :type effect_animation: :class:`Sticker`
    """

    ID: typing.Literal["messageEffectTypeEmojiReaction"] = field(
        default="messageEffectTypeEmojiReaction", metadata={"alias": "@type"}
    )
    select_animation: Sticker
    effect_animation: Sticker


@dataclass(slots=True, kw_only=True)
class MessageEffectTypePremiumSticker(BaseObject):
    """
    An effect from a premium sticker

    :param sticker: The premium sticker. The effect can be found at sticker.full_type.premium_animation
    :type sticker: :class:`Sticker`
    """

    ID: typing.Literal["messageEffectTypePremiumSticker"] = field(
        default="messageEffectTypePremiumSticker", metadata={"alias": "@type"}
    )
    sticker: Sticker


MessageEffectType = typing.Union[
    MessageEffectTypeEmojiReaction,
    MessageEffectTypePremiumSticker,
]


@dataclass(slots=True, kw_only=True)
class MessageFileTypeGroup(BaseObject):
    """
    The messages were exported from a group chat

    :param title: Title of the group chat; may be empty if unrecognized
    :type title: :class:`String`
    """

    ID: typing.Literal["messageFileTypeGroup"] = field(default="messageFileTypeGroup", metadata={"alias": "@type"})
    title: String = field(default="")


@dataclass(slots=True, kw_only=True)
class MessageFileTypePrivate(BaseObject):
    """
    The messages were exported from a private chat

    :param name: Name of the other party; may be empty if unrecognized
    :type name: :class:`String`
    """

    ID: typing.Literal["messageFileTypePrivate"] = field(default="messageFileTypePrivate", metadata={"alias": "@type"})
    name: String = field(default="")


@dataclass(slots=True, kw_only=True)
class MessageFileTypeUnknown(BaseObject):
    """
    The messages were exported from a chat of unknown type
    """

    ID: typing.Literal["messageFileTypeUnknown"] = field(default="messageFileTypeUnknown", metadata={"alias": "@type"})


MessageFileType = typing.Union[
    MessageFileTypeGroup,
    MessageFileTypePrivate,
    MessageFileTypeUnknown,
]


@dataclass(slots=True, kw_only=True)
class MessageForwardInfo(BaseObject):
    """
    Contains information about a forwarded message

    :param origin: Origin of the forwarded message
    :type origin: :class:`MessageOrigin`
    :param date: Point in time (Unix timestamp) when the message was originally sent
    :type date: :class:`Int32`
    :param public_service_announcement_type: The type of public service announcement for the forwarded message
    :type public_service_announcement_type: :class:`String`
    :param source: For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, information about the source message from which the message was forwarded last time; may be null for other forwards or if unknown, defaults to None
    :type source: :class:`ForwardSource`, optional
    """

    ID: typing.Literal["messageForwardInfo"] = field(default="messageForwardInfo", metadata={"alias": "@type"})
    origin: MessageOrigin
    date: Int32
    public_service_announcement_type: String
    source: typing.Optional[ForwardSource] = field(default=None)


@dataclass(slots=True, kw_only=True)
class MessageImportInfo(BaseObject):
    """
    Contains information about a message created with importMessages

    :param sender_name: Name of the original sender
    :type sender_name: :class:`String`
    :param date: Point in time (Unix timestamp) when the message was originally sent
    :type date: :class:`Int32`
    """

    ID: typing.Literal["messageImportInfo"] = field(default="messageImportInfo", metadata={"alias": "@type"})
    sender_name: String
    date: Int32


@dataclass(slots=True, kw_only=True)
class MessageInteractionInfo(BaseObject):
    """
    Contains information about interactions with a message

    :param view_count: Number of times the message was viewed
    :type view_count: :class:`Int32`
    :param forward_count: Number of times the message was forwarded
    :type forward_count: :class:`Int32`
    :param reply_info: Information about direct or indirect replies to the message; may be null. Currently, available only in channels with a discussion supergroup and discussion supergroups for messages, which are not replies itself, defaults to None
    :type reply_info: :class:`MessageReplyInfo`, optional
    :param reactions: The list of reactions or tags added to the message; may be null, defaults to None
    :type reactions: :class:`MessageReactions`, optional
    """

    ID: typing.Literal["messageInteractionInfo"] = field(default="messageInteractionInfo", metadata={"alias": "@type"})
    view_count: Int32
    forward_count: Int32
    reply_info: typing.Optional[MessageReplyInfo] = field(default=None)
    reactions: typing.Optional[MessageReactions] = field(default=None)


@dataclass(slots=True, kw_only=True)
class MessageLink(BaseObject):
    """
    Contains an HTTPS link to a message in a supergroup or channel, or a forum topic

    :param link: The link
    :type link: :class:`String`
    :param is_public: True, if the link will work for non-members of the chat
    :type is_public: :class:`Bool`
    """

    ID: typing.Literal["messageLink"] = field(default="messageLink", metadata={"alias": "@type"})
    link: String
    is_public: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageLinkInfo(BaseObject):
    """
    Contains information about a link to a message or a forum topic in a chat

    :param chat_id: If found, identifier of the chat to which the link points, 0 otherwise
    :type chat_id: :class:`Int53`
    :param message_thread_id: If found, identifier of the message thread in which to open the message, or a forum topic to open if the message is missing
    :type message_thread_id: :class:`Int53`
    :param message: If found, the linked message; may be null, defaults to None
    :type message: :class:`Message`, optional
    :param is_public: True, if the link is a public link for a message or a forum topic in a chat
    :type is_public: :class:`Bool`
    :param media_timestamp: Timestamp from which the video/audio/video note/voice note/story playing must start, in seconds; 0 if not specified. The media can be in the message content or in its link preview
    :type media_timestamp: :class:`Int32`
    :param for_album: True, if the whole media album to which the message belongs is linked
    :type for_album: :class:`Bool`
    """

    ID: typing.Literal["messageLinkInfo"] = field(default="messageLinkInfo", metadata={"alias": "@type"})
    chat_id: Int53
    message_thread_id: Int53
    message: typing.Optional[Message] = field(default=None)
    is_public: Bool = field(default=False)
    media_timestamp: Int32 = field(default=0)
    for_album: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageOriginChannel(BaseObject):
    """
    The message was originally a post in a channel

    :param chat_id: Identifier of the channel chat to which the message was originally sent
    :type chat_id: :class:`Int53`
    :param message_id: Message identifier of the original message
    :type message_id: :class:`Int53`
    :param author_signature: Original post author signature
    :type author_signature: :class:`String`
    """

    ID: typing.Literal["messageOriginChannel"] = field(default="messageOriginChannel", metadata={"alias": "@type"})
    chat_id: Int53
    message_id: Int53
    author_signature: String


@dataclass(slots=True, kw_only=True)
class MessageOriginChat(BaseObject):
    """
    The message was originally sent on behalf of a chat

    :param sender_chat_id: Identifier of the chat that originally sent the message
    :type sender_chat_id: :class:`Int53`
    :param author_signature: For messages originally sent by an anonymous chat administrator, original message author signature
    :type author_signature: :class:`String`
    """

    ID: typing.Literal["messageOriginChat"] = field(default="messageOriginChat", metadata={"alias": "@type"})
    sender_chat_id: Int53
    author_signature: String


@dataclass(slots=True, kw_only=True)
class MessageOriginHiddenUser(BaseObject):
    """
    The message was originally sent by a user, which is hidden by their privacy settings

    :param sender_name: Name of the sender
    :type sender_name: :class:`String`
    """

    ID: typing.Literal["messageOriginHiddenUser"] = field(
        default="messageOriginHiddenUser", metadata={"alias": "@type"}
    )
    sender_name: String


@dataclass(slots=True, kw_only=True)
class MessageOriginUser(BaseObject):
    """
    The message was originally sent by a known user

    :param sender_user_id: Identifier of the user that originally sent the message
    :type sender_user_id: :class:`Int53`
    """

    ID: typing.Literal["messageOriginUser"] = field(default="messageOriginUser", metadata={"alias": "@type"})
    sender_user_id: Int53


MessageOrigin = typing.Union[
    MessageOriginChannel,
    MessageOriginChat,
    MessageOriginHiddenUser,
    MessageOriginUser,
]


@dataclass(slots=True, kw_only=True)
class MessagePosition(BaseObject):
    """
    Contains information about a message in a specific position

    :param position: 0-based message position in the full list of suitable messages
    :type position: :class:`Int32`
    :param message_id: Message identifier
    :type message_id: :class:`Int53`
    :param date: Point in time (Unix timestamp) when the message was sent
    :type date: :class:`Int32`
    """

    ID: typing.Literal["messagePosition"] = field(default="messagePosition", metadata={"alias": "@type"})
    position: Int32
    message_id: Int53
    date: Int32


@dataclass(slots=True, kw_only=True)
class MessagePositions(BaseObject):
    """
    Contains a list of message positions

    :param total_count: Total number of messages found
    :type total_count: :class:`Int32`
    :param positions: List of message positions
    :type positions: :class:`Vector[MessagePosition]`
    """

    ID: typing.Literal["messagePositions"] = field(default="messagePositions", metadata={"alias": "@type"})
    total_count: Int32
    positions: Vector[MessagePosition]


@dataclass(slots=True, kw_only=True)
class MessageProperties(BaseObject):
    """
    Contains properties of a message and describes actions that can be done with the message right now

    :param can_be_copied_to_secret_chat: True, if content of the message can be copied to a secret chat using inputMessageForwarded or forwardMessages with copy options
    :type can_be_copied_to_secret_chat: :class:`Bool`
    :param can_be_deleted_only_for_self: True, if the message can be deleted only for the current user while other users will continue to see it using the method deleteMessages with revoke == false
    :type can_be_deleted_only_for_self: :class:`Bool`
    :param can_be_deleted_for_all_users: True, if the message can be deleted for all users using the method deleteMessages with revoke == true
    :type can_be_deleted_for_all_users: :class:`Bool`
    :param can_be_edited: True, if the message can be edited using the methods editMessageText, editMessageCaption, or editMessageReplyMarkup. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message
    :type can_be_edited: :class:`Bool`
    :param can_be_forwarded: True, if the message can be forwarded using inputMessageForwarded or forwardMessages
    :type can_be_forwarded: :class:`Bool`
    :param can_be_paid: True, if the message can be paid using inputInvoiceMessage
    :type can_be_paid: :class:`Bool`
    :param can_be_pinned: True, if the message can be pinned or unpinned in the chat using pinChatMessage or unpinChatMessage
    :type can_be_pinned: :class:`Bool`
    :param can_be_replied: True, if the message can be replied in the same chat and forum topic using inputMessageReplyToMessage
    :type can_be_replied: :class:`Bool`
    :param can_be_replied_in_another_chat: True, if the message can be replied in another chat or forum topic using inputMessageReplyToExternalMessage
    :type can_be_replied_in_another_chat: :class:`Bool`
    :param can_be_saved: True, if content of the message can be saved locally or copied using inputMessageForwarded or forwardMessages with copy options
    :type can_be_saved: :class:`Bool`
    :param can_be_shared_in_story: True, if the message can be shared in a story using inputStoryAreaTypeMessage
    :type can_be_shared_in_story: :class:`Bool`
    :param can_edit_media: True, if the message can be edited using the method editMessageMedia
    :type can_edit_media: :class:`Bool`
    :param can_edit_scheduling_state: True, if scheduling state of the message can be edited
    :type can_edit_scheduling_state: :class:`Bool`
    :param can_get_embedding_code: True, if code for message embedding can be received using getMessageEmbeddingCode
    :type can_get_embedding_code: :class:`Bool`
    :param can_get_link: True, if a link can be generated for the message using getMessageLink
    :type can_get_link: :class:`Bool`
    :param can_get_media_timestamp_links: True, if media timestamp links can be generated for media timestamp entities in the message text, caption or link preview description using getMessageLink
    :type can_get_media_timestamp_links: :class:`Bool`
    :param can_get_message_thread: True, if information about the message thread is available through getMessageThread and getMessageThreadHistory
    :type can_get_message_thread: :class:`Bool`
    :param can_get_read_date: True, if read date of the message can be received through getMessageReadDate
    :type can_get_read_date: :class:`Bool`
    :param can_get_statistics: True, if message statistics are available through getMessageStatistics and message forwards can be received using getMessagePublicForwards
    :type can_get_statistics: :class:`Bool`
    :param can_get_viewers: True, if chat members already viewed the message can be received through getMessageViewers
    :type can_get_viewers: :class:`Bool`
    :param can_recognize_speech: True, if speech can be recognized for the message through recognizeSpeech
    :type can_recognize_speech: :class:`Bool`
    :param can_report_chat: True, if the message can be reported using reportChat
    :type can_report_chat: :class:`Bool`
    :param can_report_reactions: True, if reactions on the message can be reported through reportMessageReactions
    :type can_report_reactions: :class:`Bool`
    :param can_report_supergroup_spam: True, if the message can be reported using reportSupergroupSpam
    :type can_report_supergroup_spam: :class:`Bool`
    :param can_set_fact_check: True, if fact check for the message can be changed through setMessageFactCheck
    :type can_set_fact_check: :class:`Bool`
    :param need_show_statistics: True, if message statistics must be available from context menu of the message
    :type need_show_statistics: :class:`Bool`
    """

    ID: typing.Literal["messageProperties"] = field(default="messageProperties", metadata={"alias": "@type"})
    can_be_copied_to_secret_chat: Bool = field(default=False)
    can_be_deleted_only_for_self: Bool = field(default=False)
    can_be_deleted_for_all_users: Bool = field(default=False)
    can_be_edited: Bool = field(default=False)
    can_be_forwarded: Bool = field(default=False)
    can_be_paid: Bool = field(default=False)
    can_be_pinned: Bool = field(default=False)
    can_be_replied: Bool = field(default=False)
    can_be_replied_in_another_chat: Bool = field(default=False)
    can_be_saved: Bool = field(default=False)
    can_be_shared_in_story: Bool = field(default=False)
    can_edit_media: Bool = field(default=False)
    can_edit_scheduling_state: Bool = field(default=False)
    can_get_embedding_code: Bool = field(default=False)
    can_get_link: Bool = field(default=False)
    can_get_media_timestamp_links: Bool = field(default=False)
    can_get_message_thread: Bool = field(default=False)
    can_get_read_date: Bool = field(default=False)
    can_get_statistics: Bool = field(default=False)
    can_get_viewers: Bool = field(default=False)
    can_recognize_speech: Bool = field(default=False)
    can_report_chat: Bool = field(default=False)
    can_report_reactions: Bool = field(default=False)
    can_report_supergroup_spam: Bool = field(default=False)
    can_set_fact_check: Bool = field(default=False)
    need_show_statistics: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageReaction(BaseObject):
    """
    Contains information about a reaction to a message

    :param type_: Type of the reaction
    :type type_: :class:`ReactionType`
    :param total_count: Number of times the reaction was added
    :type total_count: :class:`Int32`
    :param recent_sender_ids: Identifiers of at most 3 recent message senders, added the reaction; available in private, basic group and supergroup chats
    :type recent_sender_ids: :class:`Vector[MessageSender]`
    :param used_sender_id: Identifier of the message sender used by the current user to add the reaction; may be null if unknown or the reaction isn't chosen, defaults to None
    :type used_sender_id: :class:`MessageSender`, optional
    :param is_chosen: True, if the reaction is chosen by the current user
    :type is_chosen: :class:`Bool`
    """

    ID: typing.Literal["messageReaction"] = field(default="messageReaction", metadata={"alias": "@type"})
    type_: ReactionType = field(default=MISSING, metadata={"alias": "type"})
    total_count: Int32
    recent_sender_ids: Vector[MessageSender]
    used_sender_id: typing.Optional[MessageSender] = field(default=None)
    is_chosen: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageReactions(BaseObject):
    """
    Contains a list of reactions added to a message

    :param reactions: List of added reactions
    :type reactions: :class:`Vector[MessageReaction]`
    :param paid_reactors: Information about top users that added the paid reaction
    :type paid_reactors: :class:`Vector[PaidReactor]`
    :param are_tags: True, if the reactions are tags and Telegram Premium users can filter messages by them
    :type are_tags: :class:`Bool`
    :param can_get_added_reactions: True, if the list of added reactions is available using getMessageAddedReactions
    :type can_get_added_reactions: :class:`Bool`
    """

    ID: typing.Literal["messageReactions"] = field(default="messageReactions", metadata={"alias": "@type"})
    reactions: Vector[MessageReaction]
    paid_reactors: Vector[PaidReactor]
    are_tags: Bool = field(default=False)
    can_get_added_reactions: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageReadDateMyPrivacyRestricted(BaseObject):
    """
    The read date is unknown due to privacy settings of the current user, but will be known if the user subscribes to Telegram Premium
    """

    ID: typing.Literal["messageReadDateMyPrivacyRestricted"] = field(
        default="messageReadDateMyPrivacyRestricted", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class MessageReadDateRead(BaseObject):
    """
    Contains read date of the message

    :param read_date: Point in time (Unix timestamp) when the message was read by the other user
    :type read_date: :class:`Int32`
    """

    ID: typing.Literal["messageReadDateRead"] = field(default="messageReadDateRead", metadata={"alias": "@type"})
    read_date: Int32


@dataclass(slots=True, kw_only=True)
class MessageReadDateTooOld(BaseObject):
    """
    The message is too old to get read date
    """

    ID: typing.Literal["messageReadDateTooOld"] = field(default="messageReadDateTooOld", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class MessageReadDateUnread(BaseObject):
    """
    The message is unread yet
    """

    ID: typing.Literal["messageReadDateUnread"] = field(default="messageReadDateUnread", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class MessageReadDateUserPrivacyRestricted(BaseObject):
    """
    The read date is unknown due to privacy settings of the other user
    """

    ID: typing.Literal["messageReadDateUserPrivacyRestricted"] = field(
        default="messageReadDateUserPrivacyRestricted", metadata={"alias": "@type"}
    )


MessageReadDate = typing.Union[
    MessageReadDateMyPrivacyRestricted,
    MessageReadDateRead,
    MessageReadDateTooOld,
    MessageReadDateUnread,
    MessageReadDateUserPrivacyRestricted,
]


@dataclass(slots=True, kw_only=True)
class MessageReplyInfo(BaseObject):
    """
    Contains information about replies to a message

    :param reply_count: Number of times the message was directly or indirectly replied
    :type reply_count: :class:`Int32`
    :param recent_replier_ids: Identifiers of at most 3 recent repliers to the message; available in channels with a discussion supergroup. The users and chats are expected to be inaccessible: only their photo and name will be available
    :type recent_replier_ids: :class:`Vector[MessageSender]`
    :param last_read_inbox_message_id: Identifier of the last read incoming reply to the message
    :type last_read_inbox_message_id: :class:`Int53`
    :param last_read_outbox_message_id: Identifier of the last read outgoing reply to the message
    :type last_read_outbox_message_id: :class:`Int53`
    :param last_message_id: Identifier of the last reply to the message
    :type last_message_id: :class:`Int53`
    """

    ID: typing.Literal["messageReplyInfo"] = field(default="messageReplyInfo", metadata={"alias": "@type"})
    reply_count: Int32
    recent_replier_ids: Vector[MessageSender]
    last_read_inbox_message_id: Int53
    last_read_outbox_message_id: Int53
    last_message_id: Int53


@dataclass(slots=True, kw_only=True)
class MessageReplyToMessage(BaseObject):
    """
    Describes a message replied by a given message

    :param quote: Chosen quote from the replied message; may be null if none, defaults to None
    :type quote: :class:`TextQuote`, optional
    :param origin: Information about origin of the message if the message was from another chat or topic; may be null for messages from the same chat, defaults to None
    :type origin: :class:`MessageOrigin`, optional
    :param content: Media content of the message if the message was from another chat or topic; may be null for messages from the same chat and messages without media. Can be only one of the following types: messageAnimation, messageAudio, messageContact, messageDice, messageDocument, messageGame, messageGiveaway, messageGiveawayWinners, messageInvoice, messageLocation, messagePaidMedia, messagePhoto, messagePoll, messageSticker, messageStory, messageText (for link preview), messageVenue, messageVideo, messageVideoNote, or messageVoiceNote, defaults to None
    :type content: :class:`MessageContent`, optional
    :param chat_id: The identifier of the chat to which the message belongs; may be 0 if the replied message is in unknown chat
    :type chat_id: :class:`Int53`
    :param message_id: The identifier of the message; may be 0 if the replied message is in unknown chat
    :type message_id: :class:`Int53`
    :param origin_send_date: Point in time (Unix timestamp) when the message was sent if the message was from another chat or topic; 0 for messages from the same chat
    :type origin_send_date: :class:`Int32`
    """

    ID: typing.Literal["messageReplyToMessage"] = field(default="messageReplyToMessage", metadata={"alias": "@type"})
    quote: typing.Optional[TextQuote] = field(default=None)
    origin: typing.Optional[MessageOrigin] = field(default=None)
    content: typing.Optional[MessageContent] = field(default=None)
    chat_id: Int53 = field(default=0)
    message_id: Int53 = field(default=0)
    origin_send_date: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class MessageReplyToStory(BaseObject):
    """
    Describes a story replied by a given message

    :param story_sender_chat_id: The identifier of the sender of the story
    :type story_sender_chat_id: :class:`Int53`
    :param story_id: The identifier of the story
    :type story_id: :class:`Int32`
    """

    ID: typing.Literal["messageReplyToStory"] = field(default="messageReplyToStory", metadata={"alias": "@type"})
    story_sender_chat_id: Int53
    story_id: Int32


MessageReplyTo = typing.Union[
    MessageReplyToMessage,
    MessageReplyToStory,
]


@dataclass(slots=True, kw_only=True)
class MessageSchedulingStateSendAtDate(BaseObject):
    """
    The message will be sent at the specified date

    :param send_date: Point in time (Unix timestamp) when the message will be sent. The date must be within 367 days in the future
    :type send_date: :class:`Int32`
    """

    ID: typing.Literal["messageSchedulingStateSendAtDate"] = field(
        default="messageSchedulingStateSendAtDate", metadata={"alias": "@type"}
    )
    send_date: Int32


@dataclass(slots=True, kw_only=True)
class MessageSchedulingStateSendWhenOnline(BaseObject):
    """
    The message will be sent when the other user is online. Applicable to private chats only and when the exact online status of the other user is known
    """

    ID: typing.Literal["messageSchedulingStateSendWhenOnline"] = field(
        default="messageSchedulingStateSendWhenOnline", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class MessageSchedulingStateSendWhenVideoProcessed(BaseObject):
    """
    The message will be sent when the video in the message is converted and optimized; can be used only by the server

    :param send_date: Approximate point in time (Unix timestamp) when the message is expected to be sent
    :type send_date: :class:`Int32`
    """

    ID: typing.Literal["messageSchedulingStateSendWhenVideoProcessed"] = field(
        default="messageSchedulingStateSendWhenVideoProcessed", metadata={"alias": "@type"}
    )
    send_date: Int32


MessageSchedulingState = typing.Union[
    MessageSchedulingStateSendAtDate,
    MessageSchedulingStateSendWhenOnline,
    MessageSchedulingStateSendWhenVideoProcessed,
]


@dataclass(slots=True, kw_only=True)
class MessageSelfDestructTypeImmediately(BaseObject):
    """
    The message can be opened only once and will be self-destructed once closed
    """

    ID: typing.Literal["messageSelfDestructTypeImmediately"] = field(
        default="messageSelfDestructTypeImmediately", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class MessageSelfDestructTypeTimer(BaseObject):
    """
    The message will be self-destructed in the specified time after its content was opened

    :param self_destruct_time: The message's self-destruct time, in seconds; must be between 0 and 60 in private chats
    :type self_destruct_time: :class:`Int32`
    """

    ID: typing.Literal["messageSelfDestructTypeTimer"] = field(
        default="messageSelfDestructTypeTimer", metadata={"alias": "@type"}
    )
    self_destruct_time: Int32


MessageSelfDestructType = typing.Union[
    MessageSelfDestructTypeImmediately,
    MessageSelfDestructTypeTimer,
]


@dataclass(slots=True, kw_only=True)
class MessageSendOptions(BaseObject):
    """
    Options to be used when a message is sent

    :param sending_id: Non-persistent identifier, which will be returned back in messageSendingStatePending object and can be used to match sent messages and corresponding updateNewMessage updates
    :type sending_id: :class:`Int32`
    :param disable_notification: Pass true to disable notification for the message
    :type disable_notification: :class:`Bool`
    :param from_background: Pass true if the message is sent from the background
    :type from_background: :class:`Bool`
    :param protect_content: Pass true if the content of the message must be protected from forwarding and saving; for bots only
    :type protect_content: :class:`Bool`
    :param allow_paid_broadcast: Pass true to allow the message to ignore regular broadcast limits for a small fee; for bots only
    :type allow_paid_broadcast: :class:`Bool`
    :param update_order_of_installed_sticker_sets: Pass true if the user explicitly chosen a sticker or a custom emoji from an installed sticker set; applicable only to sendMessage and sendMessageAlbum
    :type update_order_of_installed_sticker_sets: :class:`Bool`
    :param effect_id: Identifier of the effect to apply to the message; pass 0 if none; applicable only to sendMessage and sendMessageAlbum in private chats
    :type effect_id: :class:`Int64`
    :param only_preview: Pass true to get a fake message instead of actually sending them
    :type only_preview: :class:`Bool`
    :param scheduling_state: Message scheduling state; pass null to send message immediately. Messages sent to a secret chat, live location messages and self-destructing messages can't be scheduled, defaults to None
    :type scheduling_state: :class:`MessageSchedulingState`, optional
    """

    ID: typing.Literal["messageSendOptions"] = field(default="messageSendOptions", metadata={"alias": "@type"})
    sending_id: Int32
    disable_notification: Bool = field(default=False)
    from_background: Bool = field(default=False)
    protect_content: Bool = field(default=False)
    allow_paid_broadcast: Bool = field(default=False)
    update_order_of_installed_sticker_sets: Bool = field(default=False)
    effect_id: Int64 = field(default=0)
    only_preview: Bool = field(default=False)
    scheduling_state: typing.Optional[MessageSchedulingState] = field(default=None)


@dataclass(slots=True, kw_only=True)
class MessageSenderChat(BaseObject):
    """
    The message was sent on behalf of a chat

    :param chat_id: Identifier of the chat that sent the message
    :type chat_id: :class:`Int53`
    """

    ID: typing.Literal["messageSenderChat"] = field(default="messageSenderChat", metadata={"alias": "@type"})
    chat_id: Int53


@dataclass(slots=True, kw_only=True)
class MessageSenderUser(BaseObject):
    """
    The message was sent by a known user

    :param user_id: Identifier of the user that sent the message
    :type user_id: :class:`Int53`
    """

    ID: typing.Literal["messageSenderUser"] = field(default="messageSenderUser", metadata={"alias": "@type"})
    user_id: Int53


MessageSender = typing.Union[
    MessageSenderChat,
    MessageSenderUser,
]


@dataclass(slots=True, kw_only=True)
class MessageSenders(BaseObject):
    """
    Represents a list of message senders

    :param total_count: Approximate total number of messages senders found
    :type total_count: :class:`Int32`
    :param senders: List of message senders
    :type senders: :class:`Vector[MessageSender]`
    """

    ID: typing.Literal["messageSenders"] = field(default="messageSenders", metadata={"alias": "@type"})
    total_count: Int32
    senders: Vector[MessageSender]


@dataclass(slots=True, kw_only=True)
class MessageSendingStateFailed(BaseObject):
    """
    The message failed to be sent

    :param error: The cause of the message sending failure
    :type error: :class:`Error`
    :param retry_after: Time left before the message can be re-sent, in seconds. No update is sent when this field changes
    :type retry_after: :class:`Double`
    :param can_retry: True, if the message can be re-sent using resendMessages or readdQuickReplyShortcutMessages
    :type can_retry: :class:`Bool`
    :param need_another_sender: True, if the message can be re-sent only on behalf of a different sender
    :type need_another_sender: :class:`Bool`
    :param need_another_reply_quote: True, if the message can be re-sent only if another quote is chosen in the message that is replied by the given message
    :type need_another_reply_quote: :class:`Bool`
    :param need_drop_reply: True, if the message can be re-sent only if the message to be replied is removed. This will be done automatically by resendMessages
    :type need_drop_reply: :class:`Bool`
    """

    ID: typing.Literal["messageSendingStateFailed"] = field(
        default="messageSendingStateFailed", metadata={"alias": "@type"}
    )
    error: Error
    retry_after: Double
    can_retry: Bool = field(default=False)
    need_another_sender: Bool = field(default=False)
    need_another_reply_quote: Bool = field(default=False)
    need_drop_reply: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class MessageSendingStatePending(BaseObject):
    """
    The message is being sent now, but has not yet been delivered to the server

    :param sending_id: Non-persistent message sending identifier, specified by the application
    :type sending_id: :class:`Int32`
    """

    ID: typing.Literal["messageSendingStatePending"] = field(
        default="messageSendingStatePending", metadata={"alias": "@type"}
    )
    sending_id: Int32


MessageSendingState = typing.Union[
    MessageSendingStateFailed,
    MessageSendingStatePending,
]


@dataclass(slots=True, kw_only=True)
class MessageSourceChatEventLog(BaseObject):
    """
    The message is from a chat event log
    """

    ID: typing.Literal["messageSourceChatEventLog"] = field(
        default="messageSourceChatEventLog", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class MessageSourceChatHistory(BaseObject):
    """
    The message is from a chat history
    """

    ID: typing.Literal["messageSourceChatHistory"] = field(
        default="messageSourceChatHistory", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class MessageSourceChatList(BaseObject):
    """
    The message is from a chat list or a forum topic list
    """

    ID: typing.Literal["messageSourceChatList"] = field(default="messageSourceChatList", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class MessageSourceForumTopicHistory(BaseObject):
    """
    The message is from a forum topic history
    """

    ID: typing.Literal["messageSourceForumTopicHistory"] = field(
        default="messageSourceForumTopicHistory", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class MessageSourceHistoryPreview(BaseObject):
    """
    The message is from chat, message thread or forum topic history preview
    """

    ID: typing.Literal["messageSourceHistoryPreview"] = field(
        default="messageSourceHistoryPreview", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class MessageSourceMessageThreadHistory(BaseObject):
    """
    The message is from a message thread history
    """

    ID: typing.Literal["messageSourceMessageThreadHistory"] = field(
        default="messageSourceMessageThreadHistory", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class MessageSourceNotification(BaseObject):
    """
    The message is from a notification
    """

    ID: typing.Literal["messageSourceNotification"] = field(
        default="messageSourceNotification", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class MessageSourceOther(BaseObject):
    """
    The message is from some other source
    """

    ID: typing.Literal["messageSourceOther"] = field(default="messageSourceOther", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class MessageSourceScreenshot(BaseObject):
    """
    The message was screenshotted; the source must be used only if the message content was visible during the screenshot
    """

    ID: typing.Literal["messageSourceScreenshot"] = field(
        default="messageSourceScreenshot", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class MessageSourceSearch(BaseObject):
    """
    The message is from search results, including file downloads, local file list, outgoing document messages, calendar
    """

    ID: typing.Literal["messageSourceSearch"] = field(default="messageSourceSearch", metadata={"alias": "@type"})


MessageSource = typing.Union[
    MessageSourceChatEventLog,
    MessageSourceChatHistory,
    MessageSourceChatList,
    MessageSourceForumTopicHistory,
    MessageSourceHistoryPreview,
    MessageSourceMessageThreadHistory,
    MessageSourceNotification,
    MessageSourceOther,
    MessageSourceScreenshot,
    MessageSourceSearch,
]


@dataclass(slots=True, kw_only=True)
class MessageSponsor(BaseObject):
    """
    Information about the sponsor of a message

    :param url: URL of the sponsor to be opened when the message is clicked
    :type url: :class:`String`
    :param info: Additional optional information about the sponsor to be shown along with the message
    :type info: :class:`String`
    :param photo: Photo of the sponsor; may be null if must not be shown, defaults to None
    :type photo: :class:`Photo`, optional
    """

    ID: typing.Literal["messageSponsor"] = field(default="messageSponsor", metadata={"alias": "@type"})
    url: String
    info: String
    photo: typing.Optional[Photo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class MessageStatistics(BaseObject):
    """
    A detailed statistics about a message

    :param message_interaction_graph: A graph containing number of message views and shares
    :type message_interaction_graph: :class:`StatisticalGraph`
    :param message_reaction_graph: A graph containing number of message reactions
    :type message_reaction_graph: :class:`StatisticalGraph`
    """

    ID: typing.Literal["messageStatistics"] = field(default="messageStatistics", metadata={"alias": "@type"})
    message_interaction_graph: StatisticalGraph
    message_reaction_graph: StatisticalGraph


@dataclass(slots=True, kw_only=True)
class MessageThreadInfo(BaseObject):
    """
    Contains information about a message thread

    :param chat_id: Identifier of the chat to which the message thread belongs
    :type chat_id: :class:`Int53`
    :param message_thread_id: Message thread identifier, unique within the chat
    :type message_thread_id: :class:`Int53`
    :param unread_message_count: Approximate number of unread messages in the message thread
    :type unread_message_count: :class:`Int32`
    :param messages: The messages from which the thread starts. The messages are returned in reverse chronological order (i.e., in order of decreasing message_id)
    :type messages: :class:`Vector[Message]`
    :param reply_info: Information about the message thread; may be null for forum topic threads, defaults to None
    :type reply_info: :class:`MessageReplyInfo`, optional
    :param draft_message: A draft of a message in the message thread; may be null if none, defaults to None
    :type draft_message: :class:`DraftMessage`, optional
    """

    ID: typing.Literal["messageThreadInfo"] = field(default="messageThreadInfo", metadata={"alias": "@type"})
    chat_id: Int53
    message_thread_id: Int53
    unread_message_count: Int32
    messages: Vector[Message]
    reply_info: typing.Optional[MessageReplyInfo] = field(default=None)
    draft_message: typing.Optional[DraftMessage] = field(default=None)


@dataclass(slots=True, kw_only=True)
class MessageViewer(BaseObject):
    """
    Represents a viewer of a message

    :param user_id: User identifier of the viewer
    :type user_id: :class:`Int53`
    :param view_date: Approximate point in time (Unix timestamp) when the message was viewed
    :type view_date: :class:`Int32`
    """

    ID: typing.Literal["messageViewer"] = field(default="messageViewer", metadata={"alias": "@type"})
    user_id: Int53
    view_date: Int32


@dataclass(slots=True, kw_only=True)
class MessageViewers(BaseObject):
    """
    Represents a list of message viewers

    :param viewers: List of message viewers
    :type viewers: :class:`Vector[MessageViewer]`
    """

    ID: typing.Literal["messageViewers"] = field(default="messageViewers", metadata={"alias": "@type"})
    viewers: Vector[MessageViewer]


@dataclass(slots=True, kw_only=True)
class Messages(BaseObject):
    """
    Contains a list of messages

    :param total_count: Approximate total number of messages found
    :type total_count: :class:`Int32`
    :param messages: List of messages; messages may be null, defaults to None
    :type messages: :class:`Vector[Message]`, optional
    """

    ID: typing.Literal["messages"] = field(default="messages", metadata={"alias": "@type"})
    total_count: Int32
    messages: Vector[typing.Optional[Message]] = field(default=None)


@dataclass(slots=True, kw_only=True)
class Minithumbnail(BaseObject):
    """
    Thumbnail image of a very poor quality and low resolution

    :param width: Thumbnail width, usually doesn't exceed 40
    :type width: :class:`Int32`
    :param height: Thumbnail height, usually doesn't exceed 40
    :type height: :class:`Int32`
    :param data: The thumbnail in JPEG format
    :type data: :class:`Bytes`
    """

    ID: typing.Literal["minithumbnail"] = field(default="minithumbnail", metadata={"alias": "@type"})
    width: Int32
    height: Int32
    data: Bytes


@dataclass(slots=True, kw_only=True)
class NetworkStatistics(BaseObject):
    """
    A full list of available network statistic entries

    :param since_date: Point in time (Unix timestamp) from which the statistics are collected
    :type since_date: :class:`Int32`
    :param entries: Network statistics entries
    :type entries: :class:`Vector[NetworkStatisticsEntry]`
    """

    ID: typing.Literal["networkStatistics"] = field(default="networkStatistics", metadata={"alias": "@type"})
    since_date: Int32
    entries: Vector[NetworkStatisticsEntry]


@dataclass(slots=True, kw_only=True)
class NetworkStatisticsEntryCall(BaseObject):
    """
    Contains information about the total amount of data that was used for calls

    :param network_type: Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
    :type network_type: :class:`NetworkType`
    :param sent_bytes: Total number of bytes sent
    :type sent_bytes: :class:`Int53`
    :param received_bytes: Total number of bytes received
    :type received_bytes: :class:`Int53`
    :param duration: Total call duration, in seconds
    :type duration: :class:`Double`
    """

    ID: typing.Literal["networkStatisticsEntryCall"] = field(
        default="networkStatisticsEntryCall", metadata={"alias": "@type"}
    )
    network_type: NetworkType
    sent_bytes: Int53
    received_bytes: Int53
    duration: Double


@dataclass(slots=True, kw_only=True)
class NetworkStatisticsEntryFile(BaseObject):
    """
    Contains information about the total amount of data that was used to send and receive files

    :param network_type: Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
    :type network_type: :class:`NetworkType`
    :param sent_bytes: Total number of bytes sent
    :type sent_bytes: :class:`Int53`
    :param received_bytes: Total number of bytes received
    :type received_bytes: :class:`Int53`
    :param file_type: Type of the file the data is part of; pass null if the data isn't related to files, defaults to None
    :type file_type: :class:`FileType`, optional
    """

    ID: typing.Literal["networkStatisticsEntryFile"] = field(
        default="networkStatisticsEntryFile", metadata={"alias": "@type"}
    )
    network_type: NetworkType
    sent_bytes: Int53
    received_bytes: Int53
    file_type: typing.Optional[FileType] = field(default=None)


NetworkStatisticsEntry = typing.Union[
    NetworkStatisticsEntryCall,
    NetworkStatisticsEntryFile,
]


@dataclass(slots=True, kw_only=True)
class NetworkTypeMobile(BaseObject):
    """
    A mobile network
    """

    ID: typing.Literal["networkTypeMobile"] = field(default="networkTypeMobile", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class NetworkTypeMobileRoaming(BaseObject):
    """
    A mobile roaming network
    """

    ID: typing.Literal["networkTypeMobileRoaming"] = field(
        default="networkTypeMobileRoaming", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class NetworkTypeNone(BaseObject):
    """
    The network is not available
    """

    ID: typing.Literal["networkTypeNone"] = field(default="networkTypeNone", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class NetworkTypeOther(BaseObject):
    """
    A different network type (e.g., Ethernet network)
    """

    ID: typing.Literal["networkTypeOther"] = field(default="networkTypeOther", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class NetworkTypeWiFi(BaseObject):
    """
    A Wi-Fi network
    """

    ID: typing.Literal["networkTypeWiFi"] = field(default="networkTypeWiFi", metadata={"alias": "@type"})


NetworkType = typing.Union[
    NetworkTypeMobile,
    NetworkTypeMobileRoaming,
    NetworkTypeNone,
    NetworkTypeOther,
    NetworkTypeWiFi,
]


@dataclass(slots=True, kw_only=True)
class NewChatPrivacySettings(BaseObject):
    """
    Contains privacy settings for new chats with non-contacts

    :param allow_new_chats_from_unknown_users: True, if non-contacts users are able to write first to the current user. Telegram Premium subscribers are able to write first regardless of this setting
    :type allow_new_chats_from_unknown_users: :class:`Bool`
    """

    ID: typing.Literal["newChatPrivacySettings"] = field(default="newChatPrivacySettings", metadata={"alias": "@type"})
    allow_new_chats_from_unknown_users: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class Notification(BaseObject):
    """
    Contains information about a notification

    :param id: Unique persistent identifier of this notification
    :type id: :class:`Int32`
    :param date: Notification date
    :type date: :class:`Int32`
    :param type_: Notification type
    :type type_: :class:`NotificationType`
    :param is_silent: True, if the notification was explicitly sent without sound
    :type is_silent: :class:`Bool`
    """

    ID: typing.Literal["notification"] = field(default="notification", metadata={"alias": "@type"})
    id: Int32
    date: Int32
    type_: NotificationType = field(default=MISSING, metadata={"alias": "type"})
    is_silent: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class NotificationGroup(BaseObject):
    """
    Describes a group of notifications

    :param id: Unique persistent auto-incremented from 1 identifier of the notification group
    :type id: :class:`Int32`
    :param type_: Type of the group
    :type type_: :class:`NotificationGroupType`
    :param chat_id: Identifier of a chat to which all notifications in the group belong
    :type chat_id: :class:`Int53`
    :param total_count: Total number of active notifications in the group
    :type total_count: :class:`Int32`
    :param notifications: The list of active notifications
    :type notifications: :class:`Vector[Notification]`
    """

    ID: typing.Literal["notificationGroup"] = field(default="notificationGroup", metadata={"alias": "@type"})
    id: Int32
    type_: NotificationGroupType = field(default=MISSING, metadata={"alias": "type"})
    chat_id: Int53
    total_count: Int32
    notifications: Vector[Notification]


@dataclass(slots=True, kw_only=True)
class NotificationGroupTypeCalls(BaseObject):
    """
    A group containing notifications of type notificationTypeNewCall
    """

    ID: typing.Literal["notificationGroupTypeCalls"] = field(
        default="notificationGroupTypeCalls", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class NotificationGroupTypeMentions(BaseObject):
    """
    A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with unread mentions of the current user, replies to their messages, or a pinned message
    """

    ID: typing.Literal["notificationGroupTypeMentions"] = field(
        default="notificationGroupTypeMentions", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class NotificationGroupTypeMessages(BaseObject):
    """
    A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with ordinary unread messages
    """

    ID: typing.Literal["notificationGroupTypeMessages"] = field(
        default="notificationGroupTypeMessages", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class NotificationGroupTypeSecretChat(BaseObject):
    """
    A group containing a notification of type notificationTypeNewSecretChat
    """

    ID: typing.Literal["notificationGroupTypeSecretChat"] = field(
        default="notificationGroupTypeSecretChat", metadata={"alias": "@type"}
    )


NotificationGroupType = typing.Union[
    NotificationGroupTypeCalls,
    NotificationGroupTypeMentions,
    NotificationGroupTypeMessages,
    NotificationGroupTypeSecretChat,
]


@dataclass(slots=True, kw_only=True)
class NotificationSettingsScopeChannelChats(BaseObject):
    """
    Notification settings applied to all channel chats when the corresponding chat setting has a default value
    """

    ID: typing.Literal["notificationSettingsScopeChannelChats"] = field(
        default="notificationSettingsScopeChannelChats", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class NotificationSettingsScopeGroupChats(BaseObject):
    """
    Notification settings applied to all basic group and supergroup chats when the corresponding chat setting has a default value
    """

    ID: typing.Literal["notificationSettingsScopeGroupChats"] = field(
        default="notificationSettingsScopeGroupChats", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class NotificationSettingsScopePrivateChats(BaseObject):
    """
    Notification settings applied to all private and secret chats when the corresponding chat setting has a default value
    """

    ID: typing.Literal["notificationSettingsScopePrivateChats"] = field(
        default="notificationSettingsScopePrivateChats", metadata={"alias": "@type"}
    )


NotificationSettingsScope = typing.Union[
    NotificationSettingsScopeChannelChats,
    NotificationSettingsScopeGroupChats,
    NotificationSettingsScopePrivateChats,
]


@dataclass(slots=True, kw_only=True)
class NotificationSound(BaseObject):
    """
    Describes a notification sound in MP3 format

    :param id: Unique identifier of the notification sound
    :type id: :class:`Int64`
    :param duration: Duration of the sound, in seconds
    :type duration: :class:`Int32`
    :param date: Point in time (Unix timestamp) when the sound was created
    :type date: :class:`Int32`
    :param title: Title of the notification sound
    :type title: :class:`String`
    :param data: Arbitrary data, defined while the sound was uploaded
    :type data: :class:`String`
    :param sound: File containing the sound
    :type sound: :class:`File`
    """

    ID: typing.Literal["notificationSound"] = field(default="notificationSound", metadata={"alias": "@type"})
    id: Int64
    duration: Int32
    date: Int32
    title: String
    data: String
    sound: File


@dataclass(slots=True, kw_only=True)
class NotificationSounds(BaseObject):
    """
    Contains a list of notification sounds

    :param notification_sounds: A list of notification sounds
    :type notification_sounds: :class:`Vector[NotificationSound]`
    """

    ID: typing.Literal["notificationSounds"] = field(default="notificationSounds", metadata={"alias": "@type"})
    notification_sounds: Vector[NotificationSound]


@dataclass(slots=True, kw_only=True)
class NotificationTypeNewCall(BaseObject):
    """
    New call was received

    :param call_id: Call identifier
    :type call_id: :class:`Int32`
    """

    ID: typing.Literal["notificationTypeNewCall"] = field(
        default="notificationTypeNewCall", metadata={"alias": "@type"}
    )
    call_id: Int32


@dataclass(slots=True, kw_only=True)
class NotificationTypeNewMessage(BaseObject):
    """
    New message was received

    :param message: The message
    :type message: :class:`Message`
    :param show_preview: True, if message content must be displayed in notifications
    :type show_preview: :class:`Bool`
    """

    ID: typing.Literal["notificationTypeNewMessage"] = field(
        default="notificationTypeNewMessage", metadata={"alias": "@type"}
    )
    message: Message
    show_preview: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class NotificationTypeNewPushMessage(BaseObject):
    """
    New message was received through a push notification

    :param message_id: The message identifier. The message will not be available in the chat history, but the identifier can be used in viewMessages, or as a message to be replied in the same chat
    :type message_id: :class:`Int53`
    :param sender_id: Identifier of the sender of the message. Corresponding user or chat may be inaccessible
    :type sender_id: :class:`MessageSender`
    :param sender_name: Name of the sender
    :type sender_name: :class:`String`
    :param content: Push message content
    :type content: :class:`PushMessageContent`
    :param is_outgoing: True, if the message is outgoing
    :type is_outgoing: :class:`Bool`
    """

    ID: typing.Literal["notificationTypeNewPushMessage"] = field(
        default="notificationTypeNewPushMessage", metadata={"alias": "@type"}
    )
    message_id: Int53
    sender_id: MessageSender
    sender_name: String
    content: PushMessageContent
    is_outgoing: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class NotificationTypeNewSecretChat(BaseObject):
    """
    New secret chat was created
    """

    ID: typing.Literal["notificationTypeNewSecretChat"] = field(
        default="notificationTypeNewSecretChat", metadata={"alias": "@type"}
    )


NotificationType = typing.Union[
    NotificationTypeNewCall,
    NotificationTypeNewMessage,
    NotificationTypeNewPushMessage,
    NotificationTypeNewSecretChat,
]


@dataclass(slots=True, kw_only=True)
class Ok(BaseObject):
    """
    An object of this type is returned on a successful function call for certain functions
    """

    ID: typing.Literal["ok"] = field(default="ok", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class OptionValueBoolean(BaseObject):
    """
    Represents a boolean option

    :param value: The value of the option
    :type value: :class:`Bool`
    """

    ID: typing.Literal["optionValueBoolean"] = field(default="optionValueBoolean", metadata={"alias": "@type"})
    value: Bool


@dataclass(slots=True, kw_only=True)
class OptionValueEmpty(BaseObject):
    """
    Represents an unknown option or an option which has a default value
    """

    ID: typing.Literal["optionValueEmpty"] = field(default="optionValueEmpty", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class OptionValueInteger(BaseObject):
    """
    Represents an integer option

    :param value: The value of the option
    :type value: :class:`Int64`
    """

    ID: typing.Literal["optionValueInteger"] = field(default="optionValueInteger", metadata={"alias": "@type"})
    value: Int64


@dataclass(slots=True, kw_only=True)
class OptionValueString(BaseObject):
    """
    Represents a string option

    :param value: The value of the option
    :type value: :class:`String`
    """

    ID: typing.Literal["optionValueString"] = field(default="optionValueString", metadata={"alias": "@type"})
    value: String


OptionValue = typing.Union[
    OptionValueBoolean,
    OptionValueEmpty,
    OptionValueInteger,
    OptionValueString,
]


@dataclass(slots=True, kw_only=True)
class OrderInfo(BaseObject):
    """
    Order information

    :param name: Name of the user
    :type name: :class:`String`
    :param phone_number: Phone number of the user
    :type phone_number: :class:`String`
    :param email_address: Email address of the user
    :type email_address: :class:`String`
    :param shipping_address: Shipping address for this order; may be null, defaults to None
    :type shipping_address: :class:`Address`, optional
    """

    ID: typing.Literal["orderInfo"] = field(default="orderInfo", metadata={"alias": "@type"})
    name: String
    phone_number: String
    email_address: String
    shipping_address: typing.Optional[Address] = field(default=None)


@dataclass(slots=True, kw_only=True)
class Outline(BaseObject):
    """
    Represents outline of an image

    :param paths: The list of closed vector paths
    :type paths: :class:`Vector[ClosedVectorPath]`
    """

    ID: typing.Literal["outline"] = field(default="outline", metadata={"alias": "@type"})
    paths: Vector[ClosedVectorPath]


@dataclass(slots=True, kw_only=True)
class PageBlockAnchor(BaseObject):
    """
    An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor

    :param name: Name of the anchor
    :type name: :class:`String`
    """

    ID: typing.Literal["pageBlockAnchor"] = field(default="pageBlockAnchor", metadata={"alias": "@type"})
    name: String


@dataclass(slots=True, kw_only=True)
class PageBlockAnimation(BaseObject):
    """
    An animation

    :param caption: Animation caption
    :type caption: :class:`PageBlockCaption`
    :param animation: Animation file; may be null, defaults to None
    :type animation: :class:`Animation`, optional
    :param need_autoplay: True, if the animation must be played automatically
    :type need_autoplay: :class:`Bool`
    """

    ID: typing.Literal["pageBlockAnimation"] = field(default="pageBlockAnimation", metadata={"alias": "@type"})
    caption: PageBlockCaption
    animation: typing.Optional[Animation] = field(default=None)
    need_autoplay: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PageBlockAudio(BaseObject):
    """
    An audio file

    :param caption: Audio file caption
    :type caption: :class:`PageBlockCaption`
    :param audio: Audio file; may be null, defaults to None
    :type audio: :class:`Audio`, optional
    """

    ID: typing.Literal["pageBlockAudio"] = field(default="pageBlockAudio", metadata={"alias": "@type"})
    caption: PageBlockCaption
    audio: typing.Optional[Audio] = field(default=None)


@dataclass(slots=True, kw_only=True)
class PageBlockAuthorDate(BaseObject):
    """
    The author and publishing date of a page

    :param author: Author
    :type author: :class:`RichText`
    :param publish_date: Point in time (Unix timestamp) when the article was published; 0 if unknown, defaults to None
    :type publish_date: :class:`Int32`, optional
    """

    ID: typing.Literal["pageBlockAuthorDate"] = field(default="pageBlockAuthorDate", metadata={"alias": "@type"})
    author: RichText
    publish_date: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class PageBlockBlockQuote(BaseObject):
    """
    A block quote

    :param text: Quote text
    :type text: :class:`RichText`
    :param credit: Quote credit
    :type credit: :class:`RichText`
    """

    ID: typing.Literal["pageBlockBlockQuote"] = field(default="pageBlockBlockQuote", metadata={"alias": "@type"})
    text: RichText
    credit: RichText


@dataclass(slots=True, kw_only=True)
class PageBlockChatLink(BaseObject):
    """
    A link to a chat

    :param title: Chat title
    :type title: :class:`String`
    :param accent_color_id: Identifier of the accent color for chat title and background of chat photo
    :type accent_color_id: :class:`Int32`
    :param username: Chat username by which all other information about the chat can be resolved
    :type username: :class:`String`
    :param photo: Chat photo; may be null, defaults to None
    :type photo: :class:`ChatPhotoInfo`, optional
    """

    ID: typing.Literal["pageBlockChatLink"] = field(default="pageBlockChatLink", metadata={"alias": "@type"})
    title: String
    accent_color_id: Int32
    username: String
    photo: typing.Optional[ChatPhotoInfo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class PageBlockCollage(BaseObject):
    """
    A collage

    :param page_blocks: Collage item contents
    :type page_blocks: :class:`Vector[PageBlock]`
    :param caption: Block caption
    :type caption: :class:`PageBlockCaption`
    """

    ID: typing.Literal["pageBlockCollage"] = field(default="pageBlockCollage", metadata={"alias": "@type"})
    page_blocks: Vector[PageBlock]
    caption: PageBlockCaption


@dataclass(slots=True, kw_only=True)
class PageBlockCover(BaseObject):
    """
    A page cover

    :param cover: Cover
    :type cover: :class:`PageBlock`
    """

    ID: typing.Literal["pageBlockCover"] = field(default="pageBlockCover", metadata={"alias": "@type"})
    cover: PageBlock


@dataclass(slots=True, kw_only=True)
class PageBlockDetails(BaseObject):
    """
    A collapsible block

    :param header: Always visible heading for the block
    :type header: :class:`RichText`
    :param page_blocks: Block contents
    :type page_blocks: :class:`Vector[PageBlock]`
    :param is_open: True, if the block is open by default
    :type is_open: :class:`Bool`
    """

    ID: typing.Literal["pageBlockDetails"] = field(default="pageBlockDetails", metadata={"alias": "@type"})
    header: RichText
    page_blocks: Vector[PageBlock]
    is_open: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PageBlockDivider(BaseObject):
    """
    An empty block separating a page
    """

    ID: typing.Literal["pageBlockDivider"] = field(default="pageBlockDivider", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class PageBlockEmbedded(BaseObject):
    """
    An embedded web page

    :param url: URL of the embedded page, if available
    :type url: :class:`String`
    :param html: HTML-markup of the embedded page
    :type html: :class:`String`
    :param caption: Block caption
    :type caption: :class:`PageBlockCaption`
    :param poster_photo: Poster photo, if available; may be null, defaults to None
    :type poster_photo: :class:`Photo`, optional
    :param is_full_width: True, if the block must be full width
    :type is_full_width: :class:`Bool`
    :param allow_scrolling: True, if scrolling needs to be allowed
    :type allow_scrolling: :class:`Bool`
    :param width: Block width; 0 if unknown, defaults to None
    :type width: :class:`Int32`, optional
    :param height: Block height; 0 if unknown, defaults to None
    :type height: :class:`Int32`, optional
    """

    ID: typing.Literal["pageBlockEmbedded"] = field(default="pageBlockEmbedded", metadata={"alias": "@type"})
    url: String
    html: String
    caption: PageBlockCaption
    poster_photo: typing.Optional[Photo] = field(default=None)
    is_full_width: Bool = field(default=False)
    allow_scrolling: Bool = field(default=False)
    width: typing.Optional[Int32] = field(default=0)
    height: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class PageBlockEmbeddedPost(BaseObject):
    """
    An embedded post

    :param url: URL of the embedded post
    :type url: :class:`String`
    :param author: Post author
    :type author: :class:`String`
    :param page_blocks: Post content
    :type page_blocks: :class:`Vector[PageBlock]`
    :param caption: Post caption
    :type caption: :class:`PageBlockCaption`
    :param author_photo: Post author photo; may be null, defaults to None
    :type author_photo: :class:`Photo`, optional
    :param date: Point in time (Unix timestamp) when the post was created; 0 if unknown, defaults to None
    :type date: :class:`Int32`, optional
    """

    ID: typing.Literal["pageBlockEmbeddedPost"] = field(default="pageBlockEmbeddedPost", metadata={"alias": "@type"})
    url: String
    author: String
    page_blocks: Vector[PageBlock]
    caption: PageBlockCaption
    author_photo: typing.Optional[Photo] = field(default=None)
    date: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class PageBlockFooter(BaseObject):
    """
    The footer of a page

    :param footer: Footer
    :type footer: :class:`RichText`
    """

    ID: typing.Literal["pageBlockFooter"] = field(default="pageBlockFooter", metadata={"alias": "@type"})
    footer: RichText


@dataclass(slots=True, kw_only=True)
class PageBlockHeader(BaseObject):
    """
    A header

    :param header: Header
    :type header: :class:`RichText`
    """

    ID: typing.Literal["pageBlockHeader"] = field(default="pageBlockHeader", metadata={"alias": "@type"})
    header: RichText


@dataclass(slots=True, kw_only=True)
class PageBlockKicker(BaseObject):
    """
    A kicker

    :param kicker: Kicker
    :type kicker: :class:`RichText`
    """

    ID: typing.Literal["pageBlockKicker"] = field(default="pageBlockKicker", metadata={"alias": "@type"})
    kicker: RichText


@dataclass(slots=True, kw_only=True)
class PageBlockList(BaseObject):
    """
    A list of data blocks

    :param items: The items of the list
    :type items: :class:`Vector[PageBlockListItem]`
    """

    ID: typing.Literal["pageBlockList"] = field(default="pageBlockList", metadata={"alias": "@type"})
    items: Vector[PageBlockListItem]


@dataclass(slots=True, kw_only=True)
class PageBlockMap(BaseObject):
    """
    A map

    :param location: Location of the map center
    :type location: :class:`Location`
    :param zoom: Map zoom level
    :type zoom: :class:`Int32`
    :param width: Map width
    :type width: :class:`Int32`
    :param height: Map height
    :type height: :class:`Int32`
    :param caption: Block caption
    :type caption: :class:`PageBlockCaption`
    """

    ID: typing.Literal["pageBlockMap"] = field(default="pageBlockMap", metadata={"alias": "@type"})
    location: Location
    zoom: Int32
    width: Int32
    height: Int32
    caption: PageBlockCaption


@dataclass(slots=True, kw_only=True)
class PageBlockParagraph(BaseObject):
    """
    A text paragraph

    :param text: Paragraph text
    :type text: :class:`RichText`
    """

    ID: typing.Literal["pageBlockParagraph"] = field(default="pageBlockParagraph", metadata={"alias": "@type"})
    text: RichText


@dataclass(slots=True, kw_only=True)
class PageBlockPhoto(BaseObject):
    """
    A photo

    :param caption: Photo caption
    :type caption: :class:`PageBlockCaption`
    :param url: URL that needs to be opened when the photo is clicked
    :type url: :class:`String`
    :param photo: Photo file; may be null, defaults to None
    :type photo: :class:`Photo`, optional
    """

    ID: typing.Literal["pageBlockPhoto"] = field(default="pageBlockPhoto", metadata={"alias": "@type"})
    caption: PageBlockCaption
    url: String
    photo: typing.Optional[Photo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class PageBlockPreformatted(BaseObject):
    """
    A preformatted text paragraph

    :param text: Paragraph text
    :type text: :class:`RichText`
    :param language: Programming language for which the text needs to be formatted
    :type language: :class:`String`
    """

    ID: typing.Literal["pageBlockPreformatted"] = field(default="pageBlockPreformatted", metadata={"alias": "@type"})
    text: RichText
    language: String


@dataclass(slots=True, kw_only=True)
class PageBlockPullQuote(BaseObject):
    """
    A pull quote

    :param text: Quote text
    :type text: :class:`RichText`
    :param credit: Quote credit
    :type credit: :class:`RichText`
    """

    ID: typing.Literal["pageBlockPullQuote"] = field(default="pageBlockPullQuote", metadata={"alias": "@type"})
    text: RichText
    credit: RichText


@dataclass(slots=True, kw_only=True)
class PageBlockRelatedArticles(BaseObject):
    """
    Related articles

    :param header: Block header
    :type header: :class:`RichText`
    :param articles: List of related articles
    :type articles: :class:`Vector[PageBlockRelatedArticle]`
    """

    ID: typing.Literal["pageBlockRelatedArticles"] = field(
        default="pageBlockRelatedArticles", metadata={"alias": "@type"}
    )
    header: RichText
    articles: Vector[PageBlockRelatedArticle]


@dataclass(slots=True, kw_only=True)
class PageBlockSlideshow(BaseObject):
    """
    A slideshow

    :param page_blocks: Slideshow item contents
    :type page_blocks: :class:`Vector[PageBlock]`
    :param caption: Block caption
    :type caption: :class:`PageBlockCaption`
    """

    ID: typing.Literal["pageBlockSlideshow"] = field(default="pageBlockSlideshow", metadata={"alias": "@type"})
    page_blocks: Vector[PageBlock]
    caption: PageBlockCaption


@dataclass(slots=True, kw_only=True)
class PageBlockSubheader(BaseObject):
    """
    A subheader

    :param subheader: Subheader
    :type subheader: :class:`RichText`
    """

    ID: typing.Literal["pageBlockSubheader"] = field(default="pageBlockSubheader", metadata={"alias": "@type"})
    subheader: RichText


@dataclass(slots=True, kw_only=True)
class PageBlockSubtitle(BaseObject):
    """
    The subtitle of a page

    :param subtitle: Subtitle
    :type subtitle: :class:`RichText`
    """

    ID: typing.Literal["pageBlockSubtitle"] = field(default="pageBlockSubtitle", metadata={"alias": "@type"})
    subtitle: RichText


@dataclass(slots=True, kw_only=True)
class PageBlockTable(BaseObject):
    """
    A table

    :param caption: Table caption
    :type caption: :class:`RichText`
    :param cells: Table cells
    :type cells: :class:`Vector[Vector[PageBlockTableCell]]`
    :param is_bordered: True, if the table is bordered
    :type is_bordered: :class:`Bool`
    :param is_striped: True, if the table is striped
    :type is_striped: :class:`Bool`
    """

    ID: typing.Literal["pageBlockTable"] = field(default="pageBlockTable", metadata={"alias": "@type"})
    caption: RichText
    cells: Vector[Vector[PageBlockTableCell]]
    is_bordered: Bool = field(default=False)
    is_striped: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PageBlockTitle(BaseObject):
    """
    The title of a page

    :param title: Title
    :type title: :class:`RichText`
    """

    ID: typing.Literal["pageBlockTitle"] = field(default="pageBlockTitle", metadata={"alias": "@type"})
    title: RichText


@dataclass(slots=True, kw_only=True)
class PageBlockVideo(BaseObject):
    """
    A video

    :param caption: Video caption
    :type caption: :class:`PageBlockCaption`
    :param video: Video file; may be null, defaults to None
    :type video: :class:`Video`, optional
    :param need_autoplay: True, if the video must be played automatically
    :type need_autoplay: :class:`Bool`
    :param is_looped: True, if the video must be looped
    :type is_looped: :class:`Bool`
    """

    ID: typing.Literal["pageBlockVideo"] = field(default="pageBlockVideo", metadata={"alias": "@type"})
    caption: PageBlockCaption
    video: typing.Optional[Video] = field(default=None)
    need_autoplay: Bool = field(default=False)
    is_looped: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PageBlockVoiceNote(BaseObject):
    """
    A voice note

    :param caption: Voice note caption
    :type caption: :class:`PageBlockCaption`
    :param voice_note: Voice note; may be null, defaults to None
    :type voice_note: :class:`VoiceNote`, optional
    """

    ID: typing.Literal["pageBlockVoiceNote"] = field(default="pageBlockVoiceNote", metadata={"alias": "@type"})
    caption: PageBlockCaption
    voice_note: typing.Optional[VoiceNote] = field(default=None)


PageBlock = typing.Union[
    PageBlockAnchor,
    PageBlockAnimation,
    PageBlockAudio,
    PageBlockAuthorDate,
    PageBlockBlockQuote,
    PageBlockChatLink,
    PageBlockCollage,
    PageBlockCover,
    PageBlockDetails,
    PageBlockDivider,
    PageBlockEmbedded,
    PageBlockEmbeddedPost,
    PageBlockFooter,
    PageBlockHeader,
    PageBlockKicker,
    PageBlockList,
    PageBlockMap,
    PageBlockParagraph,
    PageBlockPhoto,
    PageBlockPreformatted,
    PageBlockPullQuote,
    PageBlockRelatedArticles,
    PageBlockSlideshow,
    PageBlockSubheader,
    PageBlockSubtitle,
    PageBlockTable,
    PageBlockTitle,
    PageBlockVideo,
    PageBlockVoiceNote,
]


@dataclass(slots=True, kw_only=True)
class PageBlockListItem(BaseObject):
    """
    Describes an item of a list page block

    :param label: Item label
    :type label: :class:`String`
    :param page_blocks: Item blocks
    :type page_blocks: :class:`Vector[PageBlock]`
    """

    ID: typing.Literal["pageBlockListItem"] = field(default="pageBlockListItem", metadata={"alias": "@type"})
    label: String
    page_blocks: Vector[PageBlock]


@dataclass(slots=True, kw_only=True)
class PageBlockCaption(BaseObject):
    """
    Contains a caption of another block

    :param text: Content of the caption
    :type text: :class:`RichText`
    :param credit: Block credit (like HTML tag <cite>)
    :type credit: :class:`RichText`
    """

    ID: typing.Literal["pageBlockCaption"] = field(default="pageBlockCaption", metadata={"alias": "@type"})
    text: RichText
    credit: RichText


@dataclass(slots=True, kw_only=True)
class PageBlockHorizontalAlignmentCenter(BaseObject):
    """
    The content must be center-aligned
    """

    ID: typing.Literal["pageBlockHorizontalAlignmentCenter"] = field(
        default="pageBlockHorizontalAlignmentCenter", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PageBlockHorizontalAlignmentLeft(BaseObject):
    """
    The content must be left-aligned
    """

    ID: typing.Literal["pageBlockHorizontalAlignmentLeft"] = field(
        default="pageBlockHorizontalAlignmentLeft", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PageBlockHorizontalAlignmentRight(BaseObject):
    """
    The content must be right-aligned
    """

    ID: typing.Literal["pageBlockHorizontalAlignmentRight"] = field(
        default="pageBlockHorizontalAlignmentRight", metadata={"alias": "@type"}
    )


PageBlockHorizontalAlignment = typing.Union[
    PageBlockHorizontalAlignmentCenter,
    PageBlockHorizontalAlignmentLeft,
    PageBlockHorizontalAlignmentRight,
]


@dataclass(slots=True, kw_only=True)
class PageBlockRelatedArticle(BaseObject):
    """
    Contains information about a related article

    :param url: Related article URL
    :type url: :class:`String`
    :param photo: Article photo; may be null, defaults to None
    :type photo: :class:`Photo`, optional
    :param title: Article title; may be empty
    :type title: :class:`String`
    :param description: Article description; may be empty
    :type description: :class:`String`
    :param author: Article author; may be empty
    :type author: :class:`String`
    :param publish_date: Point in time (Unix timestamp) when the article was published; 0 if unknown, defaults to None
    :type publish_date: :class:`Int32`, optional
    """

    ID: typing.Literal["pageBlockRelatedArticle"] = field(
        default="pageBlockRelatedArticle", metadata={"alias": "@type"}
    )
    url: String
    photo: typing.Optional[Photo] = field(default=None)
    title: String = field(default="")
    description: String = field(default="")
    author: String = field(default="")
    publish_date: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class PageBlockTableCell(BaseObject):
    """
    Represents a cell of a table

    :param colspan: The number of columns the cell spans
    :type colspan: :class:`Int32`
    :param rowspan: The number of rows the cell spans
    :type rowspan: :class:`Int32`
    :param align: Horizontal cell content alignment
    :type align: :class:`PageBlockHorizontalAlignment`
    :param valign: Vertical cell content alignment
    :type valign: :class:`PageBlockVerticalAlignment`
    :param text: Cell text; may be null. If the text is null, then the cell must be invisible, defaults to None
    :type text: :class:`RichText`, optional
    :param is_header: True, if it is a header cell
    :type is_header: :class:`Bool`
    """

    ID: typing.Literal["pageBlockTableCell"] = field(default="pageBlockTableCell", metadata={"alias": "@type"})
    colspan: Int32
    rowspan: Int32
    align: PageBlockHorizontalAlignment
    valign: PageBlockVerticalAlignment
    text: typing.Optional[RichText] = field(default=None)
    is_header: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PageBlockVerticalAlignmentBottom(BaseObject):
    """
    The content must be bottom-aligned
    """

    ID: typing.Literal["pageBlockVerticalAlignmentBottom"] = field(
        default="pageBlockVerticalAlignmentBottom", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PageBlockVerticalAlignmentMiddle(BaseObject):
    """
    The content must be middle-aligned
    """

    ID: typing.Literal["pageBlockVerticalAlignmentMiddle"] = field(
        default="pageBlockVerticalAlignmentMiddle", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PageBlockVerticalAlignmentTop(BaseObject):
    """
    The content must be top-aligned
    """

    ID: typing.Literal["pageBlockVerticalAlignmentTop"] = field(
        default="pageBlockVerticalAlignmentTop", metadata={"alias": "@type"}
    )


PageBlockVerticalAlignment = typing.Union[
    PageBlockVerticalAlignmentBottom,
    PageBlockVerticalAlignmentMiddle,
    PageBlockVerticalAlignmentTop,
]


@dataclass(slots=True, kw_only=True)
class PaidMediaPhoto(BaseObject):
    """
    The media is a photo

    :param photo: The photo
    :type photo: :class:`Photo`
    """

    ID: typing.Literal["paidMediaPhoto"] = field(default="paidMediaPhoto", metadata={"alias": "@type"})
    photo: Photo


@dataclass(slots=True, kw_only=True)
class PaidMediaPreview(BaseObject):
    """
    The media is hidden until the invoice is paid

    :param minithumbnail: Media minithumbnail; may be null, defaults to None
    :type minithumbnail: :class:`Minithumbnail`, optional
    :param width: Media width; 0 if unknown, defaults to None
    :type width: :class:`Int32`, optional
    :param height: Media height; 0 if unknown, defaults to None
    :type height: :class:`Int32`, optional
    :param duration: Media duration, in seconds; 0 if unknown, defaults to None
    :type duration: :class:`Int32`, optional
    """

    ID: typing.Literal["paidMediaPreview"] = field(default="paidMediaPreview", metadata={"alias": "@type"})
    minithumbnail: typing.Optional[Minithumbnail] = field(default=None)
    width: typing.Optional[Int32] = field(default=0)
    height: typing.Optional[Int32] = field(default=0)
    duration: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class PaidMediaUnsupported(BaseObject):
    """
    The media is unsupported
    """

    ID: typing.Literal["paidMediaUnsupported"] = field(default="paidMediaUnsupported", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class PaidMediaVideo(BaseObject):
    """
    The media is a video

    :param video: The video
    :type video: :class:`Video`
    :param start_timestamp: Timestamp from which the video playing must start, in seconds
    :type start_timestamp: :class:`Int32`
    :param cover: Cover of the video; may be null if none, defaults to None
    :type cover: :class:`Photo`, optional
    """

    ID: typing.Literal["paidMediaVideo"] = field(default="paidMediaVideo", metadata={"alias": "@type"})
    video: Video
    start_timestamp: Int32
    cover: typing.Optional[Photo] = field(default=None)


PaidMedia = typing.Union[
    PaidMediaPhoto,
    PaidMediaPreview,
    PaidMediaUnsupported,
    PaidMediaVideo,
]


@dataclass(slots=True, kw_only=True)
class PaidReactionTypeAnonymous(BaseObject):
    """
    An anonymous paid reaction
    """

    ID: typing.Literal["paidReactionTypeAnonymous"] = field(
        default="paidReactionTypeAnonymous", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PaidReactionTypeChat(BaseObject):
    """
    A paid reaction on behalf of an owned chat

    :param chat_id: Identifier of the chat
    :type chat_id: :class:`Int53`
    """

    ID: typing.Literal["paidReactionTypeChat"] = field(default="paidReactionTypeChat", metadata={"alias": "@type"})
    chat_id: Int53


@dataclass(slots=True, kw_only=True)
class PaidReactionTypeRegular(BaseObject):
    """
    A paid reaction on behalf of the current user
    """

    ID: typing.Literal["paidReactionTypeRegular"] = field(
        default="paidReactionTypeRegular", metadata={"alias": "@type"}
    )


PaidReactionType = typing.Union[
    PaidReactionTypeAnonymous,
    PaidReactionTypeChat,
    PaidReactionTypeRegular,
]


@dataclass(slots=True, kw_only=True)
class PaidReactor(BaseObject):
    """
    Contains information about a user that added paid reactions

    :param star_count: Number of Telegram Stars added
    :type star_count: :class:`Int32`
    :param sender_id: Identifier of the user or chat that added the reactions; may be null for anonymous reactors that aren't the current user, defaults to None
    :type sender_id: :class:`MessageSender`, optional
    :param is_top: True, if the reactor is one of the most active reactors; may be false if the reactor is the current user
    :type is_top: :class:`Bool`
    :param is_me: True, if the paid reaction was added by the current user
    :type is_me: :class:`Bool`
    :param is_anonymous: True, if the reactor is anonymous
    :type is_anonymous: :class:`Bool`
    """

    ID: typing.Literal["paidReactor"] = field(default="paidReactor", metadata={"alias": "@type"})
    star_count: Int32
    sender_id: typing.Optional[MessageSender] = field(default=None)
    is_top: Bool = field(default=False)
    is_me: Bool = field(default=False)
    is_anonymous: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PassportAuthorizationForm(BaseObject):
    """
    Contains information about a Telegram Passport authorization form that was requested

    :param id: Unique identifier of the authorization form
    :type id: :class:`Int32`
    :param required_elements: Telegram Passport elements that must be provided to complete the form
    :type required_elements: :class:`Vector[PassportRequiredElement]`
    :param privacy_policy_url: URL for the privacy policy of the service; may be empty
    :type privacy_policy_url: :class:`String`
    """

    ID: typing.Literal["passportAuthorizationForm"] = field(
        default="passportAuthorizationForm", metadata={"alias": "@type"}
    )
    id: Int32
    required_elements: Vector[PassportRequiredElement]
    privacy_policy_url: String = field(default="")


@dataclass(slots=True, kw_only=True)
class PassportElementAddress(BaseObject):
    """
    A Telegram Passport element containing the user's address

    :param address: Address
    :type address: :class:`Address`
    """

    ID: typing.Literal["passportElementAddress"] = field(default="passportElementAddress", metadata={"alias": "@type"})
    address: Address


@dataclass(slots=True, kw_only=True)
class PassportElementBankStatement(BaseObject):
    """
    A Telegram Passport element containing the user's bank statement

    :param bank_statement: Bank statement
    :type bank_statement: :class:`PersonalDocument`
    """

    ID: typing.Literal["passportElementBankStatement"] = field(
        default="passportElementBankStatement", metadata={"alias": "@type"}
    )
    bank_statement: PersonalDocument


@dataclass(slots=True, kw_only=True)
class PassportElementDriverLicense(BaseObject):
    """
    A Telegram Passport element containing the user's driver license

    :param driver_license: Driver license
    :type driver_license: :class:`IdentityDocument`
    """

    ID: typing.Literal["passportElementDriverLicense"] = field(
        default="passportElementDriverLicense", metadata={"alias": "@type"}
    )
    driver_license: IdentityDocument


@dataclass(slots=True, kw_only=True)
class PassportElementEmailAddress(BaseObject):
    """
    A Telegram Passport element containing the user's email address

    :param email_address: Email address
    :type email_address: :class:`String`
    """

    ID: typing.Literal["passportElementEmailAddress"] = field(
        default="passportElementEmailAddress", metadata={"alias": "@type"}
    )
    email_address: String


@dataclass(slots=True, kw_only=True)
class PassportElementIdentityCard(BaseObject):
    """
    A Telegram Passport element containing the user's identity card

    :param identity_card: Identity card
    :type identity_card: :class:`IdentityDocument`
    """

    ID: typing.Literal["passportElementIdentityCard"] = field(
        default="passportElementIdentityCard", metadata={"alias": "@type"}
    )
    identity_card: IdentityDocument


@dataclass(slots=True, kw_only=True)
class PassportElementInternalPassport(BaseObject):
    """
    A Telegram Passport element containing the user's internal passport

    :param internal_passport: Internal passport
    :type internal_passport: :class:`IdentityDocument`
    """

    ID: typing.Literal["passportElementInternalPassport"] = field(
        default="passportElementInternalPassport", metadata={"alias": "@type"}
    )
    internal_passport: IdentityDocument


@dataclass(slots=True, kw_only=True)
class PassportElementPassport(BaseObject):
    """
    A Telegram Passport element containing the user's passport

    :param passport: Passport
    :type passport: :class:`IdentityDocument`
    """

    ID: typing.Literal["passportElementPassport"] = field(
        default="passportElementPassport", metadata={"alias": "@type"}
    )
    passport: IdentityDocument


@dataclass(slots=True, kw_only=True)
class PassportElementPassportRegistration(BaseObject):
    """
    A Telegram Passport element containing the user's passport registration pages

    :param passport_registration: Passport registration pages
    :type passport_registration: :class:`PersonalDocument`
    """

    ID: typing.Literal["passportElementPassportRegistration"] = field(
        default="passportElementPassportRegistration", metadata={"alias": "@type"}
    )
    passport_registration: PersonalDocument


@dataclass(slots=True, kw_only=True)
class PassportElementPersonalDetails(BaseObject):
    """
    A Telegram Passport element containing the user's personal details

    :param personal_details: Personal details of the user
    :type personal_details: :class:`PersonalDetails`
    """

    ID: typing.Literal["passportElementPersonalDetails"] = field(
        default="passportElementPersonalDetails", metadata={"alias": "@type"}
    )
    personal_details: PersonalDetails


@dataclass(slots=True, kw_only=True)
class PassportElementPhoneNumber(BaseObject):
    """
    A Telegram Passport element containing the user's phone number

    :param phone_number: Phone number
    :type phone_number: :class:`String`
    """

    ID: typing.Literal["passportElementPhoneNumber"] = field(
        default="passportElementPhoneNumber", metadata={"alias": "@type"}
    )
    phone_number: String


@dataclass(slots=True, kw_only=True)
class PassportElementRentalAgreement(BaseObject):
    """
    A Telegram Passport element containing the user's rental agreement

    :param rental_agreement: Rental agreement
    :type rental_agreement: :class:`PersonalDocument`
    """

    ID: typing.Literal["passportElementRentalAgreement"] = field(
        default="passportElementRentalAgreement", metadata={"alias": "@type"}
    )
    rental_agreement: PersonalDocument


@dataclass(slots=True, kw_only=True)
class PassportElementTemporaryRegistration(BaseObject):
    """
    A Telegram Passport element containing the user's temporary registration

    :param temporary_registration: Temporary registration
    :type temporary_registration: :class:`PersonalDocument`
    """

    ID: typing.Literal["passportElementTemporaryRegistration"] = field(
        default="passportElementTemporaryRegistration", metadata={"alias": "@type"}
    )
    temporary_registration: PersonalDocument


@dataclass(slots=True, kw_only=True)
class PassportElementUtilityBill(BaseObject):
    """
    A Telegram Passport element containing the user's utility bill

    :param utility_bill: Utility bill
    :type utility_bill: :class:`PersonalDocument`
    """

    ID: typing.Literal["passportElementUtilityBill"] = field(
        default="passportElementUtilityBill", metadata={"alias": "@type"}
    )
    utility_bill: PersonalDocument


PassportElement = typing.Union[
    PassportElementAddress,
    PassportElementBankStatement,
    PassportElementDriverLicense,
    PassportElementEmailAddress,
    PassportElementIdentityCard,
    PassportElementInternalPassport,
    PassportElementPassport,
    PassportElementPassportRegistration,
    PassportElementPersonalDetails,
    PassportElementPhoneNumber,
    PassportElementRentalAgreement,
    PassportElementTemporaryRegistration,
    PassportElementUtilityBill,
]


@dataclass(slots=True, kw_only=True)
class PassportElementError(BaseObject):
    """
    Contains the description of an error in a Telegram Passport element

    :param type_: Type of the Telegram Passport element which has the error
    :type type_: :class:`PassportElementType`
    :param message: Error message
    :type message: :class:`String`
    :param source: Error source
    :type source: :class:`PassportElementErrorSource`
    """

    ID: typing.Literal["passportElementError"] = field(default="passportElementError", metadata={"alias": "@type"})
    type_: PassportElementType = field(default=MISSING, metadata={"alias": "type"})
    message: String
    source: PassportElementErrorSource


@dataclass(slots=True, kw_only=True)
class PassportElementErrorSourceDataField(BaseObject):
    """
    One of the data fields contains an error. The error will be considered resolved when the value of the field changes

    :param field_name: Field name
    :type field_name: :class:`String`
    """

    ID: typing.Literal["passportElementErrorSourceDataField"] = field(
        default="passportElementErrorSourceDataField", metadata={"alias": "@type"}
    )
    field_name: String


@dataclass(slots=True, kw_only=True)
class PassportElementErrorSourceFile(BaseObject):
    """
    The file contains an error. The error will be considered resolved when the file changes

    :param file_index: Index of a file with the error
    :type file_index: :class:`Int32`
    """

    ID: typing.Literal["passportElementErrorSourceFile"] = field(
        default="passportElementErrorSourceFile", metadata={"alias": "@type"}
    )
    file_index: Int32


@dataclass(slots=True, kw_only=True)
class PassportElementErrorSourceFiles(BaseObject):
    """
    The list of attached files contains an error. The error will be considered resolved when the list of files changes
    """

    ID: typing.Literal["passportElementErrorSourceFiles"] = field(
        default="passportElementErrorSourceFiles", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementErrorSourceFrontSide(BaseObject):
    """
    The front side of the document contains an error. The error will be considered resolved when the file with the front side changes
    """

    ID: typing.Literal["passportElementErrorSourceFrontSide"] = field(
        default="passportElementErrorSourceFrontSide", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementErrorSourceReverseSide(BaseObject):
    """
    The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes
    """

    ID: typing.Literal["passportElementErrorSourceReverseSide"] = field(
        default="passportElementErrorSourceReverseSide", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementErrorSourceSelfie(BaseObject):
    """
    The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes
    """

    ID: typing.Literal["passportElementErrorSourceSelfie"] = field(
        default="passportElementErrorSourceSelfie", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementErrorSourceTranslationFile(BaseObject):
    """
    One of files with the translation of the document contains an error. The error will be considered resolved when the file changes

    :param file_index: Index of a file with the error
    :type file_index: :class:`Int32`
    """

    ID: typing.Literal["passportElementErrorSourceTranslationFile"] = field(
        default="passportElementErrorSourceTranslationFile", metadata={"alias": "@type"}
    )
    file_index: Int32


@dataclass(slots=True, kw_only=True)
class PassportElementErrorSourceTranslationFiles(BaseObject):
    """
    The translation of the document contains an error. The error will be considered resolved when the list of translation files changes
    """

    ID: typing.Literal["passportElementErrorSourceTranslationFiles"] = field(
        default="passportElementErrorSourceTranslationFiles", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementErrorSourceUnspecified(BaseObject):
    """
    The element contains an error in an unspecified place. The error will be considered resolved when new data is added
    """

    ID: typing.Literal["passportElementErrorSourceUnspecified"] = field(
        default="passportElementErrorSourceUnspecified", metadata={"alias": "@type"}
    )


PassportElementErrorSource = typing.Union[
    PassportElementErrorSourceDataField,
    PassportElementErrorSourceFile,
    PassportElementErrorSourceFiles,
    PassportElementErrorSourceFrontSide,
    PassportElementErrorSourceReverseSide,
    PassportElementErrorSourceSelfie,
    PassportElementErrorSourceTranslationFile,
    PassportElementErrorSourceTranslationFiles,
    PassportElementErrorSourceUnspecified,
]


@dataclass(slots=True, kw_only=True)
class PassportElementTypeAddress(BaseObject):
    """
    A Telegram Passport element containing the user's address
    """

    ID: typing.Literal["passportElementTypeAddress"] = field(
        default="passportElementTypeAddress", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementTypeBankStatement(BaseObject):
    """
    A Telegram Passport element containing the user's bank statement
    """

    ID: typing.Literal["passportElementTypeBankStatement"] = field(
        default="passportElementTypeBankStatement", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementTypeDriverLicense(BaseObject):
    """
    A Telegram Passport element containing the user's driver license
    """

    ID: typing.Literal["passportElementTypeDriverLicense"] = field(
        default="passportElementTypeDriverLicense", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementTypeEmailAddress(BaseObject):
    """
    A Telegram Passport element containing the user's email address
    """

    ID: typing.Literal["passportElementTypeEmailAddress"] = field(
        default="passportElementTypeEmailAddress", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementTypeIdentityCard(BaseObject):
    """
    A Telegram Passport element containing the user's identity card
    """

    ID: typing.Literal["passportElementTypeIdentityCard"] = field(
        default="passportElementTypeIdentityCard", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementTypeInternalPassport(BaseObject):
    """
    A Telegram Passport element containing the user's internal passport
    """

    ID: typing.Literal["passportElementTypeInternalPassport"] = field(
        default="passportElementTypeInternalPassport", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementTypePassport(BaseObject):
    """
    A Telegram Passport element containing the user's passport
    """

    ID: typing.Literal["passportElementTypePassport"] = field(
        default="passportElementTypePassport", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementTypePassportRegistration(BaseObject):
    """
    A Telegram Passport element containing the registration page of the user's passport
    """

    ID: typing.Literal["passportElementTypePassportRegistration"] = field(
        default="passportElementTypePassportRegistration", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementTypePersonalDetails(BaseObject):
    """
    A Telegram Passport element containing the user's personal details
    """

    ID: typing.Literal["passportElementTypePersonalDetails"] = field(
        default="passportElementTypePersonalDetails", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementTypePhoneNumber(BaseObject):
    """
    A Telegram Passport element containing the user's phone number
    """

    ID: typing.Literal["passportElementTypePhoneNumber"] = field(
        default="passportElementTypePhoneNumber", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementTypeRentalAgreement(BaseObject):
    """
    A Telegram Passport element containing the user's rental agreement
    """

    ID: typing.Literal["passportElementTypeRentalAgreement"] = field(
        default="passportElementTypeRentalAgreement", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementTypeTemporaryRegistration(BaseObject):
    """
    A Telegram Passport element containing the user's temporary registration
    """

    ID: typing.Literal["passportElementTypeTemporaryRegistration"] = field(
        default="passportElementTypeTemporaryRegistration", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PassportElementTypeUtilityBill(BaseObject):
    """
    A Telegram Passport element containing the user's utility bill
    """

    ID: typing.Literal["passportElementTypeUtilityBill"] = field(
        default="passportElementTypeUtilityBill", metadata={"alias": "@type"}
    )


PassportElementType = typing.Union[
    PassportElementTypeAddress,
    PassportElementTypeBankStatement,
    PassportElementTypeDriverLicense,
    PassportElementTypeEmailAddress,
    PassportElementTypeIdentityCard,
    PassportElementTypeInternalPassport,
    PassportElementTypePassport,
    PassportElementTypePassportRegistration,
    PassportElementTypePersonalDetails,
    PassportElementTypePhoneNumber,
    PassportElementTypeRentalAgreement,
    PassportElementTypeTemporaryRegistration,
    PassportElementTypeUtilityBill,
]


@dataclass(slots=True, kw_only=True)
class PassportElements(BaseObject):
    """
    Contains information about saved Telegram Passport elements

    :param elements: Telegram Passport elements
    :type elements: :class:`Vector[PassportElement]`
    """

    ID: typing.Literal["passportElements"] = field(default="passportElements", metadata={"alias": "@type"})
    elements: Vector[PassportElement]


@dataclass(slots=True, kw_only=True)
class PassportElementsWithErrors(BaseObject):
    """
    Contains information about a Telegram Passport elements and corresponding errors

    :param elements: Telegram Passport elements
    :type elements: :class:`Vector[PassportElement]`
    :param errors: Errors in the elements that are already available
    :type errors: :class:`Vector[PassportElementError]`
    """

    ID: typing.Literal["passportElementsWithErrors"] = field(
        default="passportElementsWithErrors", metadata={"alias": "@type"}
    )
    elements: Vector[PassportElement]
    errors: Vector[PassportElementError]


@dataclass(slots=True, kw_only=True)
class PassportRequiredElement(BaseObject):
    """
    Contains a description of the required Telegram Passport element that was requested by a service

    :param suitable_elements: List of Telegram Passport elements any of which is enough to provide
    :type suitable_elements: :class:`Vector[PassportSuitableElement]`
    """

    ID: typing.Literal["passportRequiredElement"] = field(
        default="passportRequiredElement", metadata={"alias": "@type"}
    )
    suitable_elements: Vector[PassportSuitableElement]


@dataclass(slots=True, kw_only=True)
class PassportSuitableElement(BaseObject):
    """
    Contains information about a Telegram Passport element that was requested by a service

    :param type_: Type of the element
    :type type_: :class:`PassportElementType`
    :param is_selfie_required: True, if a selfie is required with the identity document
    :type is_selfie_required: :class:`Bool`
    :param is_translation_required: True, if a certified English translation is required with the document
    :type is_translation_required: :class:`Bool`
    :param is_native_name_required: True, if personal details must include the user's name in the language of their country of residence
    :type is_native_name_required: :class:`Bool`
    """

    ID: typing.Literal["passportSuitableElement"] = field(
        default="passportSuitableElement", metadata={"alias": "@type"}
    )
    type_: PassportElementType = field(default=MISSING, metadata={"alias": "type"})
    is_selfie_required: Bool = field(default=False)
    is_translation_required: Bool = field(default=False)
    is_native_name_required: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PasswordState(BaseObject):
    """
    Represents the current state of 2-step verification

    :param login_email_address_pattern: Pattern of the email address set up for logging in
    :type login_email_address_pattern: :class:`String`
    :param recovery_email_address_code_info: Information about the recovery email address to which the confirmation email was sent; may be null, defaults to None
    :type recovery_email_address_code_info: :class:`EmailAddressAuthenticationCodeInfo`, optional
    :param has_password: True, if a 2-step verification password is set
    :type has_password: :class:`Bool`
    :param password_hint: Hint for the password; may be empty
    :type password_hint: :class:`String`
    :param has_recovery_email_address: True, if a recovery email is set
    :type has_recovery_email_address: :class:`Bool`
    :param has_passport_data: True, if some Telegram Passport elements were saved
    :type has_passport_data: :class:`Bool`
    :param pending_reset_date: If not 0, point in time (Unix timestamp) after which the 2-step verification password can be reset immediately using resetPassword
    :type pending_reset_date: :class:`Int32`
    """

    ID: typing.Literal["passwordState"] = field(default="passwordState", metadata={"alias": "@type"})
    login_email_address_pattern: String
    recovery_email_address_code_info: typing.Optional[EmailAddressAuthenticationCodeInfo] = field(default=None)
    has_password: Bool = field(default=False)
    password_hint: String = field(default="")
    has_recovery_email_address: Bool = field(default=False)
    has_passport_data: Bool = field(default=False)
    pending_reset_date: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class PaymentForm(BaseObject):
    """
    Contains information about an invoice payment form

    :param id: The payment form identifier
    :type id: :class:`Int64`
    :param type_: Type of the payment form
    :type type_: :class:`PaymentFormType`
    :param seller_bot_user_id: User identifier of the seller bot
    :type seller_bot_user_id: :class:`Int53`
    :param product_info: Information about the product
    :type product_info: :class:`ProductInfo`
    """

    ID: typing.Literal["paymentForm"] = field(default="paymentForm", metadata={"alias": "@type"})
    id: Int64
    type_: PaymentFormType = field(default=MISSING, metadata={"alias": "type"})
    seller_bot_user_id: Int53
    product_info: ProductInfo


@dataclass(slots=True, kw_only=True)
class PaymentFormTypeRegular(BaseObject):
    """
    The payment form is for a regular payment

    :param invoice: Full information about the invoice
    :type invoice: :class:`Invoice`
    :param payment_provider_user_id: User identifier of the payment provider bot
    :type payment_provider_user_id: :class:`Int53`
    :param payment_provider: Information about the payment provider
    :type payment_provider: :class:`PaymentProvider`
    :param additional_payment_options: The list of additional payment options
    :type additional_payment_options: :class:`Vector[PaymentOption]`
    :param saved_credentials: The list of saved payment credentials
    :type saved_credentials: :class:`Vector[SavedCredentials]`
    :param saved_order_info: Saved server-side order information; may be null, defaults to None
    :type saved_order_info: :class:`OrderInfo`, optional
    :param can_save_credentials: True, if the user can choose to save credentials
    :type can_save_credentials: :class:`Bool`
    :param need_password: True, if the user will be able to save credentials, if sets up a 2-step verification password
    :type need_password: :class:`Bool`
    """

    ID: typing.Literal["paymentFormTypeRegular"] = field(default="paymentFormTypeRegular", metadata={"alias": "@type"})
    invoice: Invoice
    payment_provider_user_id: Int53
    payment_provider: PaymentProvider
    additional_payment_options: Vector[PaymentOption]
    saved_credentials: Vector[SavedCredentials]
    saved_order_info: typing.Optional[OrderInfo] = field(default=None)
    can_save_credentials: Bool = field(default=False)
    need_password: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PaymentFormTypeStarSubscription(BaseObject):
    """
    The payment form is for a payment in Telegram Stars for subscription

    :param pricing: Information about subscription plan
    :type pricing: :class:`StarSubscriptionPricing`
    """

    ID: typing.Literal["paymentFormTypeStarSubscription"] = field(
        default="paymentFormTypeStarSubscription", metadata={"alias": "@type"}
    )
    pricing: StarSubscriptionPricing


@dataclass(slots=True, kw_only=True)
class PaymentFormTypeStars(BaseObject):
    """
    The payment form is for a payment in Telegram Stars

    :param star_count: Number of Telegram Stars that will be paid
    :type star_count: :class:`Int53`
    """

    ID: typing.Literal["paymentFormTypeStars"] = field(default="paymentFormTypeStars", metadata={"alias": "@type"})
    star_count: Int53


PaymentFormType = typing.Union[
    PaymentFormTypeRegular,
    PaymentFormTypeStarSubscription,
    PaymentFormTypeStars,
]


@dataclass(slots=True, kw_only=True)
class PaymentOption(BaseObject):
    """
    Describes an additional payment option

    :param title: Title for the payment option
    :type title: :class:`String`
    :param url: Payment form URL to be opened in a web view
    :type url: :class:`String`
    """

    ID: typing.Literal["paymentOption"] = field(default="paymentOption", metadata={"alias": "@type"})
    title: String
    url: String


@dataclass(slots=True, kw_only=True)
class PaymentProviderOther(BaseObject):
    """
    Some other payment provider, for which a web payment form must be shown

    :param url: Payment form URL
    :type url: :class:`String`
    """

    ID: typing.Literal["paymentProviderOther"] = field(default="paymentProviderOther", metadata={"alias": "@type"})
    url: String


@dataclass(slots=True, kw_only=True)
class PaymentProviderSmartGlocal(BaseObject):
    """
    Smart Glocal payment provider

    :param public_token: Public payment token
    :type public_token: :class:`String`
    :param tokenize_url: URL for sending card tokenization requests
    :type tokenize_url: :class:`String`
    """

    ID: typing.Literal["paymentProviderSmartGlocal"] = field(
        default="paymentProviderSmartGlocal", metadata={"alias": "@type"}
    )
    public_token: String
    tokenize_url: String


@dataclass(slots=True, kw_only=True)
class PaymentProviderStripe(BaseObject):
    """
    Stripe payment provider

    :param publishable_key: Stripe API publishable key
    :type publishable_key: :class:`String`
    :param need_country: True, if the user country must be provided
    :type need_country: :class:`Bool`
    :param need_postal_code: True, if the user ZIP/postal code must be provided
    :type need_postal_code: :class:`Bool`
    :param need_cardholder_name: True, if the cardholder name must be provided
    :type need_cardholder_name: :class:`Bool`
    """

    ID: typing.Literal["paymentProviderStripe"] = field(default="paymentProviderStripe", metadata={"alias": "@type"})
    publishable_key: String
    need_country: Bool = field(default=False)
    need_postal_code: Bool = field(default=False)
    need_cardholder_name: Bool = field(default=False)


PaymentProvider = typing.Union[
    PaymentProviderOther,
    PaymentProviderSmartGlocal,
    PaymentProviderStripe,
]


@dataclass(slots=True, kw_only=True)
class PaymentReceipt(BaseObject):
    """
    Contains information about a successful payment

    :param product_info: Information about the product
    :type product_info: :class:`ProductInfo`
    :param date: Point in time (Unix timestamp) when the payment was made
    :type date: :class:`Int32`
    :param seller_bot_user_id: User identifier of the seller bot
    :type seller_bot_user_id: :class:`Int53`
    :param type_: Type of the payment receipt
    :type type_: :class:`PaymentReceiptType`
    """

    ID: typing.Literal["paymentReceipt"] = field(default="paymentReceipt", metadata={"alias": "@type"})
    product_info: ProductInfo
    date: Int32
    seller_bot_user_id: Int53
    type_: PaymentReceiptType = field(default=MISSING, metadata={"alias": "type"})


@dataclass(slots=True, kw_only=True)
class PaymentReceiptTypeRegular(BaseObject):
    """
    The payment was done using a third-party payment provider

    :param payment_provider_user_id: User identifier of the payment provider bot
    :type payment_provider_user_id: :class:`Int53`
    :param invoice: Information about the invoice
    :type invoice: :class:`Invoice`
    :param credentials_title: Title of the saved credentials chosen by the buyer
    :type credentials_title: :class:`String`
    :param tip_amount: The amount of tip chosen by the buyer in the smallest units of the currency
    :type tip_amount: :class:`Int53`
    :param order_info: Order information; may be null, defaults to None
    :type order_info: :class:`OrderInfo`, optional
    :param shipping_option: Chosen shipping option; may be null, defaults to None
    :type shipping_option: :class:`ShippingOption`, optional
    """

    ID: typing.Literal["paymentReceiptTypeRegular"] = field(
        default="paymentReceiptTypeRegular", metadata={"alias": "@type"}
    )
    payment_provider_user_id: Int53
    invoice: Invoice
    credentials_title: String
    tip_amount: Int53
    order_info: typing.Optional[OrderInfo] = field(default=None)
    shipping_option: typing.Optional[ShippingOption] = field(default=None)


@dataclass(slots=True, kw_only=True)
class PaymentReceiptTypeStars(BaseObject):
    """
    The payment was done using Telegram Stars

    :param star_count: Number of Telegram Stars that were paid
    :type star_count: :class:`Int53`
    :param transaction_id: Unique identifier of the transaction that can be used to dispute it
    :type transaction_id: :class:`String`
    """

    ID: typing.Literal["paymentReceiptTypeStars"] = field(
        default="paymentReceiptTypeStars", metadata={"alias": "@type"}
    )
    star_count: Int53
    transaction_id: String


PaymentReceiptType = typing.Union[
    PaymentReceiptTypeRegular,
    PaymentReceiptTypeStars,
]


@dataclass(slots=True, kw_only=True)
class PaymentResult(BaseObject):
    """
    Contains the result of a payment request

    :param verification_url: URL for additional payment credentials verification
    :type verification_url: :class:`String`
    :param success: True, if the payment request was successful; otherwise, the verification_url will be non-empty
    :type success: :class:`Bool`
    """

    ID: typing.Literal["paymentResult"] = field(default="paymentResult", metadata={"alias": "@type"})
    verification_url: String
    success: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PersonalDetails(BaseObject):
    """
    Contains the user's personal details

    :param first_name: First name of the user written in English; 1-255 characters
    :type first_name: :class:`String`
    :param last_name: Last name of the user written in English; 1-255 characters
    :type last_name: :class:`String`
    :param native_first_name: Native first name of the user; 1-255 characters
    :type native_first_name: :class:`String`
    :param native_last_name: Native last name of the user; 1-255 characters
    :type native_last_name: :class:`String`
    :param birthdate: Birthdate of the user
    :type birthdate: :class:`Date`
    :param gender: Gender of the user, "male" or "female"
    :type gender: :class:`String`
    :param country_code: A two-letter ISO 3166-1 alpha-2 country code of the user's country
    :type country_code: :class:`String`
    :param residence_country_code: A two-letter ISO 3166-1 alpha-2 country code of the user's residence country
    :type residence_country_code: :class:`String`
    :param middle_name: Middle name of the user written in English; 0-255 characters
    :type middle_name: :class:`String`
    :param native_middle_name: Native middle name of the user; 0-255 characters
    :type native_middle_name: :class:`String`
    """

    ID: typing.Literal["personalDetails"] = field(default="personalDetails", metadata={"alias": "@type"})
    first_name: String = field(default=MISSING, metadata={"min_length": 1, "max_length": 255})
    last_name: String = field(default=MISSING, metadata={"min_length": 1, "max_length": 255})
    native_first_name: String = field(default=MISSING, metadata={"min_length": 1, "max_length": 255})
    native_last_name: String = field(default=MISSING, metadata={"min_length": 1, "max_length": 255})
    birthdate: Date
    gender: String
    country_code: String
    residence_country_code: String
    middle_name: String = field(default="", metadata={"max_length": 255})
    native_middle_name: String = field(default="", metadata={"max_length": 255})


@dataclass(slots=True, kw_only=True)
class PersonalDocument(BaseObject):
    """
    A personal document, containing some information about a user

    :param files: List of files containing the pages of the document
    :type files: :class:`Vector[DatedFile]`
    :param translation: List of files containing a certified English translation of the document
    :type translation: :class:`Vector[DatedFile]`
    """

    ID: typing.Literal["personalDocument"] = field(default="personalDocument", metadata={"alias": "@type"})
    files: Vector[DatedFile]
    translation: Vector[DatedFile]


@dataclass(slots=True, kw_only=True)
class PhoneNumberAuthenticationSettings(BaseObject):
    """
    Contains settings for the authentication of the user's phone number

    :param authentication_tokens: List of up to 20 authentication tokens, recently received in updateOption("authentication_token") in previously logged out sessions
    :type authentication_tokens: :class:`Vector[String]`
    :param allow_flash_call: Pass true if the authentication code may be sent via a flash call to the specified phone number
    :type allow_flash_call: :class:`Bool`
    :param allow_missed_call: Pass true if the authentication code may be sent via a missed call to the specified phone number
    :type allow_missed_call: :class:`Bool`
    :param is_current_phone_number: Pass true if the authenticated phone number is used on the current device
    :type is_current_phone_number: :class:`Bool`
    :param has_unknown_phone_number: Pass true if there is a SIM card in the current device, but it is not possible to check whether phone number matches
    :type has_unknown_phone_number: :class:`Bool`
    :param allow_sms_retriever_api: For official applications only. True, if the application can use Android SMS Retriever API (requires Google Play Services >= 10.2) to automatically receive the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/ for more details
    :type allow_sms_retriever_api: :class:`Bool`
    :param firebase_authentication_settings: For official Android and iOS applications only; pass null otherwise. Settings for Firebase Authentication, defaults to None
    :type firebase_authentication_settings: :class:`FirebaseAuthenticationSettings`, optional
    """

    ID: typing.Literal["phoneNumberAuthenticationSettings"] = field(
        default="phoneNumberAuthenticationSettings", metadata={"alias": "@type"}
    )
    authentication_tokens: Vector[String]
    allow_flash_call: Bool = field(default=False)
    allow_missed_call: Bool = field(default=False)
    is_current_phone_number: Bool = field(default=False)
    has_unknown_phone_number: Bool = field(default=False)
    allow_sms_retriever_api: Bool = field(default=False)
    firebase_authentication_settings: typing.Optional[FirebaseAuthenticationSettings] = field(default=None)


@dataclass(slots=True, kw_only=True)
class PhoneNumberCodeTypeChange(BaseObject):
    """
    Checks ownership of a new phone number to change the user's authentication phone number; for official Android and iOS applications only
    """

    ID: typing.Literal["phoneNumberCodeTypeChange"] = field(
        default="phoneNumberCodeTypeChange", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PhoneNumberCodeTypeConfirmOwnership(BaseObject):
    """
    Confirms ownership of a phone number to prevent account deletion while handling links of the type internalLinkTypePhoneNumberConfirmation

    :param hash_: Hash value from the link
    :type hash_: :class:`String`
    """

    ID: typing.Literal["phoneNumberCodeTypeConfirmOwnership"] = field(
        default="phoneNumberCodeTypeConfirmOwnership", metadata={"alias": "@type"}
    )
    hash_: String = field(default=MISSING, metadata={"alias": "hash"})


@dataclass(slots=True, kw_only=True)
class PhoneNumberCodeTypeVerify(BaseObject):
    """
    Verifies ownership of a phone number to be added to the user's Telegram Passport
    """

    ID: typing.Literal["phoneNumberCodeTypeVerify"] = field(
        default="phoneNumberCodeTypeVerify", metadata={"alias": "@type"}
    )


PhoneNumberCodeType = typing.Union[
    PhoneNumberCodeTypeChange,
    PhoneNumberCodeTypeConfirmOwnership,
    PhoneNumberCodeTypeVerify,
]


@dataclass(slots=True, kw_only=True)
class PhoneNumberInfo(BaseObject):
    """
    Contains information about a phone number

    :param country_calling_code: The part of the phone number denoting country calling code or its part
    :type country_calling_code: :class:`String`
    :param formatted_phone_number: The phone number without country calling code formatted accordingly to local rules. Expected digits are returned as '-', but even more digits might be entered by the user
    :type formatted_phone_number: :class:`String`
    :param country: Information about the country to which the phone number belongs; may be null, defaults to None
    :type country: :class:`CountryInfo`, optional
    :param is_anonymous: True, if the phone number was bought at https://fragment.com and isn't tied to a SIM card. Information about the phone number can be received using getCollectibleItemInfo
    :type is_anonymous: :class:`Bool`
    """

    ID: typing.Literal["phoneNumberInfo"] = field(default="phoneNumberInfo", metadata={"alias": "@type"})
    country_calling_code: String
    formatted_phone_number: String
    country: typing.Optional[CountryInfo] = field(default=None)
    is_anonymous: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class Photo(BaseObject):
    """
    Describes a photo

    :param sizes: Available variants of the photo, in different sizes
    :type sizes: :class:`Vector[PhotoSize]`
    :param minithumbnail: Photo minithumbnail; may be null, defaults to None
    :type minithumbnail: :class:`Minithumbnail`, optional
    :param has_stickers: True, if stickers were added to the photo. The list of corresponding sticker sets can be received using getAttachedStickerSets
    :type has_stickers: :class:`Bool`
    """

    ID: typing.Literal["photo"] = field(default="photo", metadata={"alias": "@type"})
    sizes: Vector[PhotoSize]
    minithumbnail: typing.Optional[Minithumbnail] = field(default=None)
    has_stickers: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PhotoSize(BaseObject):
    """
    Describes an image in JPEG format

    :param type_: Image type (see https://core.telegram.org/constructor/photoSize)
    :type type_: :class:`String`
    :param photo: Information about the image file
    :type photo: :class:`File`
    :param width: Image width
    :type width: :class:`Int32`
    :param height: Image height
    :type height: :class:`Int32`
    :param progressive_sizes: Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image; in bytes
    :type progressive_sizes: :class:`Vector[Int32]`
    """

    ID: typing.Literal["photoSize"] = field(default="photoSize", metadata={"alias": "@type"})
    type_: String = field(default=MISSING, metadata={"alias": "type"})
    photo: File
    width: Int32
    height: Int32
    progressive_sizes: Vector[Int32]


@dataclass(slots=True, kw_only=True)
class Point(BaseObject):
    """
    A point on a Cartesian plane

    :param x: The point's first coordinate
    :type x: :class:`Double`
    :param y: The point's second coordinate
    :type y: :class:`Double`
    """

    ID: typing.Literal["point"] = field(default="point", metadata={"alias": "@type"})
    x: Double
    y: Double


@dataclass(slots=True, kw_only=True)
class Poll(BaseObject):
    """
    Describes a poll

    :param id: Unique poll identifier
    :type id: :class:`Int64`
    :param question: Poll question; 1-300 characters. Only custom emoji entities are allowed
    :type question: :class:`FormattedText`
    :param options: List of poll answer options
    :type options: :class:`Vector[PollOption]`
    :param total_voter_count: Total number of voters, participating in the poll
    :type total_voter_count: :class:`Int32`
    :param recent_voter_ids: Identifiers of recent voters, if the poll is non-anonymous
    :type recent_voter_ids: :class:`Vector[MessageSender]`
    :param type_: Type of the poll
    :type type_: :class:`PollType`
    :param open_period: Amount of time the poll will be active after creation, in seconds
    :type open_period: :class:`Int32`
    :param close_date: Point in time (Unix timestamp) when the poll will automatically be closed
    :type close_date: :class:`Int32`
    :param is_anonymous: True, if the poll is anonymous
    :type is_anonymous: :class:`Bool`
    :param is_closed: True, if the poll is closed
    :type is_closed: :class:`Bool`
    """

    ID: typing.Literal["poll"] = field(default="poll", metadata={"alias": "@type"})
    id: Int64
    question: FormattedText
    options: Vector[PollOption]
    total_voter_count: Int32
    recent_voter_ids: Vector[MessageSender]
    type_: PollType = field(default=MISSING, metadata={"alias": "type"})
    open_period: Int32
    close_date: Int32
    is_anonymous: Bool = field(default=False)
    is_closed: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PollOption(BaseObject):
    """
    Describes one answer option of a poll

    :param text: Option text; 1-100 characters. Only custom emoji entities are allowed
    :type text: :class:`FormattedText`
    :param voter_count: Number of voters for this option, available only for closed or voted polls
    :type voter_count: :class:`Int32`
    :param vote_percentage: The percentage of votes for this option; 0-100
    :type vote_percentage: :class:`Int32`
    :param is_chosen: True, if the option was chosen by the user
    :type is_chosen: :class:`Bool`
    :param is_being_chosen: True, if the option is being chosen by a pending setPollAnswer request
    :type is_being_chosen: :class:`Bool`
    """

    ID: typing.Literal["pollOption"] = field(default="pollOption", metadata={"alias": "@type"})
    text: FormattedText
    voter_count: Int32
    vote_percentage: Int32
    is_chosen: Bool = field(default=False)
    is_being_chosen: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PollTypeQuiz(BaseObject):
    """
    A poll in quiz mode, which has exactly one correct answer option and can be answered only once

    :param correct_option_id: 0-based identifier of the correct answer option; -1 for a yet unanswered poll
    :type correct_option_id: :class:`Int32`
    :param explanation: Text that is shown when the user chooses an incorrect answer or taps on the lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll
    :type explanation: :class:`FormattedText`
    """

    ID: typing.Literal["pollTypeQuiz"] = field(default="pollTypeQuiz", metadata={"alias": "@type"})
    correct_option_id: Int32
    explanation: FormattedText = field(default="")


@dataclass(slots=True, kw_only=True)
class PollTypeRegular(BaseObject):
    """
    A regular poll

    :param allow_multiple_answers: True, if multiple answer options can be chosen simultaneously
    :type allow_multiple_answers: :class:`Bool`
    """

    ID: typing.Literal["pollTypeRegular"] = field(default="pollTypeRegular", metadata={"alias": "@type"})
    allow_multiple_answers: Bool = field(default=False)


PollType = typing.Union[
    PollTypeQuiz,
    PollTypeRegular,
]


@dataclass(slots=True, kw_only=True)
class PremiumFeatureAccentColor(BaseObject):
    """
    The ability to choose accent color for replies and user profile
    """

    ID: typing.Literal["premiumFeatureAccentColor"] = field(
        default="premiumFeatureAccentColor", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureAdvancedChatManagement(BaseObject):
    """
    Ability to change position of the main chat list, archive and mute all new chats from non-contacts, and completely disable notifications about the user's contacts joined Telegram
    """

    ID: typing.Literal["premiumFeatureAdvancedChatManagement"] = field(
        default="premiumFeatureAdvancedChatManagement", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureAnimatedProfilePhoto(BaseObject):
    """
    Profile photo animation on message and chat screens
    """

    ID: typing.Literal["premiumFeatureAnimatedProfilePhoto"] = field(
        default="premiumFeatureAnimatedProfilePhoto", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureAppIcons(BaseObject):
    """
    Allowed to set a premium application icons
    """

    ID: typing.Literal["premiumFeatureAppIcons"] = field(default="premiumFeatureAppIcons", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class PremiumFeatureBackgroundForBoth(BaseObject):
    """
    The ability to set private chat background for both users
    """

    ID: typing.Literal["premiumFeatureBackgroundForBoth"] = field(
        default="premiumFeatureBackgroundForBoth", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureBusiness(BaseObject):
    """
    The ability to use Business features
    """

    ID: typing.Literal["premiumFeatureBusiness"] = field(default="premiumFeatureBusiness", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class PremiumFeatureChatBoost(BaseObject):
    """
    The ability to boost chats
    """

    ID: typing.Literal["premiumFeatureChatBoost"] = field(
        default="premiumFeatureChatBoost", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureCustomEmoji(BaseObject):
    """
    Allowed to use custom emoji stickers in message texts and captions
    """

    ID: typing.Literal["premiumFeatureCustomEmoji"] = field(
        default="premiumFeatureCustomEmoji", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureDisabledAds(BaseObject):
    """
    Disabled ads
    """

    ID: typing.Literal["premiumFeatureDisabledAds"] = field(
        default="premiumFeatureDisabledAds", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureEmojiStatus(BaseObject):
    """
    The ability to show an emoji status along with the user's name
    """

    ID: typing.Literal["premiumFeatureEmojiStatus"] = field(
        default="premiumFeatureEmojiStatus", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureForumTopicIcon(BaseObject):
    """
    The ability to set a custom emoji as a forum topic icon
    """

    ID: typing.Literal["premiumFeatureForumTopicIcon"] = field(
        default="premiumFeatureForumTopicIcon", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureImprovedDownloadSpeed(BaseObject):
    """
    Improved download speed
    """

    ID: typing.Literal["premiumFeatureImprovedDownloadSpeed"] = field(
        default="premiumFeatureImprovedDownloadSpeed", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureIncreasedLimits(BaseObject):
    """
    Increased limits
    """

    ID: typing.Literal["premiumFeatureIncreasedLimits"] = field(
        default="premiumFeatureIncreasedLimits", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureIncreasedUploadFileSize(BaseObject):
    """
    Increased maximum upload file size
    """

    ID: typing.Literal["premiumFeatureIncreasedUploadFileSize"] = field(
        default="premiumFeatureIncreasedUploadFileSize", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureLastSeenTimes(BaseObject):
    """
    The ability to view last seen and read times of other users even they can't view last seen or read time for the current user
    """

    ID: typing.Literal["premiumFeatureLastSeenTimes"] = field(
        default="premiumFeatureLastSeenTimes", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureMessageEffects(BaseObject):
    """
    The ability to use all available message effects
    """

    ID: typing.Literal["premiumFeatureMessageEffects"] = field(
        default="premiumFeatureMessageEffects", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureMessagePrivacy(BaseObject):
    """
    The ability to disallow incoming voice and video note messages in private chats using setUserPrivacySettingRules with userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages and to restrict incoming messages from non-contacts using setNewChatPrivacySettings
    """

    ID: typing.Literal["premiumFeatureMessagePrivacy"] = field(
        default="premiumFeatureMessagePrivacy", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureProfileBadge(BaseObject):
    """
    A badge in the user's profile
    """

    ID: typing.Literal["premiumFeatureProfileBadge"] = field(
        default="premiumFeatureProfileBadge", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureRealTimeChatTranslation(BaseObject):
    """
    Allowed to translate chat messages real-time
    """

    ID: typing.Literal["premiumFeatureRealTimeChatTranslation"] = field(
        default="premiumFeatureRealTimeChatTranslation", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureSavedMessagesTags(BaseObject):
    """
    The ability to use tags in Saved Messages
    """

    ID: typing.Literal["premiumFeatureSavedMessagesTags"] = field(
        default="premiumFeatureSavedMessagesTags", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureUniqueReactions(BaseObject):
    """
    Allowed to use more reactions
    """

    ID: typing.Literal["premiumFeatureUniqueReactions"] = field(
        default="premiumFeatureUniqueReactions", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureUniqueStickers(BaseObject):
    """
    Allowed to use premium stickers with unique effects
    """

    ID: typing.Literal["premiumFeatureUniqueStickers"] = field(
        default="premiumFeatureUniqueStickers", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureUpgradedStories(BaseObject):
    """
    Allowed to use many additional features for stories
    """

    ID: typing.Literal["premiumFeatureUpgradedStories"] = field(
        default="premiumFeatureUpgradedStories", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumFeatureVoiceRecognition(BaseObject):
    """
    The ability to convert voice notes to text
    """

    ID: typing.Literal["premiumFeatureVoiceRecognition"] = field(
        default="premiumFeatureVoiceRecognition", metadata={"alias": "@type"}
    )


PremiumFeature = typing.Union[
    PremiumFeatureAccentColor,
    PremiumFeatureAdvancedChatManagement,
    PremiumFeatureAnimatedProfilePhoto,
    PremiumFeatureAppIcons,
    PremiumFeatureBackgroundForBoth,
    PremiumFeatureBusiness,
    PremiumFeatureChatBoost,
    PremiumFeatureCustomEmoji,
    PremiumFeatureDisabledAds,
    PremiumFeatureEmojiStatus,
    PremiumFeatureForumTopicIcon,
    PremiumFeatureImprovedDownloadSpeed,
    PremiumFeatureIncreasedLimits,
    PremiumFeatureIncreasedUploadFileSize,
    PremiumFeatureLastSeenTimes,
    PremiumFeatureMessageEffects,
    PremiumFeatureMessagePrivacy,
    PremiumFeatureProfileBadge,
    PremiumFeatureRealTimeChatTranslation,
    PremiumFeatureSavedMessagesTags,
    PremiumFeatureUniqueReactions,
    PremiumFeatureUniqueStickers,
    PremiumFeatureUpgradedStories,
    PremiumFeatureVoiceRecognition,
]


@dataclass(slots=True, kw_only=True)
class PremiumFeaturePromotionAnimation(BaseObject):
    """
    Describes a promotion animation for a Premium feature

    :param feature: Premium feature
    :type feature: :class:`PremiumFeature`
    :param animation: Promotion animation for the feature
    :type animation: :class:`Animation`
    """

    ID: typing.Literal["premiumFeaturePromotionAnimation"] = field(
        default="premiumFeaturePromotionAnimation", metadata={"alias": "@type"}
    )
    feature: PremiumFeature
    animation: Animation


@dataclass(slots=True, kw_only=True)
class PremiumFeatures(BaseObject):
    """
    Contains information about features, available to Premium users

    :param features: The list of available features
    :type features: :class:`Vector[PremiumFeature]`
    :param limits: The list of limits, increased for Premium users
    :type limits: :class:`Vector[PremiumLimit]`
    :param payment_link: An internal link to be opened to pay for Telegram Premium if store payment isn't possible; may be null if direct payment isn't available, defaults to None
    :type payment_link: :class:`InternalLinkType`, optional
    """

    ID: typing.Literal["premiumFeatures"] = field(default="premiumFeatures", metadata={"alias": "@type"})
    features: Vector[PremiumFeature]
    limits: Vector[PremiumLimit]
    payment_link: typing.Optional[InternalLinkType] = field(default=None)


@dataclass(slots=True, kw_only=True)
class PremiumGiftCodeInfo(BaseObject):
    """
    Contains information about a Telegram Premium gift code

    :param creation_date: Point in time (Unix timestamp) when the code was created
    :type creation_date: :class:`Int32`
    :param giveaway_message_id: Identifier of the corresponding giveaway message in the creator_id chat; can be 0 or an identifier of a deleted message
    :type giveaway_message_id: :class:`Int53`
    :param month_count: Number of months the Telegram Premium subscription will be active after code activation
    :type month_count: :class:`Int32`
    :param creator_id: Identifier of a chat or a user that created the gift code; may be null if unknown. If null and the code is from messagePremiumGiftCode message, then creator_id from the message can be used, defaults to None
    :type creator_id: :class:`MessageSender`, optional
    :param is_from_giveaway: True, if the gift code was created for a giveaway
    :type is_from_giveaway: :class:`Bool`
    :param user_id: Identifier of a user for which the code was created; 0 if none, defaults to None
    :type user_id: :class:`Int53`, optional
    :param use_date: Point in time (Unix timestamp) when the code was activated; 0 if none, defaults to None
    :type use_date: :class:`Int32`, optional
    """

    ID: typing.Literal["premiumGiftCodeInfo"] = field(default="premiumGiftCodeInfo", metadata={"alias": "@type"})
    creation_date: Int32
    giveaway_message_id: Int53
    month_count: Int32
    creator_id: typing.Optional[MessageSender] = field(default=None)
    is_from_giveaway: Bool = field(default=False)
    user_id: typing.Optional[Int53] = field(default=0)
    use_date: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class PremiumGiftCodePaymentOption(BaseObject):
    """
    Describes an option for creating Telegram Premium gift codes or Telegram Premium giveaway. Use telegramPaymentPurposePremiumGiftCodes or telegramPaymentPurposePremiumGiveaway for out-of-store payments

    :param currency: ISO 4217 currency code for Telegram Premium gift code payment
    :type currency: :class:`String`
    :param amount: The amount to pay, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param discount_percentage: The discount associated with this option, as a percentage
    :type discount_percentage: :class:`Int32`
    :param winner_count: Number of users which will be able to activate the gift codes
    :type winner_count: :class:`Int32`
    :param month_count: Number of months the Telegram Premium subscription will be active
    :type month_count: :class:`Int32`
    :param store_product_quantity: Number of times the store product must be paid
    :type store_product_quantity: :class:`Int32`
    :param sticker: A sticker to be shown along with the gift code; may be null if unknown, defaults to None
    :type sticker: :class:`Sticker`, optional
    :param store_product_id: Identifier of the store product associated with the option; may be empty if none
    :type store_product_id: :class:`String`
    """

    ID: typing.Literal["premiumGiftCodePaymentOption"] = field(
        default="premiumGiftCodePaymentOption", metadata={"alias": "@type"}
    )
    currency: String
    amount: Int53
    discount_percentage: Int32
    winner_count: Int32
    month_count: Int32
    store_product_quantity: Int32
    sticker: typing.Optional[Sticker] = field(default=None)
    store_product_id: String = field(default="")


@dataclass(slots=True, kw_only=True)
class PremiumGiftCodePaymentOptions(BaseObject):
    """
    Contains a list of options for creating Telegram Premium gift codes or Telegram Premium giveaway

    :param options: The list of options
    :type options: :class:`Vector[PremiumGiftCodePaymentOption]`
    """

    ID: typing.Literal["premiumGiftCodePaymentOptions"] = field(
        default="premiumGiftCodePaymentOptions", metadata={"alias": "@type"}
    )
    options: Vector[PremiumGiftCodePaymentOption]


@dataclass(slots=True, kw_only=True)
class PremiumLimit(BaseObject):
    """
    Contains information about a limit, increased for Premium users

    :param type_: The type of the limit
    :type type_: :class:`PremiumLimitType`
    :param default_value: Default value of the limit
    :type default_value: :class:`Int32`
    :param premium_value: Value of the limit for Premium users
    :type premium_value: :class:`Int32`
    """

    ID: typing.Literal["premiumLimit"] = field(default="premiumLimit", metadata={"alias": "@type"})
    type_: PremiumLimitType = field(default=MISSING, metadata={"alias": "type"})
    default_value: Int32
    premium_value: Int32


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeActiveStoryCount(BaseObject):
    """
    The maximum number of active stories
    """

    ID: typing.Literal["premiumLimitTypeActiveStoryCount"] = field(
        default="premiumLimitTypeActiveStoryCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeBioLength(BaseObject):
    """
    The maximum length of the user's bio
    """

    ID: typing.Literal["premiumLimitTypeBioLength"] = field(
        default="premiumLimitTypeBioLength", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeCaptionLength(BaseObject):
    """
    The maximum length of sent media caption
    """

    ID: typing.Literal["premiumLimitTypeCaptionLength"] = field(
        default="premiumLimitTypeCaptionLength", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeChatFolderChosenChatCount(BaseObject):
    """
    The maximum number of pinned and always included, or always excluded chats in a chat folder
    """

    ID: typing.Literal["premiumLimitTypeChatFolderChosenChatCount"] = field(
        default="premiumLimitTypeChatFolderChosenChatCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeChatFolderCount(BaseObject):
    """
    The maximum number of chat folders
    """

    ID: typing.Literal["premiumLimitTypeChatFolderCount"] = field(
        default="premiumLimitTypeChatFolderCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeChatFolderInviteLinkCount(BaseObject):
    """
    The maximum number of invite links for a chat folder
    """

    ID: typing.Literal["premiumLimitTypeChatFolderInviteLinkCount"] = field(
        default="premiumLimitTypeChatFolderInviteLinkCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeCreatedPublicChatCount(BaseObject):
    """
    The maximum number of created public chats
    """

    ID: typing.Literal["premiumLimitTypeCreatedPublicChatCount"] = field(
        default="premiumLimitTypeCreatedPublicChatCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeFavoriteStickerCount(BaseObject):
    """
    The maximum number of favorite stickers
    """

    ID: typing.Literal["premiumLimitTypeFavoriteStickerCount"] = field(
        default="premiumLimitTypeFavoriteStickerCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeMonthlySentStoryCount(BaseObject):
    """
    The maximum number of stories sent per month
    """

    ID: typing.Literal["premiumLimitTypeMonthlySentStoryCount"] = field(
        default="premiumLimitTypeMonthlySentStoryCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypePinnedArchivedChatCount(BaseObject):
    """
    The maximum number of pinned chats in the archive chat list
    """

    ID: typing.Literal["premiumLimitTypePinnedArchivedChatCount"] = field(
        default="premiumLimitTypePinnedArchivedChatCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypePinnedChatCount(BaseObject):
    """
    The maximum number of pinned chats in the main chat list
    """

    ID: typing.Literal["premiumLimitTypePinnedChatCount"] = field(
        default="premiumLimitTypePinnedChatCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypePinnedSavedMessagesTopicCount(BaseObject):
    """
    The maximum number of pinned Saved Messages topics
    """

    ID: typing.Literal["premiumLimitTypePinnedSavedMessagesTopicCount"] = field(
        default="premiumLimitTypePinnedSavedMessagesTopicCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeSavedAnimationCount(BaseObject):
    """
    The maximum number of saved animations
    """

    ID: typing.Literal["premiumLimitTypeSavedAnimationCount"] = field(
        default="premiumLimitTypeSavedAnimationCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeShareableChatFolderCount(BaseObject):
    """
    The maximum number of added shareable chat folders
    """

    ID: typing.Literal["premiumLimitTypeShareableChatFolderCount"] = field(
        default="premiumLimitTypeShareableChatFolderCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeSimilarChatCount(BaseObject):
    """
    The maximum number of received similar chats
    """

    ID: typing.Literal["premiumLimitTypeSimilarChatCount"] = field(
        default="premiumLimitTypeSimilarChatCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeStoryCaptionLength(BaseObject):
    """
    The maximum length of captions of sent stories
    """

    ID: typing.Literal["premiumLimitTypeStoryCaptionLength"] = field(
        default="premiumLimitTypeStoryCaptionLength", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeStorySuggestedReactionAreaCount(BaseObject):
    """
    The maximum number of suggested reaction areas on a story
    """

    ID: typing.Literal["premiumLimitTypeStorySuggestedReactionAreaCount"] = field(
        default="premiumLimitTypeStorySuggestedReactionAreaCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeSupergroupCount(BaseObject):
    """
    The maximum number of joined supergroups and channels
    """

    ID: typing.Literal["premiumLimitTypeSupergroupCount"] = field(
        default="premiumLimitTypeSupergroupCount", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumLimitTypeWeeklySentStoryCount(BaseObject):
    """
    The maximum number of stories sent per week
    """

    ID: typing.Literal["premiumLimitTypeWeeklySentStoryCount"] = field(
        default="premiumLimitTypeWeeklySentStoryCount", metadata={"alias": "@type"}
    )


PremiumLimitType = typing.Union[
    PremiumLimitTypeActiveStoryCount,
    PremiumLimitTypeBioLength,
    PremiumLimitTypeCaptionLength,
    PremiumLimitTypeChatFolderChosenChatCount,
    PremiumLimitTypeChatFolderCount,
    PremiumLimitTypeChatFolderInviteLinkCount,
    PremiumLimitTypeCreatedPublicChatCount,
    PremiumLimitTypeFavoriteStickerCount,
    PremiumLimitTypeMonthlySentStoryCount,
    PremiumLimitTypePinnedArchivedChatCount,
    PremiumLimitTypePinnedChatCount,
    PremiumLimitTypePinnedSavedMessagesTopicCount,
    PremiumLimitTypeSavedAnimationCount,
    PremiumLimitTypeShareableChatFolderCount,
    PremiumLimitTypeSimilarChatCount,
    PremiumLimitTypeStoryCaptionLength,
    PremiumLimitTypeStorySuggestedReactionAreaCount,
    PremiumLimitTypeSupergroupCount,
    PremiumLimitTypeWeeklySentStoryCount,
]


@dataclass(slots=True, kw_only=True)
class PremiumPaymentOption(BaseObject):
    """
    Describes an option for buying Telegram Premium to a user

    :param currency: ISO 4217 currency code for Telegram Premium subscription payment
    :type currency: :class:`String`
    :param amount: The amount to pay, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param discount_percentage: The discount associated with this option, as a percentage
    :type discount_percentage: :class:`Int32`
    :param month_count: Number of months the Telegram Premium subscription will be active. Use getPremiumInfoSticker to get the sticker to be used as representation of the Telegram Premium subscription
    :type month_count: :class:`Int32`
    :param store_product_id: Identifier of the store product associated with the option
    :type store_product_id: :class:`String`
    :param payment_link: An internal link to be opened for buying Telegram Premium to the user if store payment isn't possible; may be null if direct payment isn't available, defaults to None
    :type payment_link: :class:`InternalLinkType`, optional
    """

    ID: typing.Literal["premiumPaymentOption"] = field(default="premiumPaymentOption", metadata={"alias": "@type"})
    currency: String
    amount: Int53
    discount_percentage: Int32
    month_count: Int32
    store_product_id: String
    payment_link: typing.Optional[InternalLinkType] = field(default=None)


@dataclass(slots=True, kw_only=True)
class PremiumSourceBusinessFeature(BaseObject):
    """
    A user tried to use a Business feature

    :param feature: The used feature; pass null if none specific feature was used, defaults to None
    :type feature: :class:`BusinessFeature`, optional
    """

    ID: typing.Literal["premiumSourceBusinessFeature"] = field(
        default="premiumSourceBusinessFeature", metadata={"alias": "@type"}
    )
    feature: typing.Optional[BusinessFeature] = field(default=None)


@dataclass(slots=True, kw_only=True)
class PremiumSourceFeature(BaseObject):
    """
    A user tried to use a Premium feature

    :param feature: The used feature
    :type feature: :class:`PremiumFeature`
    """

    ID: typing.Literal["premiumSourceFeature"] = field(default="premiumSourceFeature", metadata={"alias": "@type"})
    feature: PremiumFeature


@dataclass(slots=True, kw_only=True)
class PremiumSourceLimitExceeded(BaseObject):
    """
    A limit was exceeded

    :param limit_type: Type of the exceeded limit
    :type limit_type: :class:`PremiumLimitType`
    """

    ID: typing.Literal["premiumSourceLimitExceeded"] = field(
        default="premiumSourceLimitExceeded", metadata={"alias": "@type"}
    )
    limit_type: PremiumLimitType


@dataclass(slots=True, kw_only=True)
class PremiumSourceLink(BaseObject):
    """
    A user opened an internal link of the type internalLinkTypePremiumFeatures

    :param referrer: The referrer from the link
    :type referrer: :class:`String`
    """

    ID: typing.Literal["premiumSourceLink"] = field(default="premiumSourceLink", metadata={"alias": "@type"})
    referrer: String


@dataclass(slots=True, kw_only=True)
class PremiumSourceSettings(BaseObject):
    """
    A user opened the Premium features screen from settings
    """

    ID: typing.Literal["premiumSourceSettings"] = field(default="premiumSourceSettings", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class PremiumSourceStoryFeature(BaseObject):
    """
    A user tried to use a Premium story feature

    :param feature: The used feature
    :type feature: :class:`PremiumStoryFeature`
    """

    ID: typing.Literal["premiumSourceStoryFeature"] = field(
        default="premiumSourceStoryFeature", metadata={"alias": "@type"}
    )
    feature: PremiumStoryFeature


PremiumSource = typing.Union[
    PremiumSourceBusinessFeature,
    PremiumSourceFeature,
    PremiumSourceLimitExceeded,
    PremiumSourceLink,
    PremiumSourceSettings,
    PremiumSourceStoryFeature,
]


@dataclass(slots=True, kw_only=True)
class PremiumState(BaseObject):
    """
    Contains state of Telegram Premium subscription and promotion videos for Premium features

    :param state: Text description of the state of the current Premium subscription; may be empty if the current user has no Telegram Premium subscription
    :type state: :class:`FormattedText`
    :param payment_options: The list of available options for buying Telegram Premium
    :type payment_options: :class:`Vector[PremiumStatePaymentOption]`
    :param animations: The list of available promotion animations for Premium features
    :type animations: :class:`Vector[PremiumFeaturePromotionAnimation]`
    :param business_animations: The list of available promotion animations for Business features
    :type business_animations: :class:`Vector[BusinessFeaturePromotionAnimation]`
    """

    ID: typing.Literal["premiumState"] = field(default="premiumState", metadata={"alias": "@type"})
    state: FormattedText
    payment_options: Vector[PremiumStatePaymentOption]
    animations: Vector[PremiumFeaturePromotionAnimation]
    business_animations: Vector[BusinessFeaturePromotionAnimation]


@dataclass(slots=True, kw_only=True)
class PremiumStatePaymentOption(BaseObject):
    """
    Describes an option for buying or upgrading Telegram Premium for self

    :param payment_option: Information about the payment option
    :type payment_option: :class:`PremiumPaymentOption`
    :param last_transaction_id: Identifier of the last in-store transaction for the currently used option
    :type last_transaction_id: :class:`String`
    :param is_current: True, if this is the currently used Telegram Premium subscription option
    :type is_current: :class:`Bool`
    :param is_upgrade: True, if the payment option can be used to upgrade the existing Telegram Premium subscription
    :type is_upgrade: :class:`Bool`
    """

    ID: typing.Literal["premiumStatePaymentOption"] = field(
        default="premiumStatePaymentOption", metadata={"alias": "@type"}
    )
    payment_option: PremiumPaymentOption
    last_transaction_id: String
    is_current: Bool = field(default=False)
    is_upgrade: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PremiumStoryFeatureCustomExpirationDuration(BaseObject):
    """
    The ability to set custom expiration duration for stories
    """

    ID: typing.Literal["premiumStoryFeatureCustomExpirationDuration"] = field(
        default="premiumStoryFeatureCustomExpirationDuration", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumStoryFeatureLinksAndFormatting(BaseObject):
    """
    The ability to use links and formatting in story caption, and use inputStoryAreaTypeLink areas
    """

    ID: typing.Literal["premiumStoryFeatureLinksAndFormatting"] = field(
        default="premiumStoryFeatureLinksAndFormatting", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumStoryFeaturePermanentViewsHistory(BaseObject):
    """
    The ability to check who opened the current user's stories after they expire
    """

    ID: typing.Literal["premiumStoryFeaturePermanentViewsHistory"] = field(
        default="premiumStoryFeaturePermanentViewsHistory", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumStoryFeaturePriorityOrder(BaseObject):
    """
    Stories of the current user are displayed before stories of non-Premium contacts, supergroups, and channels
    """

    ID: typing.Literal["premiumStoryFeaturePriorityOrder"] = field(
        default="premiumStoryFeaturePriorityOrder", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumStoryFeatureSaveStories(BaseObject):
    """
    The ability to save other's unprotected stories
    """

    ID: typing.Literal["premiumStoryFeatureSaveStories"] = field(
        default="premiumStoryFeatureSaveStories", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumStoryFeatureStealthMode(BaseObject):
    """
    The ability to hide the fact that the user viewed other's stories
    """

    ID: typing.Literal["premiumStoryFeatureStealthMode"] = field(
        default="premiumStoryFeatureStealthMode", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PremiumStoryFeatureVideoQuality(BaseObject):
    """
    The ability to choose better quality for viewed stories
    """

    ID: typing.Literal["premiumStoryFeatureVideoQuality"] = field(
        default="premiumStoryFeatureVideoQuality", metadata={"alias": "@type"}
    )


PremiumStoryFeature = typing.Union[
    PremiumStoryFeatureCustomExpirationDuration,
    PremiumStoryFeatureLinksAndFormatting,
    PremiumStoryFeaturePermanentViewsHistory,
    PremiumStoryFeaturePriorityOrder,
    PremiumStoryFeatureSaveStories,
    PremiumStoryFeatureStealthMode,
    PremiumStoryFeatureVideoQuality,
]


@dataclass(slots=True, kw_only=True)
class PrepaidGiveaway(BaseObject):
    """
    Describes a prepaid giveaway

    :param id: Unique identifier of the prepaid giveaway
    :type id: :class:`Int64`
    :param winner_count: Number of users which will receive giveaway prize
    :type winner_count: :class:`Int32`
    :param prize: Prize of the giveaway
    :type prize: :class:`GiveawayPrize`
    :param boost_count: The number of boosts received by the chat from the giveaway; for Telegram Star giveaways only
    :type boost_count: :class:`Int32`
    :param payment_date: Point in time (Unix timestamp) when the giveaway was paid
    :type payment_date: :class:`Int32`
    """

    ID: typing.Literal["prepaidGiveaway"] = field(default="prepaidGiveaway", metadata={"alias": "@type"})
    id: Int64
    winner_count: Int32
    prize: GiveawayPrize
    boost_count: Int32
    payment_date: Int32


@dataclass(slots=True, kw_only=True)
class PreparedInlineMessage(BaseObject):
    """
    Represents a ready to send inline message. Use sendInlineQueryResultMessage to send the message

    :param inline_query_id: Unique identifier of the inline query to pass to sendInlineQueryResultMessage
    :type inline_query_id: :class:`Int64`
    :param result: Resulted inline message of the query
    :type result: :class:`InlineQueryResult`
    :param chat_types: Types of the chats to which the message can be sent
    :type chat_types: :class:`TargetChatTypes`
    """

    ID: typing.Literal["preparedInlineMessage"] = field(default="preparedInlineMessage", metadata={"alias": "@type"})
    inline_query_id: Int64
    result: InlineQueryResult
    chat_types: TargetChatTypes


@dataclass(slots=True, kw_only=True)
class PreparedInlineMessageId(BaseObject):
    """
    Represents an inline message that can be sent via the bot

    :param id: Unique identifier for the message
    :type id: :class:`String`
    :param expiration_date: Point in time (Unix timestamp) when the message can't be used anymore
    :type expiration_date: :class:`Int32`
    """

    ID: typing.Literal["preparedInlineMessageId"] = field(
        default="preparedInlineMessageId", metadata={"alias": "@type"}
    )
    id: String
    expiration_date: Int32


@dataclass(slots=True, kw_only=True)
class ProductInfo(BaseObject):
    """
    Contains information about a product that can be paid with invoice

    :param title: Product title
    :type title: :class:`String`
    :param description: Product description
    :type description: :class:`FormattedText`
    :param photo: Product photo; may be null, defaults to None
    :type photo: :class:`Photo`, optional
    """

    ID: typing.Literal["productInfo"] = field(default="productInfo", metadata={"alias": "@type"})
    title: String
    description: FormattedText
    photo: typing.Optional[Photo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class ProfileAccentColor(BaseObject):
    """
    Contains information about supported accent color for user profile photo background

    :param id: Profile accent color identifier
    :type id: :class:`Int32`
    :param light_theme_colors: Accent colors expected to be used in light themes
    :type light_theme_colors: :class:`ProfileAccentColors`
    :param dark_theme_colors: Accent colors expected to be used in dark themes
    :type dark_theme_colors: :class:`ProfileAccentColors`
    :param min_supergroup_chat_boost_level: The minimum chat boost level required to use the color in a supergroup chat
    :type min_supergroup_chat_boost_level: :class:`Int32`
    :param min_channel_chat_boost_level: The minimum chat boost level required to use the color in a channel chat
    :type min_channel_chat_boost_level: :class:`Int32`
    """

    ID: typing.Literal["profileAccentColor"] = field(default="profileAccentColor", metadata={"alias": "@type"})
    id: Int32
    light_theme_colors: ProfileAccentColors
    dark_theme_colors: ProfileAccentColors
    min_supergroup_chat_boost_level: Int32
    min_channel_chat_boost_level: Int32


@dataclass(slots=True, kw_only=True)
class ProfileAccentColors(BaseObject):
    """
    Contains information about supported accent colors for user profile photo background in RGB format

    :param palette_colors: The list of 1-2 colors in RGB format, describing the colors, as expected to be shown in the color palette settings
    :type palette_colors: :class:`Vector[Int32]`
    :param background_colors: The list of 1-2 colors in RGB format, describing the colors, as expected to be used for the profile photo background
    :type background_colors: :class:`Vector[Int32]`
    :param story_colors: The list of 2 colors in RGB format, describing the colors of the gradient to be used for the unread active story indicator around profile photo
    :type story_colors: :class:`Vector[Int32]`
    """

    ID: typing.Literal["profileAccentColors"] = field(default="profileAccentColors", metadata={"alias": "@type"})
    palette_colors: Vector[Int32]
    background_colors: Vector[Int32]
    story_colors: Vector[Int32]


@dataclass(slots=True, kw_only=True)
class ProfilePhoto(BaseObject):
    """
    Describes a user profile photo

    :param small: A small (160x160) user profile photo. The file can be downloaded only before the photo is changed
    :type small: :class:`File`
    :param big: A big (640x640) user profile photo. The file can be downloaded only before the photo is changed
    :type big: :class:`File`
    :param minithumbnail: User profile photo minithumbnail; may be null, defaults to None
    :type minithumbnail: :class:`Minithumbnail`, optional
    :param id: Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of user profile photos
    :type id: :class:`Int64`
    :param has_animation: True, if the photo has animated variant
    :type has_animation: :class:`Bool`
    :param is_personal: True, if the photo is visible only for the current user
    :type is_personal: :class:`Bool`
    """

    ID: typing.Literal["profilePhoto"] = field(default="profilePhoto", metadata={"alias": "@type"})
    small: File
    big: File
    minithumbnail: typing.Optional[Minithumbnail] = field(default=None)
    id: Int64 = field(default=0)
    has_animation: Bool = field(default=False)
    is_personal: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class Proxies(BaseObject):
    """
    Represents a list of proxy servers

    :param proxies: List of proxy servers
    :type proxies: :class:`Vector[Proxy]`
    """

    ID: typing.Literal["proxies"] = field(default="proxies", metadata={"alias": "@type"})
    proxies: Vector[Proxy]


@dataclass(slots=True, kw_only=True)
class Proxy(BaseObject):
    """
    Contains information about a proxy server

    :param id: Unique identifier of the proxy
    :type id: :class:`Int32`
    :param server: Proxy server domain or IP address
    :type server: :class:`String`
    :param port: Proxy server port
    :type port: :class:`Int32`
    :param type_: Type of the proxy
    :type type_: :class:`ProxyType`
    :param last_used_date: Point in time (Unix timestamp) when the proxy was last used; 0 if never
    :type last_used_date: :class:`Int32`
    :param is_enabled: True, if the proxy is enabled now
    :type is_enabled: :class:`Bool`
    """

    ID: typing.Literal["proxy"] = field(default="proxy", metadata={"alias": "@type"})
    id: Int32
    server: String
    port: Int32
    type_: ProxyType = field(default=MISSING, metadata={"alias": "type"})
    last_used_date: Int32 = field(default=0)
    is_enabled: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ProxyTypeHttp(BaseObject):
    """
    A HTTP transparent proxy server

    :param username: Username for logging in; may be empty
    :type username: :class:`String`
    :param password: Password for logging in; may be empty
    :type password: :class:`String`
    :param http_only: Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method
    :type http_only: :class:`Bool`
    """

    ID: typing.Literal["proxyTypeHttp"] = field(default="proxyTypeHttp", metadata={"alias": "@type"})
    username: String = field(default="")
    password: String = field(default="")
    http_only: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ProxyTypeMtproto(BaseObject):
    """
    An MTProto proxy server

    :param secret: The proxy's secret in hexadecimal encoding
    :type secret: :class:`String`
    """

    ID: typing.Literal["proxyTypeMtproto"] = field(default="proxyTypeMtproto", metadata={"alias": "@type"})
    secret: String


@dataclass(slots=True, kw_only=True)
class ProxyTypeSocks5(BaseObject):
    """
    A SOCKS5 proxy server

    :param username: Username for logging in; may be empty
    :type username: :class:`String`
    :param password: Password for logging in; may be empty
    :type password: :class:`String`
    """

    ID: typing.Literal["proxyTypeSocks5"] = field(default="proxyTypeSocks5", metadata={"alias": "@type"})
    username: String = field(default="")
    password: String = field(default="")


ProxyType = typing.Union[
    ProxyTypeHttp,
    ProxyTypeMtproto,
    ProxyTypeSocks5,
]


@dataclass(slots=True, kw_only=True)
class PublicChatTypeHasUsername(BaseObject):
    """
    The chat is public, because it has an active username
    """

    ID: typing.Literal["publicChatTypeHasUsername"] = field(
        default="publicChatTypeHasUsername", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PublicChatTypeIsLocationBased(BaseObject):
    """
    The chat is public, because it is a location-based supergroup
    """

    ID: typing.Literal["publicChatTypeIsLocationBased"] = field(
        default="publicChatTypeIsLocationBased", metadata={"alias": "@type"}
    )


PublicChatType = typing.Union[
    PublicChatTypeHasUsername,
    PublicChatTypeIsLocationBased,
]


@dataclass(slots=True, kw_only=True)
class PublicForwardMessage(BaseObject):
    """
    Contains a public forward as a message

    :param message: Information about the message
    :type message: :class:`Message`
    """

    ID: typing.Literal["publicForwardMessage"] = field(default="publicForwardMessage", metadata={"alias": "@type"})
    message: Message


@dataclass(slots=True, kw_only=True)
class PublicForwardStory(BaseObject):
    """
    Contains a public repost to a story

    :param story: Information about the story
    :type story: :class:`Story`
    """

    ID: typing.Literal["publicForwardStory"] = field(default="publicForwardStory", metadata={"alias": "@type"})
    story: Story


PublicForward = typing.Union[
    PublicForwardMessage,
    PublicForwardStory,
]


@dataclass(slots=True, kw_only=True)
class PublicForwards(BaseObject):
    """
    Represents a list of public forwards and reposts as a story of a message or a story

    :param total_count: Approximate total number of messages and stories found
    :type total_count: :class:`Int32`
    :param forwards: List of found public forwards and reposts
    :type forwards: :class:`Vector[PublicForward]`
    :param next_offset: The offset for the next request. If empty, then there are no more results
    :type next_offset: :class:`String`
    """

    ID: typing.Literal["publicForwards"] = field(default="publicForwards", metadata={"alias": "@type"})
    total_count: Int32
    forwards: Vector[PublicForward]
    next_offset: String = field(default="")


@dataclass(slots=True, kw_only=True)
class PushMessageContentAnimation(BaseObject):
    """
    An animation message (GIF-style).

    :param caption: Animation caption
    :type caption: :class:`String`
    :param animation: Message content; may be null, defaults to None
    :type animation: :class:`Animation`, optional
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentAnimation"] = field(
        default="pushMessageContentAnimation", metadata={"alias": "@type"}
    )
    caption: String
    animation: typing.Optional[Animation] = field(default=None)
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentAudio(BaseObject):
    """
    An audio message

    :param audio: Message content; may be null, defaults to None
    :type audio: :class:`Audio`, optional
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentAudio"] = field(
        default="pushMessageContentAudio", metadata={"alias": "@type"}
    )
    audio: typing.Optional[Audio] = field(default=None)
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentBasicGroupChatCreate(BaseObject):
    """
    A newly created basic group
    """

    ID: typing.Literal["pushMessageContentBasicGroupChatCreate"] = field(
        default="pushMessageContentBasicGroupChatCreate", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PushMessageContentChatAddMembers(BaseObject):
    """
    New chat members were invited to a group

    :param member_name: Name of the added member
    :type member_name: :class:`String`
    :param is_current_user: True, if the current user was added to the group
    :type is_current_user: :class:`Bool`
    :param is_returned: True, if the user has returned to the group themselves
    :type is_returned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentChatAddMembers"] = field(
        default="pushMessageContentChatAddMembers", metadata={"alias": "@type"}
    )
    member_name: String
    is_current_user: Bool = field(default=False)
    is_returned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentChatChangePhoto(BaseObject):
    """
    A chat photo was edited
    """

    ID: typing.Literal["pushMessageContentChatChangePhoto"] = field(
        default="pushMessageContentChatChangePhoto", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PushMessageContentChatChangeTitle(BaseObject):
    """
    A chat title was edited

    :param title: New chat title
    :type title: :class:`String`
    """

    ID: typing.Literal["pushMessageContentChatChangeTitle"] = field(
        default="pushMessageContentChatChangeTitle", metadata={"alias": "@type"}
    )
    title: String


@dataclass(slots=True, kw_only=True)
class PushMessageContentChatDeleteMember(BaseObject):
    """
    A chat member was deleted

    :param member_name: Name of the deleted member
    :type member_name: :class:`String`
    :param is_current_user: True, if the current user was deleted from the group
    :type is_current_user: :class:`Bool`
    :param is_left: True, if the user has left the group themselves
    :type is_left: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentChatDeleteMember"] = field(
        default="pushMessageContentChatDeleteMember", metadata={"alias": "@type"}
    )
    member_name: String
    is_current_user: Bool = field(default=False)
    is_left: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentChatJoinByLink(BaseObject):
    """
    A new member joined the chat via an invite link
    """

    ID: typing.Literal["pushMessageContentChatJoinByLink"] = field(
        default="pushMessageContentChatJoinByLink", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PushMessageContentChatJoinByRequest(BaseObject):
    """
    A new member was accepted to the chat by an administrator
    """

    ID: typing.Literal["pushMessageContentChatJoinByRequest"] = field(
        default="pushMessageContentChatJoinByRequest", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PushMessageContentChatSetBackground(BaseObject):
    """
    A chat background was edited

    :param is_same: True, if the set background is the same as the background of the current user
    :type is_same: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentChatSetBackground"] = field(
        default="pushMessageContentChatSetBackground", metadata={"alias": "@type"}
    )
    is_same: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentChatSetTheme(BaseObject):
    """
    A chat theme was edited

    :param theme_name: If non-empty, name of a new theme, set for the chat. Otherwise, the chat theme was reset to the default one
    :type theme_name: :class:`String`
    """

    ID: typing.Literal["pushMessageContentChatSetTheme"] = field(
        default="pushMessageContentChatSetTheme", metadata={"alias": "@type"}
    )
    theme_name: String = field(default="")


@dataclass(slots=True, kw_only=True)
class PushMessageContentContact(BaseObject):
    """
    A message with a user contact

    :param name: Contact's name
    :type name: :class:`String`
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentContact"] = field(
        default="pushMessageContentContact", metadata={"alias": "@type"}
    )
    name: String
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentContactRegistered(BaseObject):
    """
    A contact has registered with Telegram
    """

    ID: typing.Literal["pushMessageContentContactRegistered"] = field(
        default="pushMessageContentContactRegistered", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PushMessageContentDocument(BaseObject):
    """
    A document message (a general file)

    :param document: Message content; may be null, defaults to None
    :type document: :class:`Document`, optional
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentDocument"] = field(
        default="pushMessageContentDocument", metadata={"alias": "@type"}
    )
    document: typing.Optional[Document] = field(default=None)
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentGame(BaseObject):
    """
    A message with a game

    :param title: Game title, empty for pinned game message
    :type title: :class:`String`
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentGame"] = field(default="pushMessageContentGame", metadata={"alias": "@type"})
    title: String
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentGameScore(BaseObject):
    """
    A new high score was achieved in a game

    :param title: Game title, empty for pinned message
    :type title: :class:`String`
    :param score: New score, 0 for pinned message
    :type score: :class:`Int32`
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentGameScore"] = field(
        default="pushMessageContentGameScore", metadata={"alias": "@type"}
    )
    title: String
    score: Int32 = field(default=0)
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentGift(BaseObject):
    """
    A message with a gift

    :param star_count: Number of Telegram Stars that sender paid for the gift
    :type star_count: :class:`Int53`
    """

    ID: typing.Literal["pushMessageContentGift"] = field(default="pushMessageContentGift", metadata={"alias": "@type"})
    star_count: Int53


@dataclass(slots=True, kw_only=True)
class PushMessageContentGiveaway(BaseObject):
    """
    A message with a giveaway

    :param prize: Prize of the giveaway; may be null for pinned message, defaults to None
    :type prize: :class:`GiveawayPrize`, optional
    :param winner_count: Number of users which will receive giveaway prizes; 0 for pinned message
    :type winner_count: :class:`Int32`
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentGiveaway"] = field(
        default="pushMessageContentGiveaway", metadata={"alias": "@type"}
    )
    prize: typing.Optional[GiveawayPrize] = field(default=None)
    winner_count: Int32 = field(default=0)
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentHidden(BaseObject):
    """
    A general message with hidden content

    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentHidden"] = field(
        default="pushMessageContentHidden", metadata={"alias": "@type"}
    )
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentInvoice(BaseObject):
    """
    A message with an invoice from a bot

    :param price: Product price
    :type price: :class:`String`
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentInvoice"] = field(
        default="pushMessageContentInvoice", metadata={"alias": "@type"}
    )
    price: String
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentLocation(BaseObject):
    """
    A message with a location

    :param is_live: True, if the location is live
    :type is_live: :class:`Bool`
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentLocation"] = field(
        default="pushMessageContentLocation", metadata={"alias": "@type"}
    )
    is_live: Bool = field(default=False)
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentMediaAlbum(BaseObject):
    """
    A media album

    :param total_count: Number of messages in the album
    :type total_count: :class:`Int32`
    :param has_photos: True, if the album has at least one photo
    :type has_photos: :class:`Bool`
    :param has_videos: True, if the album has at least one video file
    :type has_videos: :class:`Bool`
    :param has_audios: True, if the album has at least one audio file
    :type has_audios: :class:`Bool`
    :param has_documents: True, if the album has at least one document
    :type has_documents: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentMediaAlbum"] = field(
        default="pushMessageContentMediaAlbum", metadata={"alias": "@type"}
    )
    total_count: Int32
    has_photos: Bool = field(default=False)
    has_videos: Bool = field(default=False)
    has_audios: Bool = field(default=False)
    has_documents: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentMessageForwards(BaseObject):
    """
    A forwarded messages

    :param total_count: Number of forwarded messages
    :type total_count: :class:`Int32`
    """

    ID: typing.Literal["pushMessageContentMessageForwards"] = field(
        default="pushMessageContentMessageForwards", metadata={"alias": "@type"}
    )
    total_count: Int32


@dataclass(slots=True, kw_only=True)
class PushMessageContentPaidMedia(BaseObject):
    """
    A message with paid media

    :param star_count: Number of Telegram Stars needed to buy access to the media in the message; 0 for pinned message
    :type star_count: :class:`Int53`
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentPaidMedia"] = field(
        default="pushMessageContentPaidMedia", metadata={"alias": "@type"}
    )
    star_count: Int53 = field(default=0)
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentPhoto(BaseObject):
    """
    A photo message

    :param caption: Photo caption
    :type caption: :class:`String`
    :param photo: Message content; may be null, defaults to None
    :type photo: :class:`Photo`, optional
    :param is_secret: True, if the photo is secret
    :type is_secret: :class:`Bool`
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentPhoto"] = field(
        default="pushMessageContentPhoto", metadata={"alias": "@type"}
    )
    caption: String
    photo: typing.Optional[Photo] = field(default=None)
    is_secret: Bool = field(default=False)
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentPoll(BaseObject):
    """
    A message with a poll

    :param question: Poll question
    :type question: :class:`String`
    :param is_regular: True, if the poll is regular and not in quiz mode
    :type is_regular: :class:`Bool`
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentPoll"] = field(default="pushMessageContentPoll", metadata={"alias": "@type"})
    question: String
    is_regular: Bool = field(default=False)
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentPremiumGiftCode(BaseObject):
    """
    A message with a Telegram Premium gift code created for the user

    :param month_count: Number of months the Telegram Premium subscription will be active after code activation
    :type month_count: :class:`Int32`
    """

    ID: typing.Literal["pushMessageContentPremiumGiftCode"] = field(
        default="pushMessageContentPremiumGiftCode", metadata={"alias": "@type"}
    )
    month_count: Int32


@dataclass(slots=True, kw_only=True)
class PushMessageContentRecurringPayment(BaseObject):
    """
    A new recurring payment was made by the current user

    :param amount: The paid amount
    :type amount: :class:`String`
    """

    ID: typing.Literal["pushMessageContentRecurringPayment"] = field(
        default="pushMessageContentRecurringPayment", metadata={"alias": "@type"}
    )
    amount: String


@dataclass(slots=True, kw_only=True)
class PushMessageContentScreenshotTaken(BaseObject):
    """
    A screenshot of a message in the chat has been taken
    """

    ID: typing.Literal["pushMessageContentScreenshotTaken"] = field(
        default="pushMessageContentScreenshotTaken", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PushMessageContentSticker(BaseObject):
    """
    A message with a sticker

    :param sticker: Message content; may be null, defaults to None
    :type sticker: :class:`Sticker`, optional
    :param emoji: Emoji corresponding to the sticker; may be empty
    :type emoji: :class:`String`
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentSticker"] = field(
        default="pushMessageContentSticker", metadata={"alias": "@type"}
    )
    sticker: typing.Optional[Sticker] = field(default=None)
    emoji: String = field(default="")
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentStory(BaseObject):
    """
    A message with a story

    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentStory"] = field(
        default="pushMessageContentStory", metadata={"alias": "@type"}
    )
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentSuggestProfilePhoto(BaseObject):
    """
    A profile photo was suggested to the user
    """

    ID: typing.Literal["pushMessageContentSuggestProfilePhoto"] = field(
        default="pushMessageContentSuggestProfilePhoto", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class PushMessageContentText(BaseObject):
    """
    A text message

    :param text: Message text
    :type text: :class:`String`
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentText"] = field(default="pushMessageContentText", metadata={"alias": "@type"})
    text: String
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentUpgradedGift(BaseObject):
    """
    A message with an upgraded gift

    :param is_upgrade: True, if the gift was obtained by upgrading of a previously received gift; otherwise, this is a transferred gift
    :type is_upgrade: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentUpgradedGift"] = field(
        default="pushMessageContentUpgradedGift", metadata={"alias": "@type"}
    )
    is_upgrade: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentVideo(BaseObject):
    """
    A video message

    :param caption: Video caption
    :type caption: :class:`String`
    :param video: Message content; may be null, defaults to None
    :type video: :class:`Video`, optional
    :param is_secret: True, if the video is secret
    :type is_secret: :class:`Bool`
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentVideo"] = field(
        default="pushMessageContentVideo", metadata={"alias": "@type"}
    )
    caption: String
    video: typing.Optional[Video] = field(default=None)
    is_secret: Bool = field(default=False)
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentVideoNote(BaseObject):
    """
    A video note message

    :param video_note: Message content; may be null, defaults to None
    :type video_note: :class:`VideoNote`, optional
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentVideoNote"] = field(
        default="pushMessageContentVideoNote", metadata={"alias": "@type"}
    )
    video_note: typing.Optional[VideoNote] = field(default=None)
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class PushMessageContentVoiceNote(BaseObject):
    """
    A voice note message

    :param voice_note: Message content; may be null, defaults to None
    :type voice_note: :class:`VoiceNote`, optional
    :param is_pinned: True, if the message is a pinned message with the specified content
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["pushMessageContentVoiceNote"] = field(
        default="pushMessageContentVoiceNote", metadata={"alias": "@type"}
    )
    voice_note: typing.Optional[VoiceNote] = field(default=None)
    is_pinned: Bool = field(default=False)


PushMessageContent = typing.Union[
    PushMessageContentAnimation,
    PushMessageContentAudio,
    PushMessageContentBasicGroupChatCreate,
    PushMessageContentChatAddMembers,
    PushMessageContentChatChangePhoto,
    PushMessageContentChatChangeTitle,
    PushMessageContentChatDeleteMember,
    PushMessageContentChatJoinByLink,
    PushMessageContentChatJoinByRequest,
    PushMessageContentChatSetBackground,
    PushMessageContentChatSetTheme,
    PushMessageContentContact,
    PushMessageContentContactRegistered,
    PushMessageContentDocument,
    PushMessageContentGame,
    PushMessageContentGameScore,
    PushMessageContentGift,
    PushMessageContentGiveaway,
    PushMessageContentHidden,
    PushMessageContentInvoice,
    PushMessageContentLocation,
    PushMessageContentMediaAlbum,
    PushMessageContentMessageForwards,
    PushMessageContentPaidMedia,
    PushMessageContentPhoto,
    PushMessageContentPoll,
    PushMessageContentPremiumGiftCode,
    PushMessageContentRecurringPayment,
    PushMessageContentScreenshotTaken,
    PushMessageContentSticker,
    PushMessageContentStory,
    PushMessageContentSuggestProfilePhoto,
    PushMessageContentText,
    PushMessageContentUpgradedGift,
    PushMessageContentVideo,
    PushMessageContentVideoNote,
    PushMessageContentVoiceNote,
]


@dataclass(slots=True, kw_only=True)
class PushReceiverId(BaseObject):
    """
    Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification

    :param id: The globally unique identifier of push notification subscription
    :type id: :class:`Int64`
    """

    ID: typing.Literal["pushReceiverId"] = field(default="pushReceiverId", metadata={"alias": "@type"})
    id: Int64


@dataclass(slots=True, kw_only=True)
class QuickReplyMessage(BaseObject):
    """
    Describes a message that can be used for quick reply

    :param id: Unique message identifier among all quick replies
    :type id: :class:`Int53`
    :param via_bot_user_id: If non-zero, the user identifier of the bot through which this message was sent
    :type via_bot_user_id: :class:`Int53`
    :param content: Content of the message
    :type content: :class:`MessageContent`
    :param sending_state: The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent, defaults to None
    :type sending_state: :class:`MessageSendingState`, optional
    :param reply_markup: Inline keyboard reply markup for the message; may be null if none, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    :param can_be_edited: True, if the message can be edited
    :type can_be_edited: :class:`Bool`
    :param reply_to_message_id: The identifier of the quick reply message to which the message replies; 0 if none, defaults to None
    :type reply_to_message_id: :class:`Int53`, optional
    :param media_album_id: Unique identifier of an album this message belongs to; 0 if none. Only audios, documents, photos and videos can be grouped together in albums, defaults to None
    :type media_album_id: :class:`Int64`, optional
    """

    ID: typing.Literal["quickReplyMessage"] = field(default="quickReplyMessage", metadata={"alias": "@type"})
    id: Int53
    via_bot_user_id: Int53
    content: MessageContent
    sending_state: typing.Optional[MessageSendingState] = field(default=None)
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)
    can_be_edited: Bool = field(default=False)
    reply_to_message_id: typing.Optional[Int53] = field(default=0)
    media_album_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class QuickReplyMessages(BaseObject):
    """
    Contains a list of quick reply messages

    :param messages: List of quick reply messages; messages may be null, defaults to None
    :type messages: :class:`Vector[QuickReplyMessage]`, optional
    """

    ID: typing.Literal["quickReplyMessages"] = field(default="quickReplyMessages", metadata={"alias": "@type"})
    messages: Vector[typing.Optional[QuickReplyMessage]] = field(default=None)


@dataclass(slots=True, kw_only=True)
class QuickReplyShortcut(BaseObject):
    """
    Describes a shortcut that can be used for a quick reply

    :param id: Unique shortcut identifier
    :type id: :class:`Int32`
    :param name: The name of the shortcut that can be used to use the shortcut
    :type name: :class:`String`
    :param first_message: The first shortcut message
    :type first_message: :class:`QuickReplyMessage`
    :param message_count: The total number of messages in the shortcut
    :type message_count: :class:`Int32`
    """

    ID: typing.Literal["quickReplyShortcut"] = field(default="quickReplyShortcut", metadata={"alias": "@type"})
    id: Int32
    name: String
    first_message: QuickReplyMessage
    message_count: Int32


@dataclass(slots=True, kw_only=True)
class ReactionNotificationSettings(BaseObject):
    """
    Contains information about notification settings for reactions

    :param message_reaction_source: Source of message reactions for which notifications are shown
    :type message_reaction_source: :class:`ReactionNotificationSource`
    :param story_reaction_source: Source of story reactions for which notifications are shown
    :type story_reaction_source: :class:`ReactionNotificationSource`
    :param sound_id: Identifier of the notification sound to be played; 0 if sound is disabled
    :type sound_id: :class:`Int64`
    :param show_preview: True, if reaction sender and emoji must be displayed in notifications
    :type show_preview: :class:`Bool`
    """

    ID: typing.Literal["reactionNotificationSettings"] = field(
        default="reactionNotificationSettings", metadata={"alias": "@type"}
    )
    message_reaction_source: ReactionNotificationSource
    story_reaction_source: ReactionNotificationSource
    sound_id: Int64 = field(default=0)
    show_preview: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ReactionNotificationSourceAll(BaseObject):
    """
    Notifications for reactions are shown for all reactions
    """

    ID: typing.Literal["reactionNotificationSourceAll"] = field(
        default="reactionNotificationSourceAll", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ReactionNotificationSourceContacts(BaseObject):
    """
    Notifications for reactions are shown only for reactions from contacts
    """

    ID: typing.Literal["reactionNotificationSourceContacts"] = field(
        default="reactionNotificationSourceContacts", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ReactionNotificationSourceNone(BaseObject):
    """
    Notifications for reactions are disabled
    """

    ID: typing.Literal["reactionNotificationSourceNone"] = field(
        default="reactionNotificationSourceNone", metadata={"alias": "@type"}
    )


ReactionNotificationSource = typing.Union[
    ReactionNotificationSourceAll,
    ReactionNotificationSourceContacts,
    ReactionNotificationSourceNone,
]


@dataclass(slots=True, kw_only=True)
class ReactionTypeCustomEmoji(BaseObject):
    """
    A reaction with a custom emoji

    :param custom_emoji_id: Unique identifier of the custom emoji
    :type custom_emoji_id: :class:`Int64`
    """

    ID: typing.Literal["reactionTypeCustomEmoji"] = field(
        default="reactionTypeCustomEmoji", metadata={"alias": "@type"}
    )
    custom_emoji_id: Int64


@dataclass(slots=True, kw_only=True)
class ReactionTypeEmoji(BaseObject):
    """
    A reaction with an emoji

    :param emoji: Text representation of the reaction
    :type emoji: :class:`String`
    """

    ID: typing.Literal["reactionTypeEmoji"] = field(default="reactionTypeEmoji", metadata={"alias": "@type"})
    emoji: String


@dataclass(slots=True, kw_only=True)
class ReactionTypePaid(BaseObject):
    """
    The paid reaction in a channel chat
    """

    ID: typing.Literal["reactionTypePaid"] = field(default="reactionTypePaid", metadata={"alias": "@type"})


ReactionType = typing.Union[
    ReactionTypeCustomEmoji,
    ReactionTypeEmoji,
    ReactionTypePaid,
]


@dataclass(slots=True, kw_only=True)
class ReactionUnavailabilityReasonAnonymousAdministrator(BaseObject):
    """
    The user is an anonymous administrator in the supergroup, but isn't a creator of it, so they can't vote on behalf of the supergroup
    """

    ID: typing.Literal["reactionUnavailabilityReasonAnonymousAdministrator"] = field(
        default="reactionUnavailabilityReasonAnonymousAdministrator", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ReactionUnavailabilityReasonGuest(BaseObject):
    """
    The user isn't a member of the supergroup and can't send messages and reactions there without joining
    """

    ID: typing.Literal["reactionUnavailabilityReasonGuest"] = field(
        default="reactionUnavailabilityReasonGuest", metadata={"alias": "@type"}
    )


ReactionUnavailabilityReason = typing.Union[
    ReactionUnavailabilityReasonAnonymousAdministrator,
    ReactionUnavailabilityReasonGuest,
]


@dataclass(slots=True, kw_only=True)
class ReadDatePrivacySettings(BaseObject):
    """
    Contains privacy settings for message read date in private chats. Read dates are always shown to the users that can see online status of the current user regardless of this setting

    :param show_read_date: True, if message read date is shown to other users in private chats. If false and the current user isn't a Telegram Premium user, then they will not be able to see other's message read date
    :type show_read_date: :class:`Bool`
    """

    ID: typing.Literal["readDatePrivacySettings"] = field(
        default="readDatePrivacySettings", metadata={"alias": "@type"}
    )
    show_read_date: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ReceivedGift(BaseObject):
    """
    Represents a gift received by a user or a chat

    :param received_gift_id: Unique identifier of the received gift for the current user; only for the receiver of the gift
    :type received_gift_id: :class:`String`
    :param text: Message added to the gift
    :type text: :class:`FormattedText`
    :param date: Point in time (Unix timestamp) when the gift was sent
    :type date: :class:`Int32`
    :param gift: The gift
    :type gift: :class:`SentGift`
    :param prepaid_upgrade_star_count: Number of Telegram Stars that were paid by the sender for the ability to upgrade the gift
    :type prepaid_upgrade_star_count: :class:`Int53`
    :param transfer_star_count: Number of Telegram Stars that must be paid to transfer the upgraded gift; only for the receiver of the gift
    :type transfer_star_count: :class:`Int53`
    :param sender_id: Identifier of a user or a chat that sent the gift; may be null if unknown, defaults to None
    :type sender_id: :class:`MessageSender`, optional
    :param is_private: True, if the sender and gift text are shown only to the gift receiver; otherwise, everyone are able to see them
    :type is_private: :class:`Bool`
    :param is_saved: True, if the gift is displayed on the chat's profile page; only for the receiver of the gift
    :type is_saved: :class:`Bool`
    :param can_be_upgraded: True, if the gift is a regular gift that can be upgraded to a unique gift; only for the receiver of the gift
    :type can_be_upgraded: :class:`Bool`
    :param can_be_transferred: True, if the gift is an upgraded gift that can be transferred to another owner; only for the receiver of the gift
    :type can_be_transferred: :class:`Bool`
    :param was_refunded: True, if the gift was refunded and isn't available anymore
    :type was_refunded: :class:`Bool`
    :param sell_star_count: Number of Telegram Stars that can be claimed by the receiver instead of the regular gift; 0 if the gift can't be sold by the current user
    :type sell_star_count: :class:`Int53`
    :param export_date: Point in time (Unix timestamp) when the upgraded gift can be transferred to the TON blockchain as an NFT; 0 if NFT export isn't possible; only for the receiver of the gift
    :type export_date: :class:`Int32`
    """

    ID: typing.Literal["receivedGift"] = field(default="receivedGift", metadata={"alias": "@type"})
    received_gift_id: String
    text: FormattedText
    date: Int32
    gift: SentGift
    prepaid_upgrade_star_count: Int53
    transfer_star_count: Int53
    sender_id: typing.Optional[MessageSender] = field(default=None)
    is_private: Bool = field(default=False)
    is_saved: Bool = field(default=False)
    can_be_upgraded: Bool = field(default=False)
    can_be_transferred: Bool = field(default=False)
    was_refunded: Bool = field(default=False)
    sell_star_count: Int53 = field(default=0)
    export_date: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class ReceivedGifts(BaseObject):
    """
    Represents a list of gifts received by a user or a chat

    :param total_count: The total number of received gifts
    :type total_count: :class:`Int32`
    :param gifts: The list of gifts
    :type gifts: :class:`Vector[ReceivedGift]`
    :param are_notifications_enabled: True, if notifications about new gifts of the owner are enabled
    :type are_notifications_enabled: :class:`Bool`
    :param next_offset: The offset for the next request. If empty, then there are no more results
    :type next_offset: :class:`String`
    """

    ID: typing.Literal["receivedGifts"] = field(default="receivedGifts", metadata={"alias": "@type"})
    total_count: Int32
    gifts: Vector[ReceivedGift]
    are_notifications_enabled: Bool = field(default=False)
    next_offset: String = field(default="")


@dataclass(slots=True, kw_only=True)
class RecommendedChatFolder(BaseObject):
    """
    Describes a recommended chat folder

    :param folder: The chat folder
    :type folder: :class:`ChatFolder`
    :param description: Chat folder description
    :type description: :class:`String`
    """

    ID: typing.Literal["recommendedChatFolder"] = field(default="recommendedChatFolder", metadata={"alias": "@type"})
    folder: ChatFolder
    description: String


@dataclass(slots=True, kw_only=True)
class RecommendedChatFolders(BaseObject):
    """
    Contains a list of recommended chat folders

    :param chat_folders: List of recommended chat folders
    :type chat_folders: :class:`Vector[RecommendedChatFolder]`
    """

    ID: typing.Literal["recommendedChatFolders"] = field(default="recommendedChatFolders", metadata={"alias": "@type"})
    chat_folders: Vector[RecommendedChatFolder]


@dataclass(slots=True, kw_only=True)
class RecoveryEmailAddress(BaseObject):
    """
    Contains information about the current recovery email address

    :param recovery_email_address: Recovery email address
    :type recovery_email_address: :class:`String`
    """

    ID: typing.Literal["recoveryEmailAddress"] = field(default="recoveryEmailAddress", metadata={"alias": "@type"})
    recovery_email_address: String


@dataclass(slots=True, kw_only=True)
class RemoteFile(BaseObject):
    """
    Represents a remote file

    :param id: Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers. If the identifier starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known. If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string. Application must generate the file by downloading it to the specified location
    :type id: :class:`String`
    :param unique_id: Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
    :type unique_id: :class:`String`
    :param is_uploading_active: True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
    :type is_uploading_active: :class:`Bool`
    :param is_uploading_completed: True, if a remote copy is fully available
    :type is_uploading_completed: :class:`Bool`
    :param uploaded_size: Size of the remote available part of the file, in bytes; 0 if unknown, defaults to None
    :type uploaded_size: :class:`Int53`, optional
    """

    ID: typing.Literal["remoteFile"] = field(default="remoteFile", metadata={"alias": "@type"})
    id: String = field(default="")
    unique_id: String = field(default="")
    is_uploading_active: Bool = field(default=False)
    is_uploading_completed: Bool = field(default=False)
    uploaded_size: typing.Optional[Int53] = field(default=0)


@dataclass(slots=True, kw_only=True)
class ReplyMarkupForceReply(BaseObject):
    """
    Instructs application to force a reply to this message

    :param is_personal: True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply
    :type is_personal: :class:`Bool`
    :param input_field_placeholder: If non-empty, the placeholder to be shown in the input field when the reply is active; 0-64 characters, defaults to None
    :type input_field_placeholder: :class:`String`, optional
    """

    ID: typing.Literal["replyMarkupForceReply"] = field(default="replyMarkupForceReply", metadata={"alias": "@type"})
    is_personal: Bool = field(default=False)
    input_field_placeholder: typing.Optional[String] = field(default="", metadata={"max_length": 64})


@dataclass(slots=True, kw_only=True)
class ReplyMarkupInlineKeyboard(BaseObject):
    """
    Contains an inline keyboard layout

    :param rows: A list of rows of inline keyboard buttons
    :type rows: :class:`Vector[Vector[InlineKeyboardButton]]`
    """

    ID: typing.Literal["replyMarkupInlineKeyboard"] = field(
        default="replyMarkupInlineKeyboard", metadata={"alias": "@type"}
    )
    rows: Vector[Vector[InlineKeyboardButton]]


@dataclass(slots=True, kw_only=True)
class ReplyMarkupRemoveKeyboard(BaseObject):
    """
    Instructs application to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup with message_id == 0 will be sent

    :param is_personal: True, if the keyboard is removed only for the mentioned users or the target user of a reply
    :type is_personal: :class:`Bool`
    """

    ID: typing.Literal["replyMarkupRemoveKeyboard"] = field(
        default="replyMarkupRemoveKeyboard", metadata={"alias": "@type"}
    )
    is_personal: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ReplyMarkupShowKeyboard(BaseObject):
    """
    Contains a custom keyboard layout to quickly reply to bots

    :param rows: A list of rows of bot keyboard buttons
    :type rows: :class:`Vector[Vector[KeyboardButton]]`
    :param is_persistent: True, if the keyboard is expected to always be shown when the ordinary keyboard is hidden
    :type is_persistent: :class:`Bool`
    :param resize_keyboard: True, if the application needs to resize the keyboard vertically
    :type resize_keyboard: :class:`Bool`
    :param one_time: True, if the application needs to hide the keyboard after use
    :type one_time: :class:`Bool`
    :param is_personal: True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply
    :type is_personal: :class:`Bool`
    :param input_field_placeholder: If non-empty, the placeholder to be shown in the input field when the keyboard is active; 0-64 characters, defaults to None
    :type input_field_placeholder: :class:`String`, optional
    """

    ID: typing.Literal["replyMarkupShowKeyboard"] = field(
        default="replyMarkupShowKeyboard", metadata={"alias": "@type"}
    )
    rows: Vector[Vector[KeyboardButton]]
    is_persistent: Bool = field(default=False)
    resize_keyboard: Bool = field(default=False)
    one_time: Bool = field(default=False)
    is_personal: Bool = field(default=False)
    input_field_placeholder: typing.Optional[String] = field(default="", metadata={"max_length": 64})


ReplyMarkup = typing.Union[
    ReplyMarkupForceReply,
    ReplyMarkupInlineKeyboard,
    ReplyMarkupRemoveKeyboard,
    ReplyMarkupShowKeyboard,
]


@dataclass(slots=True, kw_only=True)
class ReportChatResultMessagesRequired(BaseObject):
    """
    The user must choose messages to report and repeat the reportChat request with the chosen messages
    """

    ID: typing.Literal["reportChatResultMessagesRequired"] = field(
        default="reportChatResultMessagesRequired", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ReportChatResultOk(BaseObject):
    """
    The chat was reported successfully
    """

    ID: typing.Literal["reportChatResultOk"] = field(default="reportChatResultOk", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ReportChatResultOptionRequired(BaseObject):
    """
    The user must choose an option to report the chat and repeat request with the chosen option

    :param title: Title for the option choice
    :type title: :class:`String`
    :param options: List of available options
    :type options: :class:`Vector[ReportOption]`
    """

    ID: typing.Literal["reportChatResultOptionRequired"] = field(
        default="reportChatResultOptionRequired", metadata={"alias": "@type"}
    )
    title: String
    options: Vector[ReportOption]


@dataclass(slots=True, kw_only=True)
class ReportChatResultTextRequired(BaseObject):
    """
    The user must add additional text details to the report

    :param option_id: Option identifier for the next reportChat request
    :type option_id: :class:`Bytes`
    :param is_optional: True, if the user can skip text adding
    :type is_optional: :class:`Bool`
    """

    ID: typing.Literal["reportChatResultTextRequired"] = field(
        default="reportChatResultTextRequired", metadata={"alias": "@type"}
    )
    option_id: Bytes
    is_optional: Bool = field(default=False)


ReportChatResult = typing.Union[
    ReportChatResultMessagesRequired,
    ReportChatResultOk,
    ReportChatResultOptionRequired,
    ReportChatResultTextRequired,
]


@dataclass(slots=True, kw_only=True)
class ReportChatSponsoredMessageResultAdsHidden(BaseObject):
    """
    Sponsored messages were hidden for the user in all chats
    """

    ID: typing.Literal["reportChatSponsoredMessageResultAdsHidden"] = field(
        default="reportChatSponsoredMessageResultAdsHidden", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ReportChatSponsoredMessageResultFailed(BaseObject):
    """
    The sponsored message is too old or not found
    """

    ID: typing.Literal["reportChatSponsoredMessageResultFailed"] = field(
        default="reportChatSponsoredMessageResultFailed", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ReportChatSponsoredMessageResultOk(BaseObject):
    """
    The message was reported successfully
    """

    ID: typing.Literal["reportChatSponsoredMessageResultOk"] = field(
        default="reportChatSponsoredMessageResultOk", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ReportChatSponsoredMessageResultOptionRequired(BaseObject):
    """
    The user must choose an option to report the message and repeat request with the chosen option

    :param title: Title for the option choice
    :type title: :class:`String`
    :param options: List of available options
    :type options: :class:`Vector[ReportOption]`
    """

    ID: typing.Literal["reportChatSponsoredMessageResultOptionRequired"] = field(
        default="reportChatSponsoredMessageResultOptionRequired", metadata={"alias": "@type"}
    )
    title: String
    options: Vector[ReportOption]


@dataclass(slots=True, kw_only=True)
class ReportChatSponsoredMessageResultPremiumRequired(BaseObject):
    """
    The user asked to hide sponsored messages, but Telegram Premium is required for this
    """

    ID: typing.Literal["reportChatSponsoredMessageResultPremiumRequired"] = field(
        default="reportChatSponsoredMessageResultPremiumRequired", metadata={"alias": "@type"}
    )


ReportChatSponsoredMessageResult = typing.Union[
    ReportChatSponsoredMessageResultAdsHidden,
    ReportChatSponsoredMessageResultFailed,
    ReportChatSponsoredMessageResultOk,
    ReportChatSponsoredMessageResultOptionRequired,
    ReportChatSponsoredMessageResultPremiumRequired,
]


@dataclass(slots=True, kw_only=True)
class ReportOption(BaseObject):
    """
    Describes an option to report an entity to Telegram

    :param id: Unique identifier of the option
    :type id: :class:`Bytes`
    :param text: Text of the option
    :type text: :class:`String`
    """

    ID: typing.Literal["reportOption"] = field(default="reportOption", metadata={"alias": "@type"})
    id: Bytes
    text: String


@dataclass(slots=True, kw_only=True)
class ReportReasonChildAbuse(BaseObject):
    """
    The chat has child abuse related content
    """

    ID: typing.Literal["reportReasonChildAbuse"] = field(default="reportReasonChildAbuse", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ReportReasonCopyright(BaseObject):
    """
    The chat contains copyrighted content
    """

    ID: typing.Literal["reportReasonCopyright"] = field(default="reportReasonCopyright", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ReportReasonCustom(BaseObject):
    """
    A custom reason provided by the user
    """

    ID: typing.Literal["reportReasonCustom"] = field(default="reportReasonCustom", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ReportReasonFake(BaseObject):
    """
    The chat represents a fake account
    """

    ID: typing.Literal["reportReasonFake"] = field(default="reportReasonFake", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ReportReasonIllegalDrugs(BaseObject):
    """
    The chat has illegal drugs related content
    """

    ID: typing.Literal["reportReasonIllegalDrugs"] = field(
        default="reportReasonIllegalDrugs", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ReportReasonPersonalDetails(BaseObject):
    """
    The chat contains messages with personal details
    """

    ID: typing.Literal["reportReasonPersonalDetails"] = field(
        default="reportReasonPersonalDetails", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ReportReasonPornography(BaseObject):
    """
    The chat contains pornographic messages
    """

    ID: typing.Literal["reportReasonPornography"] = field(
        default="reportReasonPornography", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ReportReasonSpam(BaseObject):
    """
    The chat contains spam messages
    """

    ID: typing.Literal["reportReasonSpam"] = field(default="reportReasonSpam", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ReportReasonUnrelatedLocation(BaseObject):
    """
    The location-based chat is unrelated to its stated location
    """

    ID: typing.Literal["reportReasonUnrelatedLocation"] = field(
        default="reportReasonUnrelatedLocation", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ReportReasonViolence(BaseObject):
    """
    The chat promotes violence
    """

    ID: typing.Literal["reportReasonViolence"] = field(default="reportReasonViolence", metadata={"alias": "@type"})


ReportReason = typing.Union[
    ReportReasonChildAbuse,
    ReportReasonCopyright,
    ReportReasonCustom,
    ReportReasonFake,
    ReportReasonIllegalDrugs,
    ReportReasonPersonalDetails,
    ReportReasonPornography,
    ReportReasonSpam,
    ReportReasonUnrelatedLocation,
    ReportReasonViolence,
]


@dataclass(slots=True, kw_only=True)
class ReportStoryResultOk(BaseObject):
    """
    The story was reported successfully
    """

    ID: typing.Literal["reportStoryResultOk"] = field(default="reportStoryResultOk", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ReportStoryResultOptionRequired(BaseObject):
    """
    The user must choose an option to report the story and repeat request with the chosen option

    :param title: Title for the option choice
    :type title: :class:`String`
    :param options: List of available options
    :type options: :class:`Vector[ReportOption]`
    """

    ID: typing.Literal["reportStoryResultOptionRequired"] = field(
        default="reportStoryResultOptionRequired", metadata={"alias": "@type"}
    )
    title: String
    options: Vector[ReportOption]


@dataclass(slots=True, kw_only=True)
class ReportStoryResultTextRequired(BaseObject):
    """
    The user must add additional text details to the report

    :param option_id: Option identifier for the next reportStory request
    :type option_id: :class:`Bytes`
    :param is_optional: True, if the user can skip text adding
    :type is_optional: :class:`Bool`
    """

    ID: typing.Literal["reportStoryResultTextRequired"] = field(
        default="reportStoryResultTextRequired", metadata={"alias": "@type"}
    )
    option_id: Bytes
    is_optional: Bool = field(default=False)


ReportStoryResult = typing.Union[
    ReportStoryResultOk,
    ReportStoryResultOptionRequired,
    ReportStoryResultTextRequired,
]


@dataclass(slots=True, kw_only=True)
class ResendCodeReasonUserRequest(BaseObject):
    """
    The user requested to resend the code
    """

    ID: typing.Literal["resendCodeReasonUserRequest"] = field(
        default="resendCodeReasonUserRequest", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class ResendCodeReasonVerificationFailed(BaseObject):
    """
    The code is re-sent, because device verification has failed

    :param error_message: Cause of the verification failure, for example, PLAY_SERVICES_NOT_AVAILABLE, APNS_RECEIVE_TIMEOUT, or APNS_INIT_FAILED
    :type error_message: :class:`String`
    """

    ID: typing.Literal["resendCodeReasonVerificationFailed"] = field(
        default="resendCodeReasonVerificationFailed", metadata={"alias": "@type"}
    )
    error_message: String


ResendCodeReason = typing.Union[
    ResendCodeReasonUserRequest,
    ResendCodeReasonVerificationFailed,
]


@dataclass(slots=True, kw_only=True)
class ResetPasswordResultDeclined(BaseObject):
    """
    The password reset request was declined

    :param retry_date: Point in time (Unix timestamp) when the password reset can be retried
    :type retry_date: :class:`Int32`
    """

    ID: typing.Literal["resetPasswordResultDeclined"] = field(
        default="resetPasswordResultDeclined", metadata={"alias": "@type"}
    )
    retry_date: Int32


@dataclass(slots=True, kw_only=True)
class ResetPasswordResultOk(BaseObject):
    """
    The password was reset
    """

    ID: typing.Literal["resetPasswordResultOk"] = field(default="resetPasswordResultOk", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ResetPasswordResultPending(BaseObject):
    """
    The password reset request is pending

    :param pending_reset_date: Point in time (Unix timestamp) after which the password can be reset immediately using resetPassword
    :type pending_reset_date: :class:`Int32`
    """

    ID: typing.Literal["resetPasswordResultPending"] = field(
        default="resetPasswordResultPending", metadata={"alias": "@type"}
    )
    pending_reset_date: Int32


ResetPasswordResult = typing.Union[
    ResetPasswordResultDeclined,
    ResetPasswordResultOk,
    ResetPasswordResultPending,
]


@dataclass(slots=True, kw_only=True)
class RevenueWithdrawalStateFailed(BaseObject):
    """
    Withdrawal failed
    """

    ID: typing.Literal["revenueWithdrawalStateFailed"] = field(
        default="revenueWithdrawalStateFailed", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class RevenueWithdrawalStatePending(BaseObject):
    """
    Withdrawal is pending
    """

    ID: typing.Literal["revenueWithdrawalStatePending"] = field(
        default="revenueWithdrawalStatePending", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class RevenueWithdrawalStateSucceeded(BaseObject):
    """
    Withdrawal succeeded

    :param date: Point in time (Unix timestamp) when the withdrawal was completed
    :type date: :class:`Int32`
    :param url: The URL where the withdrawal transaction can be viewed
    :type url: :class:`String`
    """

    ID: typing.Literal["revenueWithdrawalStateSucceeded"] = field(
        default="revenueWithdrawalStateSucceeded", metadata={"alias": "@type"}
    )
    date: Int32
    url: String


RevenueWithdrawalState = typing.Union[
    RevenueWithdrawalStateFailed,
    RevenueWithdrawalStatePending,
    RevenueWithdrawalStateSucceeded,
]


@dataclass(slots=True, kw_only=True)
class RichTextAnchor(BaseObject):
    """
    An anchor

    :param name: Anchor name
    :type name: :class:`String`
    """

    ID: typing.Literal["richTextAnchor"] = field(default="richTextAnchor", metadata={"alias": "@type"})
    name: String


@dataclass(slots=True, kw_only=True)
class RichTextAnchorLink(BaseObject):
    """
    A link to an anchor on the same page

    :param text: The link text
    :type text: :class:`RichText`
    :param anchor_name: The anchor name. If the name is empty, the link must bring back to top
    :type anchor_name: :class:`String`
    :param url: An HTTP URL, opening the anchor
    :type url: :class:`String`
    """

    ID: typing.Literal["richTextAnchorLink"] = field(default="richTextAnchorLink", metadata={"alias": "@type"})
    text: RichText
    anchor_name: String
    url: String


@dataclass(slots=True, kw_only=True)
class RichTextBold(BaseObject):
    """
    A bold rich text

    :param text: Text
    :type text: :class:`RichText`
    """

    ID: typing.Literal["richTextBold"] = field(default="richTextBold", metadata={"alias": "@type"})
    text: RichText


@dataclass(slots=True, kw_only=True)
class RichTextEmailAddress(BaseObject):
    """
    A rich text email link

    :param text: Text
    :type text: :class:`RichText`
    :param email_address: Email address
    :type email_address: :class:`String`
    """

    ID: typing.Literal["richTextEmailAddress"] = field(default="richTextEmailAddress", metadata={"alias": "@type"})
    text: RichText
    email_address: String


@dataclass(slots=True, kw_only=True)
class RichTextFixed(BaseObject):
    """
    A fixed-width rich text

    :param text: Text
    :type text: :class:`RichText`
    """

    ID: typing.Literal["richTextFixed"] = field(default="richTextFixed", metadata={"alias": "@type"})
    text: RichText


@dataclass(slots=True, kw_only=True)
class RichTextIcon(BaseObject):
    """
    A small image inside the text

    :param document: The image represented as a document. The image can be in GIF, JPEG or PNG format
    :type document: :class:`Document`
    :param width: Width of a bounding box in which the image must be shown; 0 if unknown, defaults to None
    :type width: :class:`Int32`, optional
    :param height: Height of a bounding box in which the image must be shown; 0 if unknown, defaults to None
    :type height: :class:`Int32`, optional
    """

    ID: typing.Literal["richTextIcon"] = field(default="richTextIcon", metadata={"alias": "@type"})
    document: Document
    width: typing.Optional[Int32] = field(default=0)
    height: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class RichTextItalic(BaseObject):
    """
    An italicized rich text

    :param text: Text
    :type text: :class:`RichText`
    """

    ID: typing.Literal["richTextItalic"] = field(default="richTextItalic", metadata={"alias": "@type"})
    text: RichText


@dataclass(slots=True, kw_only=True)
class RichTextMarked(BaseObject):
    """
    A marked rich text

    :param text: Text
    :type text: :class:`RichText`
    """

    ID: typing.Literal["richTextMarked"] = field(default="richTextMarked", metadata={"alias": "@type"})
    text: RichText


@dataclass(slots=True, kw_only=True)
class RichTextPhoneNumber(BaseObject):
    """
    A rich text phone number

    :param text: Text
    :type text: :class:`RichText`
    :param phone_number: Phone number
    :type phone_number: :class:`String`
    """

    ID: typing.Literal["richTextPhoneNumber"] = field(default="richTextPhoneNumber", metadata={"alias": "@type"})
    text: RichText
    phone_number: String


@dataclass(slots=True, kw_only=True)
class RichTextPlain(BaseObject):
    """
    A plain text

    :param text: Text
    :type text: :class:`String`
    """

    ID: typing.Literal["richTextPlain"] = field(default="richTextPlain", metadata={"alias": "@type"})
    text: String


@dataclass(slots=True, kw_only=True)
class RichTextReference(BaseObject):
    """
    A reference to a richTexts object on the same page

    :param text: The text
    :type text: :class:`RichText`
    :param anchor_name: The name of a richTextAnchor object, which is the first element of the target richTexts object
    :type anchor_name: :class:`String`
    :param url: An HTTP URL, opening the reference
    :type url: :class:`String`
    """

    ID: typing.Literal["richTextReference"] = field(default="richTextReference", metadata={"alias": "@type"})
    text: RichText
    anchor_name: String
    url: String


@dataclass(slots=True, kw_only=True)
class RichTextStrikethrough(BaseObject):
    """
    A strikethrough rich text

    :param text: Text
    :type text: :class:`RichText`
    """

    ID: typing.Literal["richTextStrikethrough"] = field(default="richTextStrikethrough", metadata={"alias": "@type"})
    text: RichText


@dataclass(slots=True, kw_only=True)
class RichTextSubscript(BaseObject):
    """
    A subscript rich text

    :param text: Text
    :type text: :class:`RichText`
    """

    ID: typing.Literal["richTextSubscript"] = field(default="richTextSubscript", metadata={"alias": "@type"})
    text: RichText


@dataclass(slots=True, kw_only=True)
class RichTextSuperscript(BaseObject):
    """
    A superscript rich text

    :param text: Text
    :type text: :class:`RichText`
    """

    ID: typing.Literal["richTextSuperscript"] = field(default="richTextSuperscript", metadata={"alias": "@type"})
    text: RichText


@dataclass(slots=True, kw_only=True)
class RichTextUnderline(BaseObject):
    """
    An underlined rich text

    :param text: Text
    :type text: :class:`RichText`
    """

    ID: typing.Literal["richTextUnderline"] = field(default="richTextUnderline", metadata={"alias": "@type"})
    text: RichText


@dataclass(slots=True, kw_only=True)
class RichTextUrl(BaseObject):
    """
    A rich text URL link

    :param text: Text
    :type text: :class:`RichText`
    :param url: URL
    :type url: :class:`String`
    :param is_cached: True, if the URL has cached instant view server-side
    :type is_cached: :class:`Bool`
    """

    ID: typing.Literal["richTextUrl"] = field(default="richTextUrl", metadata={"alias": "@type"})
    text: RichText
    url: String
    is_cached: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class RichTexts(BaseObject):
    """
    A concatenation of rich texts

    :param texts: Texts
    :type texts: :class:`Vector[RichText]`
    """

    ID: typing.Literal["richTexts"] = field(default="richTexts", metadata={"alias": "@type"})
    texts: Vector[RichText]


RichText = typing.Union[
    RichTextAnchor,
    RichTextAnchorLink,
    RichTextBold,
    RichTextEmailAddress,
    RichTextFixed,
    RichTextIcon,
    RichTextItalic,
    RichTextMarked,
    RichTextPhoneNumber,
    RichTextPlain,
    RichTextReference,
    RichTextStrikethrough,
    RichTextSubscript,
    RichTextSuperscript,
    RichTextUnderline,
    RichTextUrl,
    RichTexts,
]


@dataclass(slots=True, kw_only=True)
class RtmpUrl(BaseObject):
    """
    Represents an RTMP URL

    :param url: The URL
    :type url: :class:`String`
    :param stream_key: Stream key
    :type stream_key: :class:`String`
    """

    ID: typing.Literal["rtmpUrl"] = field(default="rtmpUrl", metadata={"alias": "@type"})
    url: String
    stream_key: String


@dataclass(slots=True, kw_only=True)
class SavedCredentials(BaseObject):
    """
    Contains information about saved payment credentials

    :param id: Unique identifier of the saved credentials
    :type id: :class:`String`
    :param title: Title of the saved credentials
    :type title: :class:`String`
    """

    ID: typing.Literal["savedCredentials"] = field(default="savedCredentials", metadata={"alias": "@type"})
    id: String
    title: String


@dataclass(slots=True, kw_only=True)
class SavedMessagesTag(BaseObject):
    """
    Represents a tag used in Saved Messages or a Saved Messages topic

    :param tag: The tag
    :type tag: :class:`ReactionType`
    :param label: Label of the tag; 0-12 characters. Always empty if the tag is returned for a Saved Messages topic
    :type label: :class:`String`
    :param count: Number of times the tag was used; may be 0 if the tag has non-empty label
    :type count: :class:`Int32`
    """

    ID: typing.Literal["savedMessagesTag"] = field(default="savedMessagesTag", metadata={"alias": "@type"})
    tag: ReactionType
    label: String = field(default="", metadata={"max_length": 12})
    count: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class SavedMessagesTags(BaseObject):
    """
    Contains a list of tags used in Saved Messages

    :param tags: List of tags
    :type tags: :class:`Vector[SavedMessagesTag]`
    """

    ID: typing.Literal["savedMessagesTags"] = field(default="savedMessagesTags", metadata={"alias": "@type"})
    tags: Vector[SavedMessagesTag]


@dataclass(slots=True, kw_only=True)
class SavedMessagesTopic(BaseObject):
    """
    Contains information about a Saved Messages topic

    :param id: Unique topic identifier
    :type id: :class:`Int53`
    :param type_: Type of the topic
    :type type_: :class:`SavedMessagesTopicType`
    :param order: A parameter used to determine order of the topic in the topic list. Topics must be sorted by the order in descending order
    :type order: :class:`Int64`
    :param last_message: Last message in the topic; may be null if none or unknown, defaults to None
    :type last_message: :class:`Message`, optional
    :param draft_message: A draft of a message in the topic; may be null if none, defaults to None
    :type draft_message: :class:`DraftMessage`, optional
    :param is_pinned: True, if the topic is pinned
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["savedMessagesTopic"] = field(default="savedMessagesTopic", metadata={"alias": "@type"})
    id: Int53
    type_: SavedMessagesTopicType = field(default=MISSING, metadata={"alias": "type"})
    order: Int64
    last_message: typing.Optional[Message] = field(default=None)
    draft_message: typing.Optional[DraftMessage] = field(default=None)
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class SavedMessagesTopicTypeAuthorHidden(BaseObject):
    """
    Topic containing messages forwarded from a user with hidden privacy
    """

    ID: typing.Literal["savedMessagesTopicTypeAuthorHidden"] = field(
        default="savedMessagesTopicTypeAuthorHidden", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SavedMessagesTopicTypeMyNotes(BaseObject):
    """
    Topic containing messages sent by the current user of forwarded from an unknown chat
    """

    ID: typing.Literal["savedMessagesTopicTypeMyNotes"] = field(
        default="savedMessagesTopicTypeMyNotes", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SavedMessagesTopicTypeSavedFromChat(BaseObject):
    """
    Topic containing messages forwarded from a specific chat

    :param chat_id: Identifier of the chat
    :type chat_id: :class:`Int53`
    """

    ID: typing.Literal["savedMessagesTopicTypeSavedFromChat"] = field(
        default="savedMessagesTopicTypeSavedFromChat", metadata={"alias": "@type"}
    )
    chat_id: Int53


SavedMessagesTopicType = typing.Union[
    SavedMessagesTopicTypeAuthorHidden,
    SavedMessagesTopicTypeMyNotes,
    SavedMessagesTopicTypeSavedFromChat,
]


@dataclass(slots=True, kw_only=True)
class ScopeAutosaveSettings(BaseObject):
    """
    Contains autosave settings for an autosave settings scope

    :param max_video_file_size: The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB
    :type max_video_file_size: :class:`Int53`
    :param autosave_photos: True, if photo autosave is enabled
    :type autosave_photos: :class:`Bool`
    :param autosave_videos: True, if video autosave is enabled
    :type autosave_videos: :class:`Bool`
    """

    ID: typing.Literal["scopeAutosaveSettings"] = field(default="scopeAutosaveSettings", metadata={"alias": "@type"})
    max_video_file_size: Int53
    autosave_photos: Bool = field(default=False)
    autosave_videos: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ScopeNotificationSettings(BaseObject):
    """
    Contains information about notification settings for several chats

    :param mute_for: Time left before notifications will be unmuted, in seconds
    :type mute_for: :class:`Int32`
    :param sound_id: Identifier of the notification sound to be played; 0 if sound is disabled
    :type sound_id: :class:`Int64`
    :param show_preview: True, if message content must be displayed in notifications
    :type show_preview: :class:`Bool`
    :param use_default_mute_stories: If true, story notifications are received only for the first 5 chats from topChatCategoryUsers regardless of the value of mute_stories
    :type use_default_mute_stories: :class:`Bool`
    :param mute_stories: True, if story notifications are disabled
    :type mute_stories: :class:`Bool`
    :param story_sound_id: Identifier of the notification sound to be played for stories; 0 if sound is disabled
    :type story_sound_id: :class:`Int64`
    :param show_story_sender: True, if the sender of stories must be displayed in notifications
    :type show_story_sender: :class:`Bool`
    :param disable_pinned_message_notifications: True, if notifications for incoming pinned messages will be created as for an ordinary unread message
    :type disable_pinned_message_notifications: :class:`Bool`
    :param disable_mention_notifications: True, if notifications for messages with mentions will be created as for an ordinary unread message
    :type disable_mention_notifications: :class:`Bool`
    """

    ID: typing.Literal["scopeNotificationSettings"] = field(
        default="scopeNotificationSettings", metadata={"alias": "@type"}
    )
    mute_for: Int32
    sound_id: Int64 = field(default=0)
    show_preview: Bool = field(default=False)
    use_default_mute_stories: Bool = field(default=False)
    mute_stories: Bool = field(default=False)
    story_sound_id: Int64 = field(default=0)
    show_story_sender: Bool = field(default=False)
    disable_pinned_message_notifications: Bool = field(default=False)
    disable_mention_notifications: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class SearchMessagesChatTypeFilterChannel(BaseObject):
    """
    Returns only messages in channel chats
    """

    ID: typing.Literal["searchMessagesChatTypeFilterChannel"] = field(
        default="searchMessagesChatTypeFilterChannel", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesChatTypeFilterGroup(BaseObject):
    """
    Returns only messages in basic group and supergroup chats
    """

    ID: typing.Literal["searchMessagesChatTypeFilterGroup"] = field(
        default="searchMessagesChatTypeFilterGroup", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesChatTypeFilterPrivate(BaseObject):
    """
    Returns only messages in private chats
    """

    ID: typing.Literal["searchMessagesChatTypeFilterPrivate"] = field(
        default="searchMessagesChatTypeFilterPrivate", metadata={"alias": "@type"}
    )


SearchMessagesChatTypeFilter = typing.Union[
    SearchMessagesChatTypeFilterChannel,
    SearchMessagesChatTypeFilterGroup,
    SearchMessagesChatTypeFilterPrivate,
]


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterAnimation(BaseObject):
    """
    Returns only animation messages
    """

    ID: typing.Literal["searchMessagesFilterAnimation"] = field(
        default="searchMessagesFilterAnimation", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterAudio(BaseObject):
    """
    Returns only audio messages
    """

    ID: typing.Literal["searchMessagesFilterAudio"] = field(
        default="searchMessagesFilterAudio", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterChatPhoto(BaseObject):
    """
    Returns only messages containing chat photos
    """

    ID: typing.Literal["searchMessagesFilterChatPhoto"] = field(
        default="searchMessagesFilterChatPhoto", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterDocument(BaseObject):
    """
    Returns only document messages
    """

    ID: typing.Literal["searchMessagesFilterDocument"] = field(
        default="searchMessagesFilterDocument", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterEmpty(BaseObject):
    """
    Returns all found messages, no filter is applied
    """

    ID: typing.Literal["searchMessagesFilterEmpty"] = field(
        default="searchMessagesFilterEmpty", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterFailedToSend(BaseObject):
    """
    Returns only failed to send messages. This filter can be used only if the message database is used
    """

    ID: typing.Literal["searchMessagesFilterFailedToSend"] = field(
        default="searchMessagesFilterFailedToSend", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterMention(BaseObject):
    """
    Returns only messages with mentions of the current user, or messages that are replies to their messages
    """

    ID: typing.Literal["searchMessagesFilterMention"] = field(
        default="searchMessagesFilterMention", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterPhoto(BaseObject):
    """
    Returns only photo messages
    """

    ID: typing.Literal["searchMessagesFilterPhoto"] = field(
        default="searchMessagesFilterPhoto", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterPhotoAndVideo(BaseObject):
    """
    Returns only photo and video messages
    """

    ID: typing.Literal["searchMessagesFilterPhotoAndVideo"] = field(
        default="searchMessagesFilterPhotoAndVideo", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterPinned(BaseObject):
    """
    Returns only pinned messages
    """

    ID: typing.Literal["searchMessagesFilterPinned"] = field(
        default="searchMessagesFilterPinned", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterUnreadMention(BaseObject):
    """
    Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
    """

    ID: typing.Literal["searchMessagesFilterUnreadMention"] = field(
        default="searchMessagesFilterUnreadMention", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterUnreadReaction(BaseObject):
    """
    Returns only messages with unread reactions for the current user. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
    """

    ID: typing.Literal["searchMessagesFilterUnreadReaction"] = field(
        default="searchMessagesFilterUnreadReaction", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterUrl(BaseObject):
    """
    Returns only messages containing URLs
    """

    ID: typing.Literal["searchMessagesFilterUrl"] = field(
        default="searchMessagesFilterUrl", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterVideo(BaseObject):
    """
    Returns only video messages
    """

    ID: typing.Literal["searchMessagesFilterVideo"] = field(
        default="searchMessagesFilterVideo", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterVideoNote(BaseObject):
    """
    Returns only video note messages
    """

    ID: typing.Literal["searchMessagesFilterVideoNote"] = field(
        default="searchMessagesFilterVideoNote", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterVoiceAndVideoNote(BaseObject):
    """
    Returns only voice and video note messages
    """

    ID: typing.Literal["searchMessagesFilterVoiceAndVideoNote"] = field(
        default="searchMessagesFilterVoiceAndVideoNote", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SearchMessagesFilterVoiceNote(BaseObject):
    """
    Returns only voice note messages
    """

    ID: typing.Literal["searchMessagesFilterVoiceNote"] = field(
        default="searchMessagesFilterVoiceNote", metadata={"alias": "@type"}
    )


SearchMessagesFilter = typing.Union[
    SearchMessagesFilterAnimation,
    SearchMessagesFilterAudio,
    SearchMessagesFilterChatPhoto,
    SearchMessagesFilterDocument,
    SearchMessagesFilterEmpty,
    SearchMessagesFilterFailedToSend,
    SearchMessagesFilterMention,
    SearchMessagesFilterPhoto,
    SearchMessagesFilterPhotoAndVideo,
    SearchMessagesFilterPinned,
    SearchMessagesFilterUnreadMention,
    SearchMessagesFilterUnreadReaction,
    SearchMessagesFilterUrl,
    SearchMessagesFilterVideo,
    SearchMessagesFilterVideoNote,
    SearchMessagesFilterVoiceAndVideoNote,
    SearchMessagesFilterVoiceNote,
]


@dataclass(slots=True, kw_only=True)
class Seconds(BaseObject):
    """
    Contains a value representing a number of seconds

    :param seconds: Number of seconds
    :type seconds: :class:`Double`
    """

    ID: typing.Literal["seconds"] = field(default="seconds", metadata={"alias": "@type"})
    seconds: Double


@dataclass(slots=True, kw_only=True)
class SecretChat(BaseObject):
    """
    Represents a secret chat

    :param id: Secret chat identifier
    :type id: :class:`Int32`
    :param user_id: Identifier of the chat partner
    :type user_id: :class:`Int53`
    :param state: State of the secret chat
    :type state: :class:`SecretChatState`
    :param key_hash: Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 little-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9. The pixels must be used to make a 12x12 square image filled from left to right, top to bottom. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
    :type key_hash: :class:`Bytes`
    :param layer: Secret chat layer; determines features supported by the chat partner's application. Nested text entities and underline and strikethrough entities are supported if the layer >= 101, files bigger than 2000MB are supported if the layer >= 143, spoiler and custom emoji text entities are supported if the layer >= 144
    :type layer: :class:`Int32`
    :param is_outbound: True, if the chat was created by the current user; false otherwise
    :type is_outbound: :class:`Bool`
    """

    ID: typing.Literal["secretChat"] = field(default="secretChat", metadata={"alias": "@type"})
    id: Int32
    user_id: Int53
    state: SecretChatState
    key_hash: Bytes
    layer: Int32
    is_outbound: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class SecretChatStateClosed(BaseObject):
    """
    The secret chat is closed
    """

    ID: typing.Literal["secretChatStateClosed"] = field(default="secretChatStateClosed", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SecretChatStatePending(BaseObject):
    """
    The secret chat is not yet created; waiting for the other user to get online
    """

    ID: typing.Literal["secretChatStatePending"] = field(default="secretChatStatePending", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SecretChatStateReady(BaseObject):
    """
    The secret chat is ready to use
    """

    ID: typing.Literal["secretChatStateReady"] = field(default="secretChatStateReady", metadata={"alias": "@type"})


SecretChatState = typing.Union[
    SecretChatStateClosed,
    SecretChatStatePending,
    SecretChatStateReady,
]


@dataclass(slots=True, kw_only=True)
class SentGiftRegular(BaseObject):
    """
    Regular gift

    :param gift: The gift
    :type gift: :class:`Gift`
    """

    ID: typing.Literal["sentGiftRegular"] = field(default="sentGiftRegular", metadata={"alias": "@type"})
    gift: Gift


@dataclass(slots=True, kw_only=True)
class SentGiftUpgraded(BaseObject):
    """
    Upgraded gift

    :param gift: The gift
    :type gift: :class:`UpgradedGift`
    """

    ID: typing.Literal["sentGiftUpgraded"] = field(default="sentGiftUpgraded", metadata={"alias": "@type"})
    gift: UpgradedGift


SentGift = typing.Union[
    SentGiftRegular,
    SentGiftUpgraded,
]


@dataclass(slots=True, kw_only=True)
class SentWebAppMessage(BaseObject):
    """
    Information about the message sent by answerWebAppQuery

    :param inline_message_id: Identifier of the sent inline message, if known
    :type inline_message_id: :class:`String`
    """

    ID: typing.Literal["sentWebAppMessage"] = field(default="sentWebAppMessage", metadata={"alias": "@type"})
    inline_message_id: String


@dataclass(slots=True, kw_only=True)
class Session(BaseObject):
    """
    Contains information about one session in a Telegram application used by the current user. Sessions must be shown to the user in the returned order

    :param id: Session identifier
    :type id: :class:`Int64`
    :param type_: Session type based on the system and application version, which can be used to display a corresponding icon
    :type type_: :class:`SessionType`
    :param api_id: Telegram API identifier, as provided by the application
    :type api_id: :class:`Int32`
    :param application_name: Name of the application, as provided by the application
    :type application_name: :class:`String`
    :param application_version: The version of the application, as provided by the application
    :type application_version: :class:`String`
    :param device_model: Model of the device the application has been run or is running on, as provided by the application
    :type device_model: :class:`String`
    :param platform: Operating system the application has been run or is running on, as provided by the application
    :type platform: :class:`String`
    :param system_version: Version of the operating system the application has been run or is running on, as provided by the application
    :type system_version: :class:`String`
    :param log_in_date: Point in time (Unix timestamp) when the user has logged in
    :type log_in_date: :class:`Int32`
    :param last_active_date: Point in time (Unix timestamp) when the session was last used
    :type last_active_date: :class:`Int32`
    :param ip_address: IP address from which the session was created, in human-readable format
    :type ip_address: :class:`String`
    :param location: A human-readable description of the location from which the session was created, based on the IP address
    :type location: :class:`String`
    :param is_current: True, if this session is the current session
    :type is_current: :class:`Bool`
    :param is_password_pending: True, if a 2-step verification password is needed to complete authorization of the session
    :type is_password_pending: :class:`Bool`
    :param is_unconfirmed: True, if the session wasn't confirmed from another session
    :type is_unconfirmed: :class:`Bool`
    :param can_accept_secret_chats: True, if incoming secret chats can be accepted by the session
    :type can_accept_secret_chats: :class:`Bool`
    :param can_accept_calls: True, if incoming calls can be accepted by the session
    :type can_accept_calls: :class:`Bool`
    :param is_official_application: True, if the application is an official application or uses the api_id of an official application
    :type is_official_application: :class:`Bool`
    """

    ID: typing.Literal["session"] = field(default="session", metadata={"alias": "@type"})
    id: Int64
    type_: SessionType = field(default=MISSING, metadata={"alias": "type"})
    api_id: Int32
    application_name: String
    application_version: String
    device_model: String
    platform: String
    system_version: String
    log_in_date: Int32
    last_active_date: Int32
    ip_address: String
    location: String
    is_current: Bool = field(default=False)
    is_password_pending: Bool = field(default=False)
    is_unconfirmed: Bool = field(default=False)
    can_accept_secret_chats: Bool = field(default=False)
    can_accept_calls: Bool = field(default=False)
    is_official_application: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class SessionTypeAndroid(BaseObject):
    """
    The session is running on an Android device
    """

    ID: typing.Literal["sessionTypeAndroid"] = field(default="sessionTypeAndroid", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeApple(BaseObject):
    """
    The session is running on a generic Apple device
    """

    ID: typing.Literal["sessionTypeApple"] = field(default="sessionTypeApple", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeBrave(BaseObject):
    """
    The session is running on the Brave browser
    """

    ID: typing.Literal["sessionTypeBrave"] = field(default="sessionTypeBrave", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeChrome(BaseObject):
    """
    The session is running on the Chrome browser
    """

    ID: typing.Literal["sessionTypeChrome"] = field(default="sessionTypeChrome", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeEdge(BaseObject):
    """
    The session is running on the Edge browser
    """

    ID: typing.Literal["sessionTypeEdge"] = field(default="sessionTypeEdge", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeFirefox(BaseObject):
    """
    The session is running on the Firefox browser
    """

    ID: typing.Literal["sessionTypeFirefox"] = field(default="sessionTypeFirefox", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeIpad(BaseObject):
    """
    The session is running on an iPad device
    """

    ID: typing.Literal["sessionTypeIpad"] = field(default="sessionTypeIpad", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeIphone(BaseObject):
    """
    The session is running on an iPhone device
    """

    ID: typing.Literal["sessionTypeIphone"] = field(default="sessionTypeIphone", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeLinux(BaseObject):
    """
    The session is running on a Linux device
    """

    ID: typing.Literal["sessionTypeLinux"] = field(default="sessionTypeLinux", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeMac(BaseObject):
    """
    The session is running on a Mac device
    """

    ID: typing.Literal["sessionTypeMac"] = field(default="sessionTypeMac", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeOpera(BaseObject):
    """
    The session is running on the Opera browser
    """

    ID: typing.Literal["sessionTypeOpera"] = field(default="sessionTypeOpera", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeSafari(BaseObject):
    """
    The session is running on the Safari browser
    """

    ID: typing.Literal["sessionTypeSafari"] = field(default="sessionTypeSafari", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeUbuntu(BaseObject):
    """
    The session is running on an Ubuntu device
    """

    ID: typing.Literal["sessionTypeUbuntu"] = field(default="sessionTypeUbuntu", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeUnknown(BaseObject):
    """
    The session is running on an unknown type of device
    """

    ID: typing.Literal["sessionTypeUnknown"] = field(default="sessionTypeUnknown", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeVivaldi(BaseObject):
    """
    The session is running on the Vivaldi browser
    """

    ID: typing.Literal["sessionTypeVivaldi"] = field(default="sessionTypeVivaldi", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeWindows(BaseObject):
    """
    The session is running on a Windows device
    """

    ID: typing.Literal["sessionTypeWindows"] = field(default="sessionTypeWindows", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class SessionTypeXbox(BaseObject):
    """
    The session is running on an Xbox console
    """

    ID: typing.Literal["sessionTypeXbox"] = field(default="sessionTypeXbox", metadata={"alias": "@type"})


SessionType = typing.Union[
    SessionTypeAndroid,
    SessionTypeApple,
    SessionTypeBrave,
    SessionTypeChrome,
    SessionTypeEdge,
    SessionTypeFirefox,
    SessionTypeIpad,
    SessionTypeIphone,
    SessionTypeLinux,
    SessionTypeMac,
    SessionTypeOpera,
    SessionTypeSafari,
    SessionTypeUbuntu,
    SessionTypeUnknown,
    SessionTypeVivaldi,
    SessionTypeWindows,
    SessionTypeXbox,
]


@dataclass(slots=True, kw_only=True)
class Sessions(BaseObject):
    """
    Contains a list of sessions

    :param sessions: List of sessions
    :type sessions: :class:`Vector[Session]`
    :param inactive_session_ttl_days: Number of days of inactivity before sessions will automatically be terminated; 1-366 days
    :type inactive_session_ttl_days: :class:`Int32`
    """

    ID: typing.Literal["sessions"] = field(default="sessions", metadata={"alias": "@type"})
    sessions: Vector[Session]
    inactive_session_ttl_days: Int32


@dataclass(slots=True, kw_only=True)
class SharedChat(BaseObject):
    """
    Contains information about a chat shared with a bot

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param title: Title of the chat; for bots only
    :type title: :class:`String`
    :param username: Username of the chat; for bots only
    :type username: :class:`String`
    :param photo: Photo of the chat; for bots only; may be null, defaults to None
    :type photo: :class:`Photo`, optional
    """

    ID: typing.Literal["sharedChat"] = field(default="sharedChat", metadata={"alias": "@type"})
    chat_id: Int53
    title: String
    username: String
    photo: typing.Optional[Photo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class SharedUser(BaseObject):
    """
    Contains information about a user shared with a bot

    :param user_id: User identifier
    :type user_id: :class:`Int53`
    :param first_name: First name of the user; for bots only
    :type first_name: :class:`String`
    :param last_name: Last name of the user; for bots only
    :type last_name: :class:`String`
    :param username: Username of the user; for bots only
    :type username: :class:`String`
    :param photo: Profile photo of the user; for bots only; may be null, defaults to None
    :type photo: :class:`Photo`, optional
    """

    ID: typing.Literal["sharedUser"] = field(default="sharedUser", metadata={"alias": "@type"})
    user_id: Int53
    first_name: String
    last_name: String
    username: String
    photo: typing.Optional[Photo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class ShippingOption(BaseObject):
    """
    One shipping option

    :param id: Shipping option identifier
    :type id: :class:`String`
    :param title: Option title
    :type title: :class:`String`
    :param price_parts: A list of objects used to calculate the total shipping costs
    :type price_parts: :class:`Vector[LabeledPricePart]`
    """

    ID: typing.Literal["shippingOption"] = field(default="shippingOption", metadata={"alias": "@type"})
    id: String
    title: String
    price_parts: Vector[LabeledPricePart]


@dataclass(slots=True, kw_only=True)
class SpeechRecognitionResultError(BaseObject):
    """
    The speech recognition failed

    :param error: Recognition error. An error with a message "MSG_VOICE_TOO_LONG" is returned when media duration is too big to be recognized
    :type error: :class:`Error`
    """

    ID: typing.Literal["speechRecognitionResultError"] = field(
        default="speechRecognitionResultError", metadata={"alias": "@type"}
    )
    error: Error


@dataclass(slots=True, kw_only=True)
class SpeechRecognitionResultPending(BaseObject):
    """
    The speech recognition is ongoing

    :param partial_text: Partially recognized text
    :type partial_text: :class:`String`
    """

    ID: typing.Literal["speechRecognitionResultPending"] = field(
        default="speechRecognitionResultPending", metadata={"alias": "@type"}
    )
    partial_text: String


@dataclass(slots=True, kw_only=True)
class SpeechRecognitionResultText(BaseObject):
    """
    The speech recognition successfully finished

    :param text: Recognized text
    :type text: :class:`String`
    """

    ID: typing.Literal["speechRecognitionResultText"] = field(
        default="speechRecognitionResultText", metadata={"alias": "@type"}
    )
    text: String


SpeechRecognitionResult = typing.Union[
    SpeechRecognitionResultError,
    SpeechRecognitionResultPending,
    SpeechRecognitionResultText,
]


@dataclass(slots=True, kw_only=True)
class SponsoredMessage(BaseObject):
    """
    Describes a sponsored message

    :param message_id: Message identifier; unique for the chat to which the sponsored message belongs among both ordinary and sponsored messages
    :type message_id: :class:`Int53`
    :param content: Content of the message. Currently, can be only of the types messageText, messageAnimation, messagePhoto, or messageVideo. Video messages can be viewed fullscreen
    :type content: :class:`MessageContent`
    :param sponsor: Information about the sponsor of the message
    :type sponsor: :class:`MessageSponsor`
    :param title: Title of the sponsored message
    :type title: :class:`String`
    :param button_text: Text for the message action button
    :type button_text: :class:`String`
    :param accent_color_id: Identifier of the accent color for title, button text and message background
    :type accent_color_id: :class:`Int32`
    :param is_recommended: True, if the message needs to be labeled as "recommended" instead of "sponsored"
    :type is_recommended: :class:`Bool`
    :param can_be_reported: True, if the message can be reported to Telegram moderators through reportChatSponsoredMessage
    :type can_be_reported: :class:`Bool`
    :param additional_info: If non-empty, additional information about the sponsored message to be shown along with the message
    :type additional_info: :class:`String`
    :param background_custom_emoji_id: Identifier of a custom emoji to be shown on the message background; 0 if none, defaults to None
    :type background_custom_emoji_id: :class:`Int64`, optional
    """

    ID: typing.Literal["sponsoredMessage"] = field(default="sponsoredMessage", metadata={"alias": "@type"})
    message_id: Int53
    content: MessageContent
    sponsor: MessageSponsor
    title: String
    button_text: String
    accent_color_id: Int32
    is_recommended: Bool = field(default=False)
    can_be_reported: Bool = field(default=False)
    additional_info: String = field(default="")
    background_custom_emoji_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class SponsoredMessages(BaseObject):
    """
    Contains a list of sponsored messages

    :param messages: List of sponsored messages
    :type messages: :class:`Vector[SponsoredMessage]`
    :param messages_between: The minimum number of messages between shown sponsored messages, or 0 if only one sponsored message must be shown after all ordinary messages
    :type messages_between: :class:`Int32`
    """

    ID: typing.Literal["sponsoredMessages"] = field(default="sponsoredMessages", metadata={"alias": "@type"})
    messages: Vector[SponsoredMessage]
    messages_between: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class StarAmount(BaseObject):
    """
    Describes a possibly non-integer amount of Telegram Stars

    :param star_count: The integer amount of Telegram Stars rounded to 0
    :type star_count: :class:`Int53`
    :param nanostar_count: The number of 1/1000000000 shares of Telegram Stars; from -999999999 to 999999999
    :type nanostar_count: :class:`Int32`
    """

    ID: typing.Literal["starAmount"] = field(default="starAmount", metadata={"alias": "@type"})
    star_count: Int53
    nanostar_count: Int32


@dataclass(slots=True, kw_only=True)
class StarGiveawayPaymentOption(BaseObject):
    """
    Describes an option for creating Telegram Star giveaway. Use telegramPaymentPurposeStarGiveaway for out-of-store payments

    :param currency: ISO 4217 currency code for the payment
    :type currency: :class:`String`
    :param amount: The amount to pay, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param star_count: Number of Telegram Stars that will be distributed among winners
    :type star_count: :class:`Int53`
    :param yearly_boost_count: Number of times the chat will be boosted for one year if the option is chosen
    :type yearly_boost_count: :class:`Int32`
    :param winner_options: Allowed options for the number of giveaway winners
    :type winner_options: :class:`Vector[StarGiveawayWinnerOption]`
    :param store_product_id: Identifier of the store product associated with the option; may be empty if none
    :type store_product_id: :class:`String`
    :param is_default: True, if the option must be chosen by default
    :type is_default: :class:`Bool`
    :param is_additional: True, if the option must be shown only in the full list of payment options
    :type is_additional: :class:`Bool`
    """

    ID: typing.Literal["starGiveawayPaymentOption"] = field(
        default="starGiveawayPaymentOption", metadata={"alias": "@type"}
    )
    currency: String
    amount: Int53
    star_count: Int53
    yearly_boost_count: Int32
    winner_options: Vector[StarGiveawayWinnerOption]
    store_product_id: String = field(default="")
    is_default: Bool = field(default=False)
    is_additional: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class StarGiveawayPaymentOptions(BaseObject):
    """
    Contains a list of options for creating Telegram Star giveaway

    :param options: The list of options
    :type options: :class:`Vector[StarGiveawayPaymentOption]`
    """

    ID: typing.Literal["starGiveawayPaymentOptions"] = field(
        default="starGiveawayPaymentOptions", metadata={"alias": "@type"}
    )
    options: Vector[StarGiveawayPaymentOption]


@dataclass(slots=True, kw_only=True)
class StarGiveawayWinnerOption(BaseObject):
    """
    Describes an option for the number of winners of a Telegram Star giveaway

    :param winner_count: The number of users that will be chosen as winners
    :type winner_count: :class:`Int32`
    :param won_star_count: The number of Telegram Stars that will be won by the winners of the giveaway
    :type won_star_count: :class:`Int53`
    :param is_default: True, if the option must be chosen by default
    :type is_default: :class:`Bool`
    """

    ID: typing.Literal["starGiveawayWinnerOption"] = field(
        default="starGiveawayWinnerOption", metadata={"alias": "@type"}
    )
    winner_count: Int32
    won_star_count: Int53
    is_default: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class StarPaymentOption(BaseObject):
    """
    Describes an option for buying Telegram Stars. Use telegramPaymentPurposeStars for out-of-store payments

    :param currency: ISO 4217 currency code for the payment
    :type currency: :class:`String`
    :param amount: The amount to pay, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param star_count: Number of Telegram Stars that will be purchased
    :type star_count: :class:`Int53`
    :param store_product_id: Identifier of the store product associated with the option; may be empty if none
    :type store_product_id: :class:`String`
    :param is_additional: True, if the option must be shown only in the full list of payment options
    :type is_additional: :class:`Bool`
    """

    ID: typing.Literal["starPaymentOption"] = field(default="starPaymentOption", metadata={"alias": "@type"})
    currency: String
    amount: Int53
    star_count: Int53
    store_product_id: String = field(default="")
    is_additional: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class StarPaymentOptions(BaseObject):
    """
    Contains a list of options for buying Telegram Stars

    :param options: The list of options
    :type options: :class:`Vector[StarPaymentOption]`
    """

    ID: typing.Literal["starPaymentOptions"] = field(default="starPaymentOptions", metadata={"alias": "@type"})
    options: Vector[StarPaymentOption]


@dataclass(slots=True, kw_only=True)
class StarRevenueStatistics(BaseObject):
    """
    A detailed statistics about Telegram Stars earned by a bot or a chat

    :param revenue_by_day_graph: A graph containing amount of revenue in a given day
    :type revenue_by_day_graph: :class:`StatisticalGraph`
    :param status: Telegram Star revenue status
    :type status: :class:`StarRevenueStatus`
    :param usd_rate: Current conversion rate of a Telegram Star to USD
    :type usd_rate: :class:`Double`
    """

    ID: typing.Literal["starRevenueStatistics"] = field(default="starRevenueStatistics", metadata={"alias": "@type"})
    revenue_by_day_graph: StatisticalGraph
    status: StarRevenueStatus
    usd_rate: Double


@dataclass(slots=True, kw_only=True)
class StarRevenueStatus(BaseObject):
    """
    Contains information about Telegram Stars earned by a bot or a chat

    :param total_amount: Total amount of Telegram Stars earned
    :type total_amount: :class:`StarAmount`
    :param current_amount: The amount of Telegram Stars that aren't withdrawn yet
    :type current_amount: :class:`StarAmount`
    :param available_amount: The amount of Telegram Stars that are available for withdrawal
    :type available_amount: :class:`StarAmount`
    :param withdrawal_enabled: True, if Telegram Stars can be withdrawn now or later
    :type withdrawal_enabled: :class:`Bool`
    :param next_withdrawal_in: Time left before the next withdrawal can be started, in seconds; 0 if withdrawal can be started now
    :type next_withdrawal_in: :class:`Int32`
    """

    ID: typing.Literal["starRevenueStatus"] = field(default="starRevenueStatus", metadata={"alias": "@type"})
    total_amount: StarAmount
    current_amount: StarAmount
    available_amount: StarAmount
    withdrawal_enabled: Bool = field(default=False)
    next_withdrawal_in: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class StarSubscription(BaseObject):
    """
    Contains information about subscription to a channel chat, a bot, or a business account that was paid in Telegram Stars

    :param id: Unique identifier of the subscription
    :type id: :class:`String`
    :param chat_id: Identifier of the chat that is subscribed
    :type chat_id: :class:`Int53`
    :param expiration_date: Point in time (Unix timestamp) when the subscription will expire or expired
    :type expiration_date: :class:`Int32`
    :param pricing: The subscription plan
    :type pricing: :class:`StarSubscriptionPricing`
    :param type_: Type of the subscription
    :type type_: :class:`StarSubscriptionType`
    :param is_canceled: True, if the subscription was canceled
    :type is_canceled: :class:`Bool`
    :param is_expiring: True, if the subscription expires soon and there are no enough Telegram Stars on the user's balance to extend it
    :type is_expiring: :class:`Bool`
    """

    ID: typing.Literal["starSubscription"] = field(default="starSubscription", metadata={"alias": "@type"})
    id: String
    chat_id: Int53
    expiration_date: Int32
    pricing: StarSubscriptionPricing
    type_: StarSubscriptionType = field(default=MISSING, metadata={"alias": "type"})
    is_canceled: Bool = field(default=False)
    is_expiring: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class StarSubscriptionPricing(BaseObject):
    """
    Describes subscription plan paid in Telegram Stars

    :param period: The number of seconds between consecutive Telegram Star debiting
    :type period: :class:`Int32`
    :param star_count: The amount of Telegram Stars that must be paid for each period
    :type star_count: :class:`Int53`
    """

    ID: typing.Literal["starSubscriptionPricing"] = field(
        default="starSubscriptionPricing", metadata={"alias": "@type"}
    )
    period: Int32
    star_count: Int53


@dataclass(slots=True, kw_only=True)
class StarSubscriptionTypeBot(BaseObject):
    """
    Describes a subscription in a bot or a business account

    :param title: Subscription invoice title
    :type title: :class:`String`
    :param photo: Subscription invoice photo
    :type photo: :class:`Photo`
    :param invoice_link: The link to the subscription invoice
    :type invoice_link: :class:`String`
    :param is_canceled_by_bot: True, if the subscription was canceled by the bot and can't be extended
    :type is_canceled_by_bot: :class:`Bool`
    """

    ID: typing.Literal["starSubscriptionTypeBot"] = field(
        default="starSubscriptionTypeBot", metadata={"alias": "@type"}
    )
    title: String
    photo: Photo
    invoice_link: String
    is_canceled_by_bot: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class StarSubscriptionTypeChannel(BaseObject):
    """
    Describes a subscription to a channel chat

    :param can_reuse: True, if the subscription is active and the user can use the method reuseStarSubscription to join the subscribed chat again
    :type can_reuse: :class:`Bool`
    :param invite_link: The invite link that can be used to renew the subscription if it has been expired; may be empty, if the link isn't available anymore
    :type invite_link: :class:`String`
    """

    ID: typing.Literal["starSubscriptionTypeChannel"] = field(
        default="starSubscriptionTypeChannel", metadata={"alias": "@type"}
    )
    can_reuse: Bool = field(default=False)
    invite_link: String = field(default="")


StarSubscriptionType = typing.Union[
    StarSubscriptionTypeBot,
    StarSubscriptionTypeChannel,
]


@dataclass(slots=True, kw_only=True)
class StarSubscriptions(BaseObject):
    """
    Represents a list of Telegram Star subscriptions

    :param star_amount: The amount of owned Telegram Stars
    :type star_amount: :class:`StarAmount`
    :param subscriptions: List of subscriptions for Telegram Stars
    :type subscriptions: :class:`Vector[StarSubscription]`
    :param required_star_count: The number of Telegram Stars required to buy to extend subscriptions expiring soon
    :type required_star_count: :class:`Int53`
    :param next_offset: The offset for the next request. If empty, then there are no more results
    :type next_offset: :class:`String`
    """

    ID: typing.Literal["starSubscriptions"] = field(default="starSubscriptions", metadata={"alias": "@type"})
    star_amount: StarAmount
    subscriptions: Vector[StarSubscription]
    required_star_count: Int53
    next_offset: String = field(default="")


@dataclass(slots=True, kw_only=True)
class StarTransaction(BaseObject):
    """
    Represents a transaction changing the amount of owned Telegram Stars

    :param id: Unique identifier of the transaction
    :type id: :class:`String`
    :param star_amount: The amount of added owned Telegram Stars; negative for outgoing transactions
    :type star_amount: :class:`StarAmount`
    :param date: Point in time (Unix timestamp) when the transaction was completed
    :type date: :class:`Int32`
    :param type_: Type of the transaction
    :type type_: :class:`StarTransactionType`
    :param is_refund: True, if the transaction is a refund of a previous transaction
    :type is_refund: :class:`Bool`
    """

    ID: typing.Literal["starTransaction"] = field(default="starTransaction", metadata={"alias": "@type"})
    id: String
    star_amount: StarAmount
    date: Int32
    type_: StarTransactionType = field(default=MISSING, metadata={"alias": "type"})
    is_refund: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class StarTransactionDirectionIncoming(BaseObject):
    """
    The transaction is incoming and increases the number of owned Telegram Stars
    """

    ID: typing.Literal["starTransactionDirectionIncoming"] = field(
        default="starTransactionDirectionIncoming", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class StarTransactionDirectionOutgoing(BaseObject):
    """
    The transaction is outgoing and decreases the number of owned Telegram Stars
    """

    ID: typing.Literal["starTransactionDirectionOutgoing"] = field(
        default="starTransactionDirectionOutgoing", metadata={"alias": "@type"}
    )


StarTransactionDirection = typing.Union[
    StarTransactionDirectionIncoming,
    StarTransactionDirectionOutgoing,
]


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeAffiliateProgramCommission(BaseObject):
    """
    The transaction is a receiving of a commission from an affiliate program; for regular users, bots and channel chats only

    :param chat_id: Identifier of the chat that created the affiliate program
    :type chat_id: :class:`Int53`
    :param commission_per_mille: The number of Telegram Stars received by the affiliate for each 1000 Telegram Stars received by the program owner
    :type commission_per_mille: :class:`Int32`
    """

    ID: typing.Literal["starTransactionTypeAffiliateProgramCommission"] = field(
        default="starTransactionTypeAffiliateProgramCommission", metadata={"alias": "@type"}
    )
    chat_id: Int53
    commission_per_mille: Int32


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeAppStoreDeposit(BaseObject):
    """
    The transaction is a deposit of Telegram Stars from App Store; for regular users only
    """

    ID: typing.Literal["starTransactionTypeAppStoreDeposit"] = field(
        default="starTransactionTypeAppStoreDeposit", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeBotInvoicePurchase(BaseObject):
    """
    The transaction is a purchase of a product from a bot or a business account by the current user; for regular users only

    :param user_id: Identifier of the bot or the business account user that created the invoice
    :type user_id: :class:`Int53`
    :param product_info: Information about the bought product
    :type product_info: :class:`ProductInfo`
    """

    ID: typing.Literal["starTransactionTypeBotInvoicePurchase"] = field(
        default="starTransactionTypeBotInvoicePurchase", metadata={"alias": "@type"}
    )
    user_id: Int53
    product_info: ProductInfo


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeBotInvoiceSale(BaseObject):
    """
    The transaction is a sale of a product by the bot; for bots only

    :param user_id: Identifier of the user that bought the product
    :type user_id: :class:`Int53`
    :param product_info: Information about the bought product
    :type product_info: :class:`ProductInfo`
    :param invoice_payload: Invoice payload
    :type invoice_payload: :class:`Bytes`
    :param affiliate: Information about the affiliate which received commission from the transaction; may be null if none, defaults to None
    :type affiliate: :class:`AffiliateInfo`, optional
    """

    ID: typing.Literal["starTransactionTypeBotInvoiceSale"] = field(
        default="starTransactionTypeBotInvoiceSale", metadata={"alias": "@type"}
    )
    user_id: Int53
    product_info: ProductInfo
    invoice_payload: Bytes
    affiliate: typing.Optional[AffiliateInfo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeBotPaidMediaPurchase(BaseObject):
    """
    The transaction is a purchase of paid media from a bot or a business account by the current user; for regular users only

    :param user_id: Identifier of the bot or the business account user that sent the paid media
    :type user_id: :class:`Int53`
    :param media: The bought media if the transaction wasn't refunded
    :type media: :class:`Vector[PaidMedia]`
    """

    ID: typing.Literal["starTransactionTypeBotPaidMediaPurchase"] = field(
        default="starTransactionTypeBotPaidMediaPurchase", metadata={"alias": "@type"}
    )
    user_id: Int53
    media: Vector[PaidMedia]


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeBotPaidMediaSale(BaseObject):
    """
    The transaction is a sale of paid media by the bot or a business account managed by the bot; for bots only

    :param user_id: Identifier of the user that bought the media
    :type user_id: :class:`Int53`
    :param media: The bought media
    :type media: :class:`Vector[PaidMedia]`
    :param payload: Bot-provided payload
    :type payload: :class:`String`
    :param affiliate: Information about the affiliate which received commission from the transaction; may be null if none, defaults to None
    :type affiliate: :class:`AffiliateInfo`, optional
    """

    ID: typing.Literal["starTransactionTypeBotPaidMediaSale"] = field(
        default="starTransactionTypeBotPaidMediaSale", metadata={"alias": "@type"}
    )
    user_id: Int53
    media: Vector[PaidMedia]
    payload: String
    affiliate: typing.Optional[AffiliateInfo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeBotSubscriptionPurchase(BaseObject):
    """
    The transaction is a purchase of a subscription from a bot or a business account by the current user; for regular users only

    :param user_id: Identifier of the bot or the business account user that created the subscription link
    :type user_id: :class:`Int53`
    :param subscription_period: The number of seconds between consecutive Telegram Star debitings
    :type subscription_period: :class:`Int32`
    :param product_info: Information about the bought subscription
    :type product_info: :class:`ProductInfo`
    """

    ID: typing.Literal["starTransactionTypeBotSubscriptionPurchase"] = field(
        default="starTransactionTypeBotSubscriptionPurchase", metadata={"alias": "@type"}
    )
    user_id: Int53
    subscription_period: Int32
    product_info: ProductInfo


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeBotSubscriptionSale(BaseObject):
    """
    The transaction is a sale of a subscription by the bot; for bots only

    :param user_id: Identifier of the user that bought the subscription
    :type user_id: :class:`Int53`
    :param subscription_period: The number of seconds between consecutive Telegram Star debitings
    :type subscription_period: :class:`Int32`
    :param product_info: Information about the bought subscription
    :type product_info: :class:`ProductInfo`
    :param invoice_payload: Invoice payload
    :type invoice_payload: :class:`Bytes`
    :param affiliate: Information about the affiliate which received commission from the transaction; may be null if none, defaults to None
    :type affiliate: :class:`AffiliateInfo`, optional
    """

    ID: typing.Literal["starTransactionTypeBotSubscriptionSale"] = field(
        default="starTransactionTypeBotSubscriptionSale", metadata={"alias": "@type"}
    )
    user_id: Int53
    subscription_period: Int32
    product_info: ProductInfo
    invoice_payload: Bytes
    affiliate: typing.Optional[AffiliateInfo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeChannelPaidMediaPurchase(BaseObject):
    """
    The transaction is a purchase of paid media from a channel by the current user; for regular users only

    :param chat_id: Identifier of the channel chat that sent the paid media
    :type chat_id: :class:`Int53`
    :param message_id: Identifier of the corresponding message with paid media; can be 0 or an identifier of a deleted message
    :type message_id: :class:`Int53`
    :param media: The bought media if the transaction wasn't refunded
    :type media: :class:`Vector[PaidMedia]`
    """

    ID: typing.Literal["starTransactionTypeChannelPaidMediaPurchase"] = field(
        default="starTransactionTypeChannelPaidMediaPurchase", metadata={"alias": "@type"}
    )
    chat_id: Int53
    message_id: Int53
    media: Vector[PaidMedia]


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeChannelPaidMediaSale(BaseObject):
    """
    The transaction is a sale of paid media by the channel chat; for channel chats only

    :param user_id: Identifier of the user that bought the media
    :type user_id: :class:`Int53`
    :param message_id: Identifier of the corresponding message with paid media; can be 0 or an identifier of a deleted message
    :type message_id: :class:`Int53`
    :param media: The bought media
    :type media: :class:`Vector[PaidMedia]`
    """

    ID: typing.Literal["starTransactionTypeChannelPaidMediaSale"] = field(
        default="starTransactionTypeChannelPaidMediaSale", metadata={"alias": "@type"}
    )
    user_id: Int53
    message_id: Int53
    media: Vector[PaidMedia]


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeChannelPaidReactionReceive(BaseObject):
    """
    The transaction is a receiving of a paid reaction to a message by the channel chat; for channel chats only

    :param user_id: Identifier of the user that added the paid reaction
    :type user_id: :class:`Int53`
    :param message_id: Identifier of the reacted message; can be 0 or an identifier of a deleted message
    :type message_id: :class:`Int53`
    """

    ID: typing.Literal["starTransactionTypeChannelPaidReactionReceive"] = field(
        default="starTransactionTypeChannelPaidReactionReceive", metadata={"alias": "@type"}
    )
    user_id: Int53
    message_id: Int53


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeChannelPaidReactionSend(BaseObject):
    """
    The transaction is a sending of a paid reaction to a message in a channel chat by the current user; for regular users only

    :param chat_id: Identifier of the channel chat
    :type chat_id: :class:`Int53`
    :param message_id: Identifier of the reacted message; can be 0 or an identifier of a deleted message
    :type message_id: :class:`Int53`
    """

    ID: typing.Literal["starTransactionTypeChannelPaidReactionSend"] = field(
        default="starTransactionTypeChannelPaidReactionSend", metadata={"alias": "@type"}
    )
    chat_id: Int53
    message_id: Int53


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeChannelSubscriptionPurchase(BaseObject):
    """
    The transaction is a purchase of a subscription to a channel chat by the current user; for regular users only

    :param chat_id: Identifier of the channel chat that created the subscription
    :type chat_id: :class:`Int53`
    :param subscription_period: The number of seconds between consecutive Telegram Star debitings
    :type subscription_period: :class:`Int32`
    """

    ID: typing.Literal["starTransactionTypeChannelSubscriptionPurchase"] = field(
        default="starTransactionTypeChannelSubscriptionPurchase", metadata={"alias": "@type"}
    )
    chat_id: Int53
    subscription_period: Int32


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeChannelSubscriptionSale(BaseObject):
    """
    The transaction is a sale of a subscription by the channel chat; for channel chats only

    :param user_id: Identifier of the user that bought the subscription
    :type user_id: :class:`Int53`
    :param subscription_period: The number of seconds between consecutive Telegram Star debitings
    :type subscription_period: :class:`Int32`
    """

    ID: typing.Literal["starTransactionTypeChannelSubscriptionSale"] = field(
        default="starTransactionTypeChannelSubscriptionSale", metadata={"alias": "@type"}
    )
    user_id: Int53
    subscription_period: Int32


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeFragmentDeposit(BaseObject):
    """
    The transaction is a deposit of Telegram Stars from Fragment; for regular users and bots only
    """

    ID: typing.Literal["starTransactionTypeFragmentDeposit"] = field(
        default="starTransactionTypeFragmentDeposit", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeFragmentWithdrawal(BaseObject):
    """
    The transaction is a withdrawal of earned Telegram Stars to Fragment; for bots and channel chats only

    :param withdrawal_state: State of the withdrawal; may be null for refunds from Fragment, defaults to None
    :type withdrawal_state: :class:`RevenueWithdrawalState`, optional
    """

    ID: typing.Literal["starTransactionTypeFragmentWithdrawal"] = field(
        default="starTransactionTypeFragmentWithdrawal", metadata={"alias": "@type"}
    )
    withdrawal_state: typing.Optional[RevenueWithdrawalState] = field(default=None)


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeGiftPurchase(BaseObject):
    """
    The transaction is a purchase of a regular gift; for regular users and bots only

    :param owner_id: Identifier of the user or the channel that received the gift
    :type owner_id: :class:`MessageSender`
    :param gift: The gift
    :type gift: :class:`Gift`
    """

    ID: typing.Literal["starTransactionTypeGiftPurchase"] = field(
        default="starTransactionTypeGiftPurchase", metadata={"alias": "@type"}
    )
    owner_id: MessageSender
    gift: Gift


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeGiftSale(BaseObject):
    """
    The transaction is a sale of a received gift; for regular users and channel chats only

    :param user_id: Identifier of the user that sent the gift
    :type user_id: :class:`Int53`
    :param gift: The gift
    :type gift: :class:`Gift`
    """

    ID: typing.Literal["starTransactionTypeGiftSale"] = field(
        default="starTransactionTypeGiftSale", metadata={"alias": "@type"}
    )
    user_id: Int53
    gift: Gift


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeGiftTransfer(BaseObject):
    """
    The transaction is a transfer of an upgraded gift; for regular users only

    :param owner_id: Identifier of the user or the channel that received the gift
    :type owner_id: :class:`MessageSender`
    :param gift: The gift
    :type gift: :class:`UpgradedGift`
    """

    ID: typing.Literal["starTransactionTypeGiftTransfer"] = field(
        default="starTransactionTypeGiftTransfer", metadata={"alias": "@type"}
    )
    owner_id: MessageSender
    gift: UpgradedGift


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeGiftUpgrade(BaseObject):
    """
    The transaction is an upgrade of a gift; for regular users only

    :param gift: The upgraded gift
    :type gift: :class:`UpgradedGift`
    """

    ID: typing.Literal["starTransactionTypeGiftUpgrade"] = field(
        default="starTransactionTypeGiftUpgrade", metadata={"alias": "@type"}
    )
    gift: UpgradedGift


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeGiveawayDeposit(BaseObject):
    """
    The transaction is a deposit of Telegram Stars from a giveaway; for regular users only

    :param chat_id: Identifier of a supergroup or a channel chat that created the giveaway
    :type chat_id: :class:`Int53`
    :param giveaway_message_id: Identifier of the message with the giveaway; can be 0 or an identifier of a deleted message
    :type giveaway_message_id: :class:`Int53`
    """

    ID: typing.Literal["starTransactionTypeGiveawayDeposit"] = field(
        default="starTransactionTypeGiveawayDeposit", metadata={"alias": "@type"}
    )
    chat_id: Int53
    giveaway_message_id: Int53


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeGooglePlayDeposit(BaseObject):
    """
    The transaction is a deposit of Telegram Stars from Google Play; for regular users only
    """

    ID: typing.Literal["starTransactionTypeGooglePlayDeposit"] = field(
        default="starTransactionTypeGooglePlayDeposit", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class StarTransactionTypePremiumBotDeposit(BaseObject):
    """
    The transaction is a deposit of Telegram Stars from the Premium bot; for regular users only
    """

    ID: typing.Literal["starTransactionTypePremiumBotDeposit"] = field(
        default="starTransactionTypePremiumBotDeposit", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeTelegramAdsWithdrawal(BaseObject):
    """
    The transaction is a withdrawal of earned Telegram Stars to Telegram Ad platform; for bots and channel chats only
    """

    ID: typing.Literal["starTransactionTypeTelegramAdsWithdrawal"] = field(
        default="starTransactionTypeTelegramAdsWithdrawal", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeTelegramApiUsage(BaseObject):
    """
    The transaction is a payment for Telegram API usage; for bots only

    :param request_count: The number of billed requests
    :type request_count: :class:`Int32`
    """

    ID: typing.Literal["starTransactionTypeTelegramApiUsage"] = field(
        default="starTransactionTypeTelegramApiUsage", metadata={"alias": "@type"}
    )
    request_count: Int32


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeUnsupported(BaseObject):
    """
    The transaction is a transaction of an unsupported type
    """

    ID: typing.Literal["starTransactionTypeUnsupported"] = field(
        default="starTransactionTypeUnsupported", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class StarTransactionTypeUserDeposit(BaseObject):
    """
    The transaction is a deposit of Telegram Stars by another user; for regular users only

    :param sticker: The sticker to be shown in the transaction information; may be null if unknown, defaults to None
    :type sticker: :class:`Sticker`, optional
    :param user_id: Identifier of the user that gifted Telegram Stars; 0 if the user was anonymous
    :type user_id: :class:`Int53`
    """

    ID: typing.Literal["starTransactionTypeUserDeposit"] = field(
        default="starTransactionTypeUserDeposit", metadata={"alias": "@type"}
    )
    sticker: typing.Optional[Sticker] = field(default=None)
    user_id: Int53 = field(default=0)


StarTransactionType = typing.Union[
    StarTransactionTypeAffiliateProgramCommission,
    StarTransactionTypeAppStoreDeposit,
    StarTransactionTypeBotInvoicePurchase,
    StarTransactionTypeBotInvoiceSale,
    StarTransactionTypeBotPaidMediaPurchase,
    StarTransactionTypeBotPaidMediaSale,
    StarTransactionTypeBotSubscriptionPurchase,
    StarTransactionTypeBotSubscriptionSale,
    StarTransactionTypeChannelPaidMediaPurchase,
    StarTransactionTypeChannelPaidMediaSale,
    StarTransactionTypeChannelPaidReactionReceive,
    StarTransactionTypeChannelPaidReactionSend,
    StarTransactionTypeChannelSubscriptionPurchase,
    StarTransactionTypeChannelSubscriptionSale,
    StarTransactionTypeFragmentDeposit,
    StarTransactionTypeFragmentWithdrawal,
    StarTransactionTypeGiftPurchase,
    StarTransactionTypeGiftSale,
    StarTransactionTypeGiftTransfer,
    StarTransactionTypeGiftUpgrade,
    StarTransactionTypeGiveawayDeposit,
    StarTransactionTypeGooglePlayDeposit,
    StarTransactionTypePremiumBotDeposit,
    StarTransactionTypeTelegramAdsWithdrawal,
    StarTransactionTypeTelegramApiUsage,
    StarTransactionTypeUnsupported,
    StarTransactionTypeUserDeposit,
]


@dataclass(slots=True, kw_only=True)
class StarTransactions(BaseObject):
    """
    Represents a list of Telegram Star transactions

    :param star_amount: The amount of owned Telegram Stars
    :type star_amount: :class:`StarAmount`
    :param transactions: List of transactions with Telegram Stars
    :type transactions: :class:`Vector[StarTransaction]`
    :param next_offset: The offset for the next request. If empty, then there are no more results
    :type next_offset: :class:`String`
    """

    ID: typing.Literal["starTransactions"] = field(default="starTransactions", metadata={"alias": "@type"})
    star_amount: StarAmount
    transactions: Vector[StarTransaction]
    next_offset: String = field(default="")


@dataclass(slots=True, kw_only=True)
class StatisticalGraphAsync(BaseObject):
    """
    The graph data to be asynchronously loaded through getStatisticalGraph

    :param token: The token to use for data loading
    :type token: :class:`String`
    """

    ID: typing.Literal["statisticalGraphAsync"] = field(default="statisticalGraphAsync", metadata={"alias": "@type"})
    token: String


@dataclass(slots=True, kw_only=True)
class StatisticalGraphData(BaseObject):
    """
    A graph data

    :param json_data: Graph data in JSON format
    :type json_data: :class:`String`
    :param zoom_token: If non-empty, a token which can be used to receive a zoomed in graph
    :type zoom_token: :class:`String`
    """

    ID: typing.Literal["statisticalGraphData"] = field(default="statisticalGraphData", metadata={"alias": "@type"})
    json_data: String
    zoom_token: String = field(default="")


@dataclass(slots=True, kw_only=True)
class StatisticalGraphError(BaseObject):
    """
    An error message to be shown to the user instead of the graph

    :param error_message: The error message
    :type error_message: :class:`String`
    """

    ID: typing.Literal["statisticalGraphError"] = field(default="statisticalGraphError", metadata={"alias": "@type"})
    error_message: String


StatisticalGraph = typing.Union[
    StatisticalGraphAsync,
    StatisticalGraphData,
    StatisticalGraphError,
]


@dataclass(slots=True, kw_only=True)
class StatisticalValue(BaseObject):
    """
    A value with information about its recent changes

    :param value: The current value
    :type value: :class:`Double`
    :param previous_value: The value for the previous day
    :type previous_value: :class:`Double`
    :param growth_rate_percentage: The growth rate of the value, as a percentage
    :type growth_rate_percentage: :class:`Double`
    """

    ID: typing.Literal["statisticalValue"] = field(default="statisticalValue", metadata={"alias": "@type"})
    value: Double
    previous_value: Double
    growth_rate_percentage: Double


@dataclass(slots=True, kw_only=True)
class Sticker(BaseObject):
    """
    Describes a sticker

    :param width: Sticker width; as defined by the sender
    :type width: :class:`Int32`
    :param height: Sticker height; as defined by the sender
    :type height: :class:`Int32`
    :param emoji: Emoji corresponding to the sticker
    :type emoji: :class:`String`
    :param format_: Sticker format
    :type format_: :class:`StickerFormat`
    :param full_type: Sticker's full type
    :type full_type: :class:`StickerFullType`
    :param sticker: File containing the sticker
    :type sticker: :class:`File`
    :param thumbnail: Sticker thumbnail in WEBP or JPEG format; may be null, defaults to None
    :type thumbnail: :class:`Thumbnail`, optional
    :param id: Unique sticker identifier within the set; 0 if none, defaults to None
    :type id: :class:`Int64`, optional
    :param set_id: Identifier of the sticker set to which the sticker belongs; 0 if none, defaults to None
    :type set_id: :class:`Int64`, optional
    """

    ID: typing.Literal["sticker"] = field(default="sticker", metadata={"alias": "@type"})
    width: Int32
    height: Int32
    emoji: String
    format_: StickerFormat = field(default=MISSING, metadata={"alias": "format"})
    full_type: StickerFullType
    sticker: File
    thumbnail: typing.Optional[Thumbnail] = field(default=None)
    id: typing.Optional[Int64] = field(default=0)
    set_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class StickerFormatTgs(BaseObject):
    """
    The sticker is an animation in TGS format
    """

    ID: typing.Literal["stickerFormatTgs"] = field(default="stickerFormatTgs", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class StickerFormatWebm(BaseObject):
    """
    The sticker is a video in WEBM format
    """

    ID: typing.Literal["stickerFormatWebm"] = field(default="stickerFormatWebm", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class StickerFormatWebp(BaseObject):
    """
    The sticker is an image in WEBP format
    """

    ID: typing.Literal["stickerFormatWebp"] = field(default="stickerFormatWebp", metadata={"alias": "@type"})


StickerFormat = typing.Union[
    StickerFormatTgs,
    StickerFormatWebm,
    StickerFormatWebp,
]


@dataclass(slots=True, kw_only=True)
class StickerFullTypeCustomEmoji(BaseObject):
    """
    The sticker is a custom emoji to be used inside message text and caption. Currently, only Telegram Premium users can use custom emoji

    :param custom_emoji_id: Identifier of the custom emoji
    :type custom_emoji_id: :class:`Int64`
    :param needs_repainting: True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places
    :type needs_repainting: :class:`Bool`
    """

    ID: typing.Literal["stickerFullTypeCustomEmoji"] = field(
        default="stickerFullTypeCustomEmoji", metadata={"alias": "@type"}
    )
    custom_emoji_id: Int64
    needs_repainting: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class StickerFullTypeMask(BaseObject):
    """
    The sticker is a mask in WEBP format to be placed on photos or videos

    :param mask_position: Position where the mask is placed; may be null, defaults to None
    :type mask_position: :class:`MaskPosition`, optional
    """

    ID: typing.Literal["stickerFullTypeMask"] = field(default="stickerFullTypeMask", metadata={"alias": "@type"})
    mask_position: typing.Optional[MaskPosition] = field(default=None)


@dataclass(slots=True, kw_only=True)
class StickerFullTypeRegular(BaseObject):
    """
    The sticker is a regular sticker

    :param premium_animation: Premium animation of the sticker; may be null. If present, only Telegram Premium users can use the sticker, defaults to None
    :type premium_animation: :class:`File`, optional
    """

    ID: typing.Literal["stickerFullTypeRegular"] = field(default="stickerFullTypeRegular", metadata={"alias": "@type"})
    premium_animation: typing.Optional[File] = field(default=None)


StickerFullType = typing.Union[
    StickerFullTypeCustomEmoji,
    StickerFullTypeMask,
    StickerFullTypeRegular,
]


@dataclass(slots=True, kw_only=True)
class StickerSet(BaseObject):
    """
    Represents a sticker set

    :param id: Identifier of the sticker set
    :type id: :class:`Int64`
    :param title: Title of the sticker set
    :type title: :class:`String`
    :param name: Name of the sticker set
    :type name: :class:`String`
    :param sticker_type: Type of the stickers in the set
    :type sticker_type: :class:`StickerType`
    :param is_viewed: True for already viewed trending sticker sets
    :type is_viewed: :class:`Bool`
    :param stickers: List of stickers in this set
    :type stickers: :class:`Vector[Sticker]`
    :param emojis: A list of emojis corresponding to the stickers in the same order. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
    :type emojis: :class:`Vector[Emojis]`
    :param thumbnail: Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed, defaults to None
    :type thumbnail: :class:`Thumbnail`, optional
    :param thumbnail_outline: Sticker set thumbnail's outline; may be null if unknown, defaults to None
    :type thumbnail_outline: :class:`Outline`, optional
    :param is_owned: True, if the sticker set is owned by the current user
    :type is_owned: :class:`Bool`
    :param is_installed: True, if the sticker set has been installed by the current user
    :type is_installed: :class:`Bool`
    :param is_archived: True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
    :type is_archived: :class:`Bool`
    :param is_official: True, if the sticker set is official
    :type is_official: :class:`Bool`
    :param needs_repainting: True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only
    :type needs_repainting: :class:`Bool`
    :param is_allowed_as_chat_emoji_status: True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only
    :type is_allowed_as_chat_emoji_status: :class:`Bool`
    """

    ID: typing.Literal["stickerSet"] = field(default="stickerSet", metadata={"alias": "@type"})
    id: Int64
    title: String
    name: String
    sticker_type: StickerType
    is_viewed: Bool
    stickers: Vector[Sticker]
    emojis: Vector[Emojis]
    thumbnail: typing.Optional[Thumbnail] = field(default=None)
    thumbnail_outline: typing.Optional[Outline] = field(default=None)
    is_owned: Bool = field(default=False)
    is_installed: Bool = field(default=False)
    is_archived: Bool = field(default=False)
    is_official: Bool = field(default=False)
    needs_repainting: Bool = field(default=False)
    is_allowed_as_chat_emoji_status: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class StickerSetInfo(BaseObject):
    """
    Represents short information about a sticker set

    :param id: Identifier of the sticker set
    :type id: :class:`Int64`
    :param title: Title of the sticker set
    :type title: :class:`String`
    :param name: Name of the sticker set
    :type name: :class:`String`
    :param sticker_type: Type of the stickers in the set
    :type sticker_type: :class:`StickerType`
    :param is_viewed: True for already viewed trending sticker sets
    :type is_viewed: :class:`Bool`
    :param size: Total number of stickers in the set
    :type size: :class:`Int32`
    :param covers: Up to the first 5 stickers from the set, depending on the context. If the application needs more stickers the full sticker set needs to be requested
    :type covers: :class:`Vector[Sticker]`
    :param thumbnail: Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed, defaults to None
    :type thumbnail: :class:`Thumbnail`, optional
    :param thumbnail_outline: Sticker set thumbnail's outline; may be null if unknown, defaults to None
    :type thumbnail_outline: :class:`Outline`, optional
    :param is_owned: True, if the sticker set is owned by the current user
    :type is_owned: :class:`Bool`
    :param is_installed: True, if the sticker set has been installed by the current user
    :type is_installed: :class:`Bool`
    :param is_archived: True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
    :type is_archived: :class:`Bool`
    :param is_official: True, if the sticker set is official
    :type is_official: :class:`Bool`
    :param needs_repainting: True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only
    :type needs_repainting: :class:`Bool`
    :param is_allowed_as_chat_emoji_status: True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only
    :type is_allowed_as_chat_emoji_status: :class:`Bool`
    """

    ID: typing.Literal["stickerSetInfo"] = field(default="stickerSetInfo", metadata={"alias": "@type"})
    id: Int64
    title: String
    name: String
    sticker_type: StickerType
    is_viewed: Bool
    size: Int32
    covers: Vector[Sticker]
    thumbnail: typing.Optional[Thumbnail] = field(default=None)
    thumbnail_outline: typing.Optional[Outline] = field(default=None)
    is_owned: Bool = field(default=False)
    is_installed: Bool = field(default=False)
    is_archived: Bool = field(default=False)
    is_official: Bool = field(default=False)
    needs_repainting: Bool = field(default=False)
    is_allowed_as_chat_emoji_status: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class StickerSets(BaseObject):
    """
    Represents a list of sticker sets

    :param total_count: Approximate total number of sticker sets found
    :type total_count: :class:`Int32`
    :param sets: List of sticker sets
    :type sets: :class:`Vector[StickerSetInfo]`
    """

    ID: typing.Literal["stickerSets"] = field(default="stickerSets", metadata={"alias": "@type"})
    total_count: Int32
    sets: Vector[StickerSetInfo]


@dataclass(slots=True, kw_only=True)
class StickerTypeCustomEmoji(BaseObject):
    """
    The sticker is a custom emoji to be used inside message text and caption
    """

    ID: typing.Literal["stickerTypeCustomEmoji"] = field(default="stickerTypeCustomEmoji", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class StickerTypeMask(BaseObject):
    """
    The sticker is a mask in WEBP format to be placed on photos or videos
    """

    ID: typing.Literal["stickerTypeMask"] = field(default="stickerTypeMask", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class StickerTypeRegular(BaseObject):
    """
    The sticker is a regular sticker
    """

    ID: typing.Literal["stickerTypeRegular"] = field(default="stickerTypeRegular", metadata={"alias": "@type"})


StickerType = typing.Union[
    StickerTypeCustomEmoji,
    StickerTypeMask,
    StickerTypeRegular,
]


@dataclass(slots=True, kw_only=True)
class Stickers(BaseObject):
    """
    Represents a list of stickers

    :param stickers: List of stickers
    :type stickers: :class:`Vector[Sticker]`
    """

    ID: typing.Literal["stickers"] = field(default="stickers", metadata={"alias": "@type"})
    stickers: Vector[Sticker]


@dataclass(slots=True, kw_only=True)
class StorageStatistics(BaseObject):
    """
    Contains the exact storage usage statistics split by chats and file type

    :param size: Total size of files, in bytes
    :type size: :class:`Int53`
    :param count: Total number of files
    :type count: :class:`Int32`
    :param by_chat: Statistics split by chats
    :type by_chat: :class:`Vector[StorageStatisticsByChat]`
    """

    ID: typing.Literal["storageStatistics"] = field(default="storageStatistics", metadata={"alias": "@type"})
    size: Int53
    count: Int32
    by_chat: Vector[StorageStatisticsByChat]


@dataclass(slots=True, kw_only=True)
class StorageStatisticsByChat(BaseObject):
    """
    Contains the storage usage statistics for a specific chat

    :param size: Total size of the files in the chat, in bytes
    :type size: :class:`Int53`
    :param count: Total number of files in the chat
    :type count: :class:`Int32`
    :param by_file_type: Statistics split by file types
    :type by_file_type: :class:`Vector[StorageStatisticsByFileType]`
    :param chat_id: Chat identifier; 0 if none, defaults to None
    :type chat_id: :class:`Int53`, optional
    """

    ID: typing.Literal["storageStatisticsByChat"] = field(
        default="storageStatisticsByChat", metadata={"alias": "@type"}
    )
    size: Int53
    count: Int32
    by_file_type: Vector[StorageStatisticsByFileType]
    chat_id: typing.Optional[Int53] = field(default=0)


@dataclass(slots=True, kw_only=True)
class StorageStatisticsByFileType(BaseObject):
    """
    Contains the storage usage statistics for a specific file type

    :param file_type: File type
    :type file_type: :class:`FileType`
    :param size: Total size of the files, in bytes
    :type size: :class:`Int53`
    :param count: Total number of files
    :type count: :class:`Int32`
    """

    ID: typing.Literal["storageStatisticsByFileType"] = field(
        default="storageStatisticsByFileType", metadata={"alias": "@type"}
    )
    file_type: FileType
    size: Int53
    count: Int32


@dataclass(slots=True, kw_only=True)
class StorageStatisticsFast(BaseObject):
    """
    Contains approximate storage usage statistics, excluding files of unknown file type

    :param files_size: Approximate total size of files, in bytes
    :type files_size: :class:`Int53`
    :param file_count: Approximate number of files
    :type file_count: :class:`Int32`
    :param database_size: Size of the database
    :type database_size: :class:`Int53`
    :param language_pack_database_size: Size of the language pack database
    :type language_pack_database_size: :class:`Int53`
    :param log_size: Size of the TDLib internal log
    :type log_size: :class:`Int53`
    """

    ID: typing.Literal["storageStatisticsFast"] = field(default="storageStatisticsFast", metadata={"alias": "@type"})
    files_size: Int53
    file_count: Int32
    database_size: Int53
    language_pack_database_size: Int53
    log_size: Int53


@dataclass(slots=True, kw_only=True)
class StorePaymentPurposeGiftedStars(BaseObject):
    """
    The user buying Telegram Stars for other users

    :param user_id: Identifier of the user to which Telegram Stars are gifted
    :type user_id: :class:`Int53`
    :param currency: ISO 4217 currency code of the payment currency
    :type currency: :class:`String`
    :param amount: Paid amount, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param star_count: Number of bought Telegram Stars
    :type star_count: :class:`Int53`
    """

    ID: typing.Literal["storePaymentPurposeGiftedStars"] = field(
        default="storePaymentPurposeGiftedStars", metadata={"alias": "@type"}
    )
    user_id: Int53
    currency: String
    amount: Int53
    star_count: Int53


@dataclass(slots=True, kw_only=True)
class StorePaymentPurposePremiumGiftCodes(BaseObject):
    """
    The user creating Telegram Premium gift codes for other users

    :param currency: ISO 4217 currency code of the payment currency
    :type currency: :class:`String`
    :param amount: Paid amount, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param user_ids: Identifiers of the users which can activate the gift codes
    :type user_ids: :class:`Vector[Int53]`
    :param text: Text to show along with the gift codes; 0-getOption("gift_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed
    :type text: :class:`FormattedText`
    :param boosted_chat_id: Identifier of the supergroup or channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user; 0 if none, defaults to None
    :type boosted_chat_id: :class:`Int53`, optional
    """

    ID: typing.Literal["storePaymentPurposePremiumGiftCodes"] = field(
        default="storePaymentPurposePremiumGiftCodes", metadata={"alias": "@type"}
    )
    currency: String
    amount: Int53
    user_ids: Vector[Int53]
    text: FormattedText
    boosted_chat_id: typing.Optional[Int53] = field(default=0)


@dataclass(slots=True, kw_only=True)
class StorePaymentPurposePremiumGiveaway(BaseObject):
    """
    The user creating a Telegram Premium giveaway

    :param parameters: Giveaway parameters
    :type parameters: :class:`GiveawayParameters`
    :param currency: ISO 4217 currency code of the payment currency
    :type currency: :class:`String`
    :param amount: Paid amount, in the smallest units of the currency
    :type amount: :class:`Int53`
    """

    ID: typing.Literal["storePaymentPurposePremiumGiveaway"] = field(
        default="storePaymentPurposePremiumGiveaway", metadata={"alias": "@type"}
    )
    parameters: GiveawayParameters
    currency: String
    amount: Int53


@dataclass(slots=True, kw_only=True)
class StorePaymentPurposePremiumSubscription(BaseObject):
    """
    The user subscribing to Telegram Premium

    :param is_restore: Pass true if this is a restore of a Telegram Premium purchase; only for App Store
    :type is_restore: :class:`Bool`
    :param is_upgrade: Pass true if this is an upgrade from a monthly subscription to early subscription; only for App Store
    :type is_upgrade: :class:`Bool`
    """

    ID: typing.Literal["storePaymentPurposePremiumSubscription"] = field(
        default="storePaymentPurposePremiumSubscription", metadata={"alias": "@type"}
    )
    is_restore: Bool = field(default=False)
    is_upgrade: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class StorePaymentPurposeStarGiveaway(BaseObject):
    """
    The user creating a Telegram Star giveaway

    :param parameters: Giveaway parameters
    :type parameters: :class:`GiveawayParameters`
    :param currency: ISO 4217 currency code of the payment currency
    :type currency: :class:`String`
    :param amount: Paid amount, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param winner_count: The number of users to receive Telegram Stars
    :type winner_count: :class:`Int32`
    :param star_count: The number of Telegram Stars to be distributed through the giveaway
    :type star_count: :class:`Int53`
    """

    ID: typing.Literal["storePaymentPurposeStarGiveaway"] = field(
        default="storePaymentPurposeStarGiveaway", metadata={"alias": "@type"}
    )
    parameters: GiveawayParameters
    currency: String
    amount: Int53
    winner_count: Int32
    star_count: Int53


@dataclass(slots=True, kw_only=True)
class StorePaymentPurposeStars(BaseObject):
    """
    The user buying Telegram Stars

    :param currency: ISO 4217 currency code of the payment currency
    :type currency: :class:`String`
    :param amount: Paid amount, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param star_count: Number of bought Telegram Stars
    :type star_count: :class:`Int53`
    """

    ID: typing.Literal["storePaymentPurposeStars"] = field(
        default="storePaymentPurposeStars", metadata={"alias": "@type"}
    )
    currency: String
    amount: Int53
    star_count: Int53


StorePaymentPurpose = typing.Union[
    StorePaymentPurposeGiftedStars,
    StorePaymentPurposePremiumGiftCodes,
    StorePaymentPurposePremiumGiveaway,
    StorePaymentPurposePremiumSubscription,
    StorePaymentPurposeStarGiveaway,
    StorePaymentPurposeStars,
]


@dataclass(slots=True, kw_only=True)
class Stories(BaseObject):
    """
    Represents a list of stories

    :param total_count: Approximate total number of stories found
    :type total_count: :class:`Int32`
    :param stories: The list of stories
    :type stories: :class:`Vector[Story]`
    :param pinned_story_ids: Identifiers of the pinned stories; returned only in getChatPostedToChatPageStories with from_story_id == 0
    :type pinned_story_ids: :class:`Vector[Int32]`
    """

    ID: typing.Literal["stories"] = field(default="stories", metadata={"alias": "@type"})
    total_count: Int32
    stories: Vector[Story]
    pinned_story_ids: Vector[Int32]


@dataclass(slots=True, kw_only=True)
class Story(BaseObject):
    """
    Represents a story

    :param id: Unique story identifier among stories of the given sender
    :type id: :class:`Int32`
    :param sender_chat_id: Identifier of the chat that posted the story
    :type sender_chat_id: :class:`Int53`
    :param date: Point in time (Unix timestamp) when the story was published
    :type date: :class:`Int32`
    :param privacy_settings: Privacy rules affecting story visibility; may be approximate for non-owned stories
    :type privacy_settings: :class:`StoryPrivacySettings`
    :param content: Content of the story
    :type content: :class:`StoryContent`
    :param areas: Clickable areas to be shown on the story content
    :type areas: :class:`Vector[StoryArea]`
    :param caption: Caption of the story
    :type caption: :class:`FormattedText`
    :param sender_id: Identifier of the sender of the story; may be null if the story is posted on behalf of the sender_chat_id, defaults to None
    :type sender_id: :class:`MessageSender`, optional
    :param repost_info: Information about the original story; may be null if the story wasn't reposted, defaults to None
    :type repost_info: :class:`StoryRepostInfo`, optional
    :param interaction_info: Information about interactions with the story; may be null if the story isn't owned or there were no interactions, defaults to None
    :type interaction_info: :class:`StoryInteractionInfo`, optional
    :param chosen_reaction_type: Type of the chosen reaction; may be null if none, defaults to None
    :type chosen_reaction_type: :class:`ReactionType`, optional
    :param is_being_sent: True, if the story is being sent by the current user
    :type is_being_sent: :class:`Bool`
    :param is_being_edited: True, if the story is being edited by the current user
    :type is_being_edited: :class:`Bool`
    :param is_edited: True, if the story was edited
    :type is_edited: :class:`Bool`
    :param is_posted_to_chat_page: True, if the story is saved in the sender's profile and will be available there after expiration
    :type is_posted_to_chat_page: :class:`Bool`
    :param is_visible_only_for_self: True, if the story is visible only for the current user
    :type is_visible_only_for_self: :class:`Bool`
    :param can_be_deleted: True, if the story can be deleted
    :type can_be_deleted: :class:`Bool`
    :param can_be_edited: True, if the story can be edited
    :type can_be_edited: :class:`Bool`
    :param can_be_forwarded: True, if the story can be forwarded as a message. Otherwise, screenshots and saving of the story content must be also forbidden
    :type can_be_forwarded: :class:`Bool`
    :param can_be_replied: True, if the story can be replied in the chat with the story sender
    :type can_be_replied: :class:`Bool`
    :param can_toggle_is_posted_to_chat_page: True, if the story's is_posted_to_chat_page value can be changed
    :type can_toggle_is_posted_to_chat_page: :class:`Bool`
    :param can_get_statistics: True, if the story statistics are available through getStoryStatistics
    :type can_get_statistics: :class:`Bool`
    :param can_get_interactions: True, if interactions with the story can be received through getStoryInteractions
    :type can_get_interactions: :class:`Bool`
    :param has_expired_viewers: True, if users viewed the story can't be received, because the story has expired more than getOption("story_viewers_expiration_delay") seconds ago
    :type has_expired_viewers: :class:`Bool`
    """

    ID: typing.Literal["story"] = field(default="story", metadata={"alias": "@type"})
    id: Int32
    sender_chat_id: Int53
    date: Int32
    privacy_settings: StoryPrivacySettings
    content: StoryContent
    areas: Vector[StoryArea]
    caption: FormattedText
    sender_id: typing.Optional[MessageSender] = field(default=None)
    repost_info: typing.Optional[StoryRepostInfo] = field(default=None)
    interaction_info: typing.Optional[StoryInteractionInfo] = field(default=None)
    chosen_reaction_type: typing.Optional[ReactionType] = field(default=None)
    is_being_sent: Bool = field(default=False)
    is_being_edited: Bool = field(default=False)
    is_edited: Bool = field(default=False)
    is_posted_to_chat_page: Bool = field(default=False)
    is_visible_only_for_self: Bool = field(default=False)
    can_be_deleted: Bool = field(default=False)
    can_be_edited: Bool = field(default=False)
    can_be_forwarded: Bool = field(default=False)
    can_be_replied: Bool = field(default=False)
    can_toggle_is_posted_to_chat_page: Bool = field(default=False)
    can_get_statistics: Bool = field(default=False)
    can_get_interactions: Bool = field(default=False)
    has_expired_viewers: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class StoryArea(BaseObject):
    """
    Describes a clickable rectangle area on a story media

    :param position: Position of the area
    :type position: :class:`StoryAreaPosition`
    :param type_: Type of the area
    :type type_: :class:`StoryAreaType`
    """

    ID: typing.Literal["storyArea"] = field(default="storyArea", metadata={"alias": "@type"})
    position: StoryAreaPosition
    type_: StoryAreaType = field(default=MISSING, metadata={"alias": "type"})


@dataclass(slots=True, kw_only=True)
class StoryAreaPosition(BaseObject):
    """
    Describes position of a clickable rectangle area on a story media

    :param x_percentage: The abscissa of the rectangle's center, as a percentage of the media width
    :type x_percentage: :class:`Double`
    :param y_percentage: The ordinate of the rectangle's center, as a percentage of the media height
    :type y_percentage: :class:`Double`
    :param width_percentage: The width of the rectangle, as a percentage of the media width
    :type width_percentage: :class:`Double`
    :param height_percentage: The height of the rectangle, as a percentage of the media height
    :type height_percentage: :class:`Double`
    :param rotation_angle: Clockwise rotation angle of the rectangle, in degrees; 0-360
    :type rotation_angle: :class:`Double`
    :param corner_radius_percentage: The radius of the rectangle corner rounding, as a percentage of the media width
    :type corner_radius_percentage: :class:`Double`
    """

    ID: typing.Literal["storyAreaPosition"] = field(default="storyAreaPosition", metadata={"alias": "@type"})
    x_percentage: Double
    y_percentage: Double
    width_percentage: Double
    height_percentage: Double
    rotation_angle: Double
    corner_radius_percentage: Double


@dataclass(slots=True, kw_only=True)
class StoryAreaTypeLink(BaseObject):
    """
    An area pointing to a HTTP or tg:// link

    :param url: HTTP or tg:// URL to be opened when the area is clicked
    :type url: :class:`String`
    """

    ID: typing.Literal["storyAreaTypeLink"] = field(default="storyAreaTypeLink", metadata={"alias": "@type"})
    url: String


@dataclass(slots=True, kw_only=True)
class StoryAreaTypeLocation(BaseObject):
    """
    An area pointing to a location

    :param location: The location
    :type location: :class:`Location`
    :param address: Address of the location; may be null if unknown, defaults to None
    :type address: :class:`LocationAddress`, optional
    """

    ID: typing.Literal["storyAreaTypeLocation"] = field(default="storyAreaTypeLocation", metadata={"alias": "@type"})
    location: Location
    address: typing.Optional[LocationAddress] = field(default=None)


@dataclass(slots=True, kw_only=True)
class StoryAreaTypeMessage(BaseObject):
    """
    An area pointing to a message

    :param chat_id: Identifier of the chat with the message
    :type chat_id: :class:`Int53`
    :param message_id: Identifier of the message
    :type message_id: :class:`Int53`
    """

    ID: typing.Literal["storyAreaTypeMessage"] = field(default="storyAreaTypeMessage", metadata={"alias": "@type"})
    chat_id: Int53
    message_id: Int53


@dataclass(slots=True, kw_only=True)
class StoryAreaTypeSuggestedReaction(BaseObject):
    """
    An area pointing to a suggested reaction. App needs to show a clickable reaction on the area and call setStoryReaction when the are is clicked

    :param reaction_type: Type of the reaction
    :type reaction_type: :class:`ReactionType`
    :param total_count: Number of times the reaction was added
    :type total_count: :class:`Int32`
    :param is_dark: True, if reaction has a dark background
    :type is_dark: :class:`Bool`
    :param is_flipped: True, if reaction corner is flipped
    :type is_flipped: :class:`Bool`
    """

    ID: typing.Literal["storyAreaTypeSuggestedReaction"] = field(
        default="storyAreaTypeSuggestedReaction", metadata={"alias": "@type"}
    )
    reaction_type: ReactionType
    total_count: Int32
    is_dark: Bool = field(default=False)
    is_flipped: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class StoryAreaTypeUpgradedGift(BaseObject):
    """
    An area with an upgraded gift

    :param gift_name: Unique name of the upgraded gift
    :type gift_name: :class:`String`
    """

    ID: typing.Literal["storyAreaTypeUpgradedGift"] = field(
        default="storyAreaTypeUpgradedGift", metadata={"alias": "@type"}
    )
    gift_name: String


@dataclass(slots=True, kw_only=True)
class StoryAreaTypeVenue(BaseObject):
    """
    An area pointing to a venue

    :param venue: Information about the venue
    :type venue: :class:`Venue`
    """

    ID: typing.Literal["storyAreaTypeVenue"] = field(default="storyAreaTypeVenue", metadata={"alias": "@type"})
    venue: Venue


@dataclass(slots=True, kw_only=True)
class StoryAreaTypeWeather(BaseObject):
    """
    An area with information about weather

    :param temperature: Temperature, in degree Celsius
    :type temperature: :class:`Double`
    :param emoji: Emoji representing the weather
    :type emoji: :class:`String`
    :param background_color: A color of the area background in the ARGB format
    :type background_color: :class:`Int32`
    """

    ID: typing.Literal["storyAreaTypeWeather"] = field(default="storyAreaTypeWeather", metadata={"alias": "@type"})
    temperature: Double
    emoji: String
    background_color: Int32


StoryAreaType = typing.Union[
    StoryAreaTypeLink,
    StoryAreaTypeLocation,
    StoryAreaTypeMessage,
    StoryAreaTypeSuggestedReaction,
    StoryAreaTypeUpgradedGift,
    StoryAreaTypeVenue,
    StoryAreaTypeWeather,
]


@dataclass(slots=True, kw_only=True)
class StoryContentPhoto(BaseObject):
    """
    A photo story

    :param photo: The photo
    :type photo: :class:`Photo`
    """

    ID: typing.Literal["storyContentPhoto"] = field(default="storyContentPhoto", metadata={"alias": "@type"})
    photo: Photo


@dataclass(slots=True, kw_only=True)
class StoryContentUnsupported(BaseObject):
    """
    A story content that is not supported in the current TDLib version
    """

    ID: typing.Literal["storyContentUnsupported"] = field(
        default="storyContentUnsupported", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class StoryContentVideo(BaseObject):
    """
    A video story

    :param video: The video in MPEG4 format
    :type video: :class:`StoryVideo`
    :param alternative_video: Alternative version of the video in MPEG4 format, encoded with H.264 codec; may be null, defaults to None
    :type alternative_video: :class:`StoryVideo`, optional
    """

    ID: typing.Literal["storyContentVideo"] = field(default="storyContentVideo", metadata={"alias": "@type"})
    video: StoryVideo
    alternative_video: typing.Optional[StoryVideo] = field(default=None)


StoryContent = typing.Union[
    StoryContentPhoto,
    StoryContentUnsupported,
    StoryContentVideo,
]


@dataclass(slots=True, kw_only=True)
class StoryFullId(BaseObject):
    """
    Contains identifier of a story along with identifier of its sender

    :param sender_chat_id: Identifier of the chat that posted the story
    :type sender_chat_id: :class:`Int53`
    :param story_id: Unique story identifier among stories of the given sender
    :type story_id: :class:`Int32`
    """

    ID: typing.Literal["storyFullId"] = field(default="storyFullId", metadata={"alias": "@type"})
    sender_chat_id: Int53
    story_id: Int32


@dataclass(slots=True, kw_only=True)
class StoryInfo(BaseObject):
    """
    Contains basic information about a story

    :param story_id: Unique story identifier among stories of the given sender
    :type story_id: :class:`Int32`
    :param date: Point in time (Unix timestamp) when the story was published
    :type date: :class:`Int32`
    :param is_for_close_friends: True, if the story is available only to close friends
    :type is_for_close_friends: :class:`Bool`
    """

    ID: typing.Literal["storyInfo"] = field(default="storyInfo", metadata={"alias": "@type"})
    story_id: Int32
    date: Int32
    is_for_close_friends: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class StoryInteraction(BaseObject):
    """
    Represents interaction with a story

    :param actor_id: Identifier of the user or chat that made the interaction
    :type actor_id: :class:`MessageSender`
    :param interaction_date: Approximate point in time (Unix timestamp) when the interaction happened
    :type interaction_date: :class:`Int32`
    :param type_: Type of the interaction
    :type type_: :class:`StoryInteractionType`
    :param block_list: Block list to which the actor is added; may be null if none or for chat stories, defaults to None
    :type block_list: :class:`BlockList`, optional
    """

    ID: typing.Literal["storyInteraction"] = field(default="storyInteraction", metadata={"alias": "@type"})
    actor_id: MessageSender
    interaction_date: Int32
    type_: StoryInteractionType = field(default=MISSING, metadata={"alias": "type"})
    block_list: typing.Optional[BlockList] = field(default=None)


@dataclass(slots=True, kw_only=True)
class StoryInteractionInfo(BaseObject):
    """
    Contains information about interactions with a story

    :param view_count: Number of times the story was viewed
    :type view_count: :class:`Int32`
    :param recent_viewer_user_ids: Identifiers of at most 3 recent viewers of the story
    :type recent_viewer_user_ids: :class:`Vector[Int53]`
    :param forward_count: Number of times the story was forwarded; 0 if none or unknown, defaults to None
    :type forward_count: :class:`Int32`, optional
    :param reaction_count: Number of reactions added to the story; 0 if none or unknown, defaults to None
    :type reaction_count: :class:`Int32`, optional
    """

    ID: typing.Literal["storyInteractionInfo"] = field(default="storyInteractionInfo", metadata={"alias": "@type"})
    view_count: Int32
    recent_viewer_user_ids: Vector[Int53]
    forward_count: typing.Optional[Int32] = field(default=0)
    reaction_count: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class StoryInteractionTypeForward(BaseObject):
    """
    A forward of the story as a message

    :param message: The message with story forward
    :type message: :class:`Message`
    """

    ID: typing.Literal["storyInteractionTypeForward"] = field(
        default="storyInteractionTypeForward", metadata={"alias": "@type"}
    )
    message: Message


@dataclass(slots=True, kw_only=True)
class StoryInteractionTypeRepost(BaseObject):
    """
    A repost of the story as a story

    :param story: The reposted story
    :type story: :class:`Story`
    """

    ID: typing.Literal["storyInteractionTypeRepost"] = field(
        default="storyInteractionTypeRepost", metadata={"alias": "@type"}
    )
    story: Story


@dataclass(slots=True, kw_only=True)
class StoryInteractionTypeView(BaseObject):
    """
    A view of the story

    :param chosen_reaction_type: Type of the reaction that was chosen by the viewer; may be null if none, defaults to None
    :type chosen_reaction_type: :class:`ReactionType`, optional
    """

    ID: typing.Literal["storyInteractionTypeView"] = field(
        default="storyInteractionTypeView", metadata={"alias": "@type"}
    )
    chosen_reaction_type: typing.Optional[ReactionType] = field(default=None)


StoryInteractionType = typing.Union[
    StoryInteractionTypeForward,
    StoryInteractionTypeRepost,
    StoryInteractionTypeView,
]


@dataclass(slots=True, kw_only=True)
class StoryInteractions(BaseObject):
    """
    Represents a list of interactions with a story

    :param total_count: Approximate total number of interactions found
    :type total_count: :class:`Int32`
    :param interactions: List of story interactions
    :type interactions: :class:`Vector[StoryInteraction]`
    :param total_forward_count: Approximate total number of found forwards and reposts; always 0 for chat stories
    :type total_forward_count: :class:`Int32`
    :param total_reaction_count: Approximate total number of found reactions; always 0 for chat stories
    :type total_reaction_count: :class:`Int32`
    :param next_offset: The offset for the next request. If empty, then there are no more results
    :type next_offset: :class:`String`
    """

    ID: typing.Literal["storyInteractions"] = field(default="storyInteractions", metadata={"alias": "@type"})
    total_count: Int32
    interactions: Vector[StoryInteraction]
    total_forward_count: Int32 = field(default=0)
    total_reaction_count: Int32 = field(default=0)
    next_offset: String = field(default="")


@dataclass(slots=True, kw_only=True)
class StoryListArchive(BaseObject):
    """
    The list of stories, shown in the Arvhive chat list
    """

    ID: typing.Literal["storyListArchive"] = field(default="storyListArchive", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class StoryListMain(BaseObject):
    """
    The list of stories, shown in the main chat list and folder chat lists
    """

    ID: typing.Literal["storyListMain"] = field(default="storyListMain", metadata={"alias": "@type"})


StoryList = typing.Union[
    StoryListArchive,
    StoryListMain,
]


@dataclass(slots=True, kw_only=True)
class StoryOriginHiddenUser(BaseObject):
    """
    The original story was sent by an unknown user

    :param sender_name: Name of the story sender
    :type sender_name: :class:`String`
    """

    ID: typing.Literal["storyOriginHiddenUser"] = field(default="storyOriginHiddenUser", metadata={"alias": "@type"})
    sender_name: String


@dataclass(slots=True, kw_only=True)
class StoryOriginPublicStory(BaseObject):
    """
    The original story was a public story with known sender

    :param chat_id: Identifier of the chat that posted original story
    :type chat_id: :class:`Int53`
    :param story_id: Story identifier of the original story
    :type story_id: :class:`Int32`
    """

    ID: typing.Literal["storyOriginPublicStory"] = field(default="storyOriginPublicStory", metadata={"alias": "@type"})
    chat_id: Int53
    story_id: Int32


StoryOrigin = typing.Union[
    StoryOriginHiddenUser,
    StoryOriginPublicStory,
]


@dataclass(slots=True, kw_only=True)
class StoryPrivacySettingsCloseFriends(BaseObject):
    """
    The story can be viewed by all close friends
    """

    ID: typing.Literal["storyPrivacySettingsCloseFriends"] = field(
        default="storyPrivacySettingsCloseFriends", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class StoryPrivacySettingsContacts(BaseObject):
    """
    The story can be viewed by all contacts except chosen users

    :param except_user_ids: User identifiers of the contacts that can't see the story; always unknown and empty for non-owned stories
    :type except_user_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["storyPrivacySettingsContacts"] = field(
        default="storyPrivacySettingsContacts", metadata={"alias": "@type"}
    )
    except_user_ids: Vector[Int53]


@dataclass(slots=True, kw_only=True)
class StoryPrivacySettingsEveryone(BaseObject):
    """
    The story can be viewed by everyone

    :param except_user_ids: Identifiers of the users that can't see the story; always unknown and empty for non-owned stories
    :type except_user_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["storyPrivacySettingsEveryone"] = field(
        default="storyPrivacySettingsEveryone", metadata={"alias": "@type"}
    )
    except_user_ids: Vector[Int53]


@dataclass(slots=True, kw_only=True)
class StoryPrivacySettingsSelectedUsers(BaseObject):
    """
    The story can be viewed by certain specified users

    :param user_ids: Identifiers of the users; always unknown and empty for non-owned stories
    :type user_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["storyPrivacySettingsSelectedUsers"] = field(
        default="storyPrivacySettingsSelectedUsers", metadata={"alias": "@type"}
    )
    user_ids: Vector[Int53]


StoryPrivacySettings = typing.Union[
    StoryPrivacySettingsCloseFriends,
    StoryPrivacySettingsContacts,
    StoryPrivacySettingsEveryone,
    StoryPrivacySettingsSelectedUsers,
]


@dataclass(slots=True, kw_only=True)
class StoryRepostInfo(BaseObject):
    """
    Contains information about original story that was reposted

    :param origin: Origin of the story that was reposted
    :type origin: :class:`StoryOrigin`
    :param is_content_modified: True, if story content was modified during reposting; otherwise, story wasn't modified
    :type is_content_modified: :class:`Bool`
    """

    ID: typing.Literal["storyRepostInfo"] = field(default="storyRepostInfo", metadata={"alias": "@type"})
    origin: StoryOrigin
    is_content_modified: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class StoryStatistics(BaseObject):
    """
    A detailed statistics about a story

    :param story_interaction_graph: A graph containing number of story views and shares
    :type story_interaction_graph: :class:`StatisticalGraph`
    :param story_reaction_graph: A graph containing number of story reactions
    :type story_reaction_graph: :class:`StatisticalGraph`
    """

    ID: typing.Literal["storyStatistics"] = field(default="storyStatistics", metadata={"alias": "@type"})
    story_interaction_graph: StatisticalGraph
    story_reaction_graph: StatisticalGraph


@dataclass(slots=True, kw_only=True)
class StoryVideo(BaseObject):
    """
    Describes a video file sent in a story

    :param duration: Duration of the video, in seconds
    :type duration: :class:`Double`
    :param width: Video width
    :type width: :class:`Int32`
    :param height: Video height
    :type height: :class:`Int32`
    :param preload_prefix_size: Size of file prefix, which is expected to be preloaded, in bytes
    :type preload_prefix_size: :class:`Int32`
    :param cover_frame_timestamp: Timestamp of the frame used as video thumbnail
    :type cover_frame_timestamp: :class:`Double`
    :param video: File containing the video
    :type video: :class:`File`
    :param minithumbnail: Video minithumbnail; may be null, defaults to None
    :type minithumbnail: :class:`Minithumbnail`, optional
    :param thumbnail: Video thumbnail in JPEG or MPEG4 format; may be null, defaults to None
    :type thumbnail: :class:`Thumbnail`, optional
    :param has_stickers: True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
    :type has_stickers: :class:`Bool`
    :param is_animation: True, if the video has no sound
    :type is_animation: :class:`Bool`
    """

    ID: typing.Literal["storyVideo"] = field(default="storyVideo", metadata={"alias": "@type"})
    duration: Double
    width: Int32
    height: Int32
    preload_prefix_size: Int32
    cover_frame_timestamp: Double
    video: File
    minithumbnail: typing.Optional[Minithumbnail] = field(default=None)
    thumbnail: typing.Optional[Thumbnail] = field(default=None)
    has_stickers: Bool = field(default=False)
    is_animation: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class SuggestedActionCheckPassword(BaseObject):
    """
    Suggests the user to check whether they still remember their 2-step verification password
    """

    ID: typing.Literal["suggestedActionCheckPassword"] = field(
        default="suggestedActionCheckPassword", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SuggestedActionCheckPhoneNumber(BaseObject):
    """
    Suggests the user to check whether authorization phone number is correct and change the phone number if it is inaccessible
    """

    ID: typing.Literal["suggestedActionCheckPhoneNumber"] = field(
        default="suggestedActionCheckPhoneNumber", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SuggestedActionConvertToBroadcastGroup(BaseObject):
    """
    Suggests the user to convert specified supergroup to a broadcast group

    :param supergroup_id: Supergroup identifier
    :type supergroup_id: :class:`Int53`
    """

    ID: typing.Literal["suggestedActionConvertToBroadcastGroup"] = field(
        default="suggestedActionConvertToBroadcastGroup", metadata={"alias": "@type"}
    )
    supergroup_id: Int53


@dataclass(slots=True, kw_only=True)
class SuggestedActionEnableArchiveAndMuteNewChats(BaseObject):
    """
    Suggests the user to enable archive_and_mute_new_chats_from_unknown_users setting in archiveChatListSettings
    """

    ID: typing.Literal["suggestedActionEnableArchiveAndMuteNewChats"] = field(
        default="suggestedActionEnableArchiveAndMuteNewChats", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SuggestedActionExtendPremium(BaseObject):
    """
    Suggests the user to extend their expiring Telegram Premium subscription

    :param manage_premium_subscription_url: A URL for managing Telegram Premium subscription
    :type manage_premium_subscription_url: :class:`String`
    """

    ID: typing.Literal["suggestedActionExtendPremium"] = field(
        default="suggestedActionExtendPremium", metadata={"alias": "@type"}
    )
    manage_premium_subscription_url: String


@dataclass(slots=True, kw_only=True)
class SuggestedActionExtendStarSubscriptions(BaseObject):
    """
    Suggests the user to extend their expiring Telegram Star subscriptions. Call getStarSubscriptions with only_expiring == true to get the number of expiring subscriptions and the number of required to buy Telegram Stars
    """

    ID: typing.Literal["suggestedActionExtendStarSubscriptions"] = field(
        default="suggestedActionExtendStarSubscriptions", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SuggestedActionGiftPremiumForChristmas(BaseObject):
    """
    Suggests the user to gift Telegram Premium to friends for Christmas
    """

    ID: typing.Literal["suggestedActionGiftPremiumForChristmas"] = field(
        default="suggestedActionGiftPremiumForChristmas", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SuggestedActionRestorePremium(BaseObject):
    """
    Suggests the user to restore a recently expired Premium subscription
    """

    ID: typing.Literal["suggestedActionRestorePremium"] = field(
        default="suggestedActionRestorePremium", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SuggestedActionSetBirthdate(BaseObject):
    """
    Suggests the user to set birthdate
    """

    ID: typing.Literal["suggestedActionSetBirthdate"] = field(
        default="suggestedActionSetBirthdate", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SuggestedActionSetPassword(BaseObject):
    """
    Suggests the user to set a 2-step verification password to be able to log in again

    :param authorization_delay: The number of days to pass between consecutive authorizations if the user declines to set password; if 0, then the user is advised to set the password for security reasons
    :type authorization_delay: :class:`Int32`
    """

    ID: typing.Literal["suggestedActionSetPassword"] = field(
        default="suggestedActionSetPassword", metadata={"alias": "@type"}
    )
    authorization_delay: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class SuggestedActionSetProfilePhoto(BaseObject):
    """
    Suggests the user to set profile photo
    """

    ID: typing.Literal["suggestedActionSetProfilePhoto"] = field(
        default="suggestedActionSetProfilePhoto", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SuggestedActionSubscribeToAnnualPremium(BaseObject):
    """
    Suggests the user to subscribe to the Premium subscription with annual payments
    """

    ID: typing.Literal["suggestedActionSubscribeToAnnualPremium"] = field(
        default="suggestedActionSubscribeToAnnualPremium", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SuggestedActionUpgradePremium(BaseObject):
    """
    Suggests the user to upgrade the Premium subscription from monthly payments to annual payments
    """

    ID: typing.Literal["suggestedActionUpgradePremium"] = field(
        default="suggestedActionUpgradePremium", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SuggestedActionViewChecksHint(BaseObject):
    """
    Suggests the user to view a hint about the meaning of one and two check marks on sent messages
    """

    ID: typing.Literal["suggestedActionViewChecksHint"] = field(
        default="suggestedActionViewChecksHint", metadata={"alias": "@type"}
    )


SuggestedAction = typing.Union[
    SuggestedActionCheckPassword,
    SuggestedActionCheckPhoneNumber,
    SuggestedActionConvertToBroadcastGroup,
    SuggestedActionEnableArchiveAndMuteNewChats,
    SuggestedActionExtendPremium,
    SuggestedActionExtendStarSubscriptions,
    SuggestedActionGiftPremiumForChristmas,
    SuggestedActionRestorePremium,
    SuggestedActionSetBirthdate,
    SuggestedActionSetPassword,
    SuggestedActionSetProfilePhoto,
    SuggestedActionSubscribeToAnnualPremium,
    SuggestedActionUpgradePremium,
    SuggestedActionViewChecksHint,
]


@dataclass(slots=True, kw_only=True)
class Supergroup(BaseObject):
    """
    Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup: only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos. Unlike supergroups, channels can have an unlimited number of subscribers

    :param id: Supergroup or channel identifier
    :type id: :class:`Int53`
    :param date: Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member
    :type date: :class:`Int32`
    :param status: Status of the current user in the supergroup or channel; custom title will always be empty
    :type status: :class:`ChatMemberStatus`
    :param boost_level: Approximate boost level for the chat
    :type boost_level: :class:`Int32`
    :param usernames: Usernames of the supergroup or channel; may be null, defaults to None
    :type usernames: :class:`Usernames`, optional
    :param verification_status: Information about verification status of the supergroup or channel; may be null if none, defaults to None
    :type verification_status: :class:`VerificationStatus`, optional
    :param has_linked_chat: True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel
    :type has_linked_chat: :class:`Bool`
    :param has_location: True, if the supergroup is connected to a location, i.e. the supergroup is a location-based supergroup
    :type has_location: :class:`Bool`
    :param sign_messages: True, if messages sent to the channel contains name of the sender. This field is only applicable to channels
    :type sign_messages: :class:`Bool`
    :param show_message_sender: True, if messages sent to the channel have information about the sender user. This field is only applicable to channels
    :type show_message_sender: :class:`Bool`
    :param join_to_send_messages: True, if users need to join the supergroup before they can send messages. Always true for channels and non-discussion supergroups
    :type join_to_send_messages: :class:`Bool`
    :param join_by_request: True, if all users directly joining the supergroup need to be approved by supergroup administrators. Always false for channels and supergroups without username, location, or a linked chat
    :type join_by_request: :class:`Bool`
    :param is_slow_mode_enabled: True, if the slow mode is enabled in the supergroup
    :type is_slow_mode_enabled: :class:`Bool`
    :param is_channel: True, if the supergroup is a channel
    :type is_channel: :class:`Bool`
    :param is_broadcast_group: True, if the supergroup is a broadcast group, i.e. only administrators can send messages and there is no limit on the number of members
    :type is_broadcast_group: :class:`Bool`
    :param is_forum: True, if the supergroup is a forum with topics
    :type is_forum: :class:`Bool`
    :param has_sensitive_content: True, if content of media messages in the supergroup or channel chat must be hidden with 18+ spoiler
    :type has_sensitive_content: :class:`Bool`
    :param restriction_reason: If non-empty, contains a human-readable description of the reason why access to this supergroup or channel must be restricted
    :type restriction_reason: :class:`String`
    :param has_active_stories: True, if the supergroup or channel has non-expired stories available to the current user
    :type has_active_stories: :class:`Bool`
    :param has_unread_active_stories: True, if the supergroup or channel has unread non-expired stories available to the current user
    :type has_unread_active_stories: :class:`Bool`
    :param member_count: Number of members in the supergroup or channel; 0 if unknown. Currently, it is guaranteed to be known only if the supergroup or channel was received through getChatSimilarChats, getChatsToSendStories, getCreatedPublicChats, getGroupsInCommon, getInactiveSupergroupChats, getRecommendedChats, getSuitableDiscussionChats, getUserPrivacySettingRules, getVideoChatAvailableParticipants, searchPublicChats, or in chatFolderInviteLinkInfo.missing_chat_ids, or in userFullInfo.personal_chat_id, or for chats with messages or stories from publicForwards and foundStories, defaults to None
    :type member_count: :class:`Int32`, optional
    """

    ID: typing.Literal["supergroup"] = field(default="supergroup", metadata={"alias": "@type"})
    id: Int53
    date: Int32
    status: ChatMemberStatus
    boost_level: Int32
    usernames: typing.Optional[Usernames] = field(default=None)
    verification_status: typing.Optional[VerificationStatus] = field(default=None)
    has_linked_chat: Bool = field(default=False)
    has_location: Bool = field(default=False)
    sign_messages: Bool = field(default=False)
    show_message_sender: Bool = field(default=False)
    join_to_send_messages: Bool = field(default=False)
    join_by_request: Bool = field(default=False)
    is_slow_mode_enabled: Bool = field(default=False)
    is_channel: Bool = field(default=False)
    is_broadcast_group: Bool = field(default=False)
    is_forum: Bool = field(default=False)
    has_sensitive_content: Bool = field(default=False)
    restriction_reason: String = field(default="")
    has_active_stories: Bool = field(default=False)
    has_unread_active_stories: Bool = field(default=False)
    member_count: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class SupergroupFullInfo(BaseObject):
    """
    Contains full information about a supergroup or channel

    :param description: Supergroup or channel description
    :type description: :class:`String`
    :param slow_mode_delay: Delay between consecutive sent messages for non-administrator supergroup members, in seconds
    :type slow_mode_delay: :class:`Int32`
    :param slow_mode_delay_expires_in: Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non-zero
    :type slow_mode_delay_expires_in: :class:`Double`
    :param gift_count: Number of saved to profile gifts for channels without can_post_messages administrator right, otherwise, the total number of received gifts
    :type gift_count: :class:`Int32`
    :param my_boost_count: Number of times the current user boosted the supergroup or channel
    :type my_boost_count: :class:`Int32`
    :param bot_commands: List of commands of bots in the group
    :type bot_commands: :class:`Vector[BotCommands]`
    :param photo: Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo, defaults to None
    :type photo: :class:`ChatPhoto`, optional
    :param location: Location to which the supergroup is connected; may be null if none, defaults to None
    :type location: :class:`ChatLocation`, optional
    :param invite_link: Primary invite link for the chat; may be null. For chat administrators with can_invite_users right only, defaults to None
    :type invite_link: :class:`ChatInviteLink`, optional
    :param bot_verification: Information about verification status of the supergroup or the channel provided by a bot; may be null if none or unknown, defaults to None
    :type bot_verification: :class:`BotVerification`, optional
    :param can_enable_paid_reaction: True, if paid reaction can be enabled in the channel chat; for channels only
    :type can_enable_paid_reaction: :class:`Bool`
    :param can_get_members: True, if members of the chat can be retrieved via getSupergroupMembers or searchChatMembers
    :type can_get_members: :class:`Bool`
    :param has_hidden_members: True, if non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers
    :type has_hidden_members: :class:`Bool`
    :param can_hide_members: True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators
    :type can_hide_members: :class:`Bool`
    :param can_set_sticker_set: True, if the supergroup sticker set can be changed
    :type can_set_sticker_set: :class:`Bool`
    :param can_set_location: True, if the supergroup location can be changed
    :type can_set_location: :class:`Bool`
    :param can_get_statistics: True, if the supergroup or channel statistics are available
    :type can_get_statistics: :class:`Bool`
    :param can_get_revenue_statistics: True, if the supergroup or channel revenue statistics are available
    :type can_get_revenue_statistics: :class:`Bool`
    :param can_get_star_revenue_statistics: True, if the supergroup or channel Telegram Star revenue statistics are available
    :type can_get_star_revenue_statistics: :class:`Bool`
    :param can_send_gift: True, if the user can send a gift to the supergroup or channel using sendGift or transferGift
    :type can_send_gift: :class:`Bool`
    :param can_toggle_aggressive_anti_spam: True, if aggressive anti-spam checks can be enabled or disabled in the supergroup
    :type can_toggle_aggressive_anti_spam: :class:`Bool`
    :param is_all_history_available: True, if new chat members will have access to old messages. In public, discussion, of forum groups and all channels, old messages are always available, so this option affects only private non-forum supergroups without a linked chat. The value of this field is only available to chat administrators
    :type is_all_history_available: :class:`Bool`
    :param can_have_sponsored_messages: True, if the chat can have sponsored messages. The value of this field is only available to the owner of the chat
    :type can_have_sponsored_messages: :class:`Bool`
    :param has_aggressive_anti_spam_enabled: True, if aggressive anti-spam checks are enabled in the supergroup. The value of this field is only available to chat administrators
    :type has_aggressive_anti_spam_enabled: :class:`Bool`
    :param has_paid_media_allowed: True, if paid media can be sent and forwarded to the channel chat; for channels only
    :type has_paid_media_allowed: :class:`Bool`
    :param has_pinned_stories: True, if the supergroup or channel has pinned stories
    :type has_pinned_stories: :class:`Bool`
    :param unrestrict_boost_count: Number of times the supergroup must be boosted by a user to ignore slow mode and chat permission restrictions; 0 if unspecified
    :type unrestrict_boost_count: :class:`Int32`
    :param member_count: Number of members in the supergroup or channel; 0 if unknown, defaults to None
    :type member_count: :class:`Int32`, optional
    :param administrator_count: Number of privileged users in the supergroup or channel; 0 if unknown, defaults to None
    :type administrator_count: :class:`Int32`, optional
    :param restricted_count: Number of restricted users in the supergroup; 0 if unknown, defaults to None
    :type restricted_count: :class:`Int32`, optional
    :param banned_count: Number of users banned from chat; 0 if unknown, defaults to None
    :type banned_count: :class:`Int32`, optional
    :param linked_chat_id: Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown, defaults to None
    :type linked_chat_id: :class:`Int53`, optional
    :param sticker_set_id: Identifier of the supergroup sticker set that must be shown before user sticker sets; 0 if none, defaults to None
    :type sticker_set_id: :class:`Int64`, optional
    :param custom_emoji_sticker_set_id: Identifier of the custom emoji sticker set that can be used in the supergroup without Telegram Premium subscription; 0 if none, defaults to None
    :type custom_emoji_sticker_set_id: :class:`Int64`, optional
    :param upgraded_from_basic_group_id: Identifier of the basic group from which supergroup was upgraded; 0 if none, defaults to None
    :type upgraded_from_basic_group_id: :class:`Int53`, optional
    :param upgraded_from_max_message_id: Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none, defaults to None
    :type upgraded_from_max_message_id: :class:`Int53`, optional
    """

    ID: typing.Literal["supergroupFullInfo"] = field(default="supergroupFullInfo", metadata={"alias": "@type"})
    description: String
    slow_mode_delay: Int32
    slow_mode_delay_expires_in: Double
    gift_count: Int32
    my_boost_count: Int32
    bot_commands: Vector[BotCommands]
    photo: typing.Optional[ChatPhoto] = field(default=None)
    location: typing.Optional[ChatLocation] = field(default=None)
    invite_link: typing.Optional[ChatInviteLink] = field(default=None)
    bot_verification: typing.Optional[BotVerification] = field(default=None)
    can_enable_paid_reaction: Bool = field(default=False)
    can_get_members: Bool = field(default=False)
    has_hidden_members: Bool = field(default=False)
    can_hide_members: Bool = field(default=False)
    can_set_sticker_set: Bool = field(default=False)
    can_set_location: Bool = field(default=False)
    can_get_statistics: Bool = field(default=False)
    can_get_revenue_statistics: Bool = field(default=False)
    can_get_star_revenue_statistics: Bool = field(default=False)
    can_send_gift: Bool = field(default=False)
    can_toggle_aggressive_anti_spam: Bool = field(default=False)
    is_all_history_available: Bool = field(default=False)
    can_have_sponsored_messages: Bool = field(default=False)
    has_aggressive_anti_spam_enabled: Bool = field(default=False)
    has_paid_media_allowed: Bool = field(default=False)
    has_pinned_stories: Bool = field(default=False)
    unrestrict_boost_count: Int32 = field(default=0)
    member_count: typing.Optional[Int32] = field(default=0)
    administrator_count: typing.Optional[Int32] = field(default=0)
    restricted_count: typing.Optional[Int32] = field(default=0)
    banned_count: typing.Optional[Int32] = field(default=0)
    linked_chat_id: typing.Optional[Int53] = field(default=0)
    sticker_set_id: typing.Optional[Int64] = field(default=0)
    custom_emoji_sticker_set_id: typing.Optional[Int64] = field(default=0)
    upgraded_from_basic_group_id: typing.Optional[Int53] = field(default=0)
    upgraded_from_max_message_id: typing.Optional[Int53] = field(default=0)


@dataclass(slots=True, kw_only=True)
class SupergroupMembersFilterAdministrators(BaseObject):
    """
    Returns the owner and administrators
    """

    ID: typing.Literal["supergroupMembersFilterAdministrators"] = field(
        default="supergroupMembersFilterAdministrators", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SupergroupMembersFilterBanned(BaseObject):
    """
    Returns users banned from the supergroup or channel; can be used only by administrators

    :param query: Query to search for
    :type query: :class:`String`
    """

    ID: typing.Literal["supergroupMembersFilterBanned"] = field(
        default="supergroupMembersFilterBanned", metadata={"alias": "@type"}
    )
    query: String


@dataclass(slots=True, kw_only=True)
class SupergroupMembersFilterBots(BaseObject):
    """
    Returns bot members of the supergroup or channel
    """

    ID: typing.Literal["supergroupMembersFilterBots"] = field(
        default="supergroupMembersFilterBots", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SupergroupMembersFilterContacts(BaseObject):
    """
    Returns contacts of the user, which are members of the supergroup or channel

    :param query: Query to search for
    :type query: :class:`String`
    """

    ID: typing.Literal["supergroupMembersFilterContacts"] = field(
        default="supergroupMembersFilterContacts", metadata={"alias": "@type"}
    )
    query: String


@dataclass(slots=True, kw_only=True)
class SupergroupMembersFilterMention(BaseObject):
    """
    Returns users which can be mentioned in the supergroup

    :param query: Query to search for
    :type query: :class:`String`
    :param message_thread_id: If non-zero, the identifier of the current message thread
    :type message_thread_id: :class:`Int53`
    """

    ID: typing.Literal["supergroupMembersFilterMention"] = field(
        default="supergroupMembersFilterMention", metadata={"alias": "@type"}
    )
    query: String
    message_thread_id: Int53


@dataclass(slots=True, kw_only=True)
class SupergroupMembersFilterRecent(BaseObject):
    """
    Returns recently active users in reverse chronological order
    """

    ID: typing.Literal["supergroupMembersFilterRecent"] = field(
        default="supergroupMembersFilterRecent", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class SupergroupMembersFilterRestricted(BaseObject):
    """
    Returns restricted supergroup members; can be used only by administrators

    :param query: Query to search for
    :type query: :class:`String`
    """

    ID: typing.Literal["supergroupMembersFilterRestricted"] = field(
        default="supergroupMembersFilterRestricted", metadata={"alias": "@type"}
    )
    query: String


@dataclass(slots=True, kw_only=True)
class SupergroupMembersFilterSearch(BaseObject):
    """
    Used to search for supergroup or channel members via a (string) query

    :param query: Query to search for
    :type query: :class:`String`
    """

    ID: typing.Literal["supergroupMembersFilterSearch"] = field(
        default="supergroupMembersFilterSearch", metadata={"alias": "@type"}
    )
    query: String


SupergroupMembersFilter = typing.Union[
    SupergroupMembersFilterAdministrators,
    SupergroupMembersFilterBanned,
    SupergroupMembersFilterBots,
    SupergroupMembersFilterContacts,
    SupergroupMembersFilterMention,
    SupergroupMembersFilterRecent,
    SupergroupMembersFilterRestricted,
    SupergroupMembersFilterSearch,
]


@dataclass(slots=True, kw_only=True)
class TMeUrl(BaseObject):
    """
    Represents a URL linking to an internal Telegram entity

    :param url: URL
    :type url: :class:`String`
    :param type_: Type of the URL
    :type type_: :class:`TMeUrlType`
    """

    ID: typing.Literal["tMeUrl"] = field(default="tMeUrl", metadata={"alias": "@type"})
    url: String
    type_: TMeUrlType = field(default=MISSING, metadata={"alias": "type"})


@dataclass(slots=True, kw_only=True)
class TMeUrlTypeChatInvite(BaseObject):
    """
    A chat invite link

    :param info: Information about the chat invite link
    :type info: :class:`ChatInviteLinkInfo`
    """

    ID: typing.Literal["tMeUrlTypeChatInvite"] = field(default="tMeUrlTypeChatInvite", metadata={"alias": "@type"})
    info: ChatInviteLinkInfo


@dataclass(slots=True, kw_only=True)
class TMeUrlTypeStickerSet(BaseObject):
    """
    A URL linking to a sticker set

    :param sticker_set_id: Identifier of the sticker set
    :type sticker_set_id: :class:`Int64`
    """

    ID: typing.Literal["tMeUrlTypeStickerSet"] = field(default="tMeUrlTypeStickerSet", metadata={"alias": "@type"})
    sticker_set_id: Int64


@dataclass(slots=True, kw_only=True)
class TMeUrlTypeSupergroup(BaseObject):
    """
    A URL linking to a public supergroup or channel

    :param supergroup_id: Identifier of the supergroup or channel
    :type supergroup_id: :class:`Int53`
    """

    ID: typing.Literal["tMeUrlTypeSupergroup"] = field(default="tMeUrlTypeSupergroup", metadata={"alias": "@type"})
    supergroup_id: Int53


@dataclass(slots=True, kw_only=True)
class TMeUrlTypeUser(BaseObject):
    """
    A URL linking to a user

    :param user_id: Identifier of the user
    :type user_id: :class:`Int53`
    """

    ID: typing.Literal["tMeUrlTypeUser"] = field(default="tMeUrlTypeUser", metadata={"alias": "@type"})
    user_id: Int53


TMeUrlType = typing.Union[
    TMeUrlTypeChatInvite,
    TMeUrlTypeStickerSet,
    TMeUrlTypeSupergroup,
    TMeUrlTypeUser,
]


@dataclass(slots=True, kw_only=True)
class TMeUrls(BaseObject):
    """
    Contains a list of t.me URLs

    :param urls: List of URLs
    :type urls: :class:`Vector[TMeUrl]`
    """

    ID: typing.Literal["tMeUrls"] = field(default="tMeUrls", metadata={"alias": "@type"})
    urls: Vector[TMeUrl]


@dataclass(slots=True, kw_only=True)
class TargetChatChosen(BaseObject):
    """
    The chat needs to be chosen by the user among chats of the specified types

    :param types: Allowed types for the chat
    :type types: :class:`TargetChatTypes`
    """

    ID: typing.Literal["targetChatChosen"] = field(default="targetChatChosen", metadata={"alias": "@type"})
    types: TargetChatTypes


@dataclass(slots=True, kw_only=True)
class TargetChatCurrent(BaseObject):
    """
    The currently opened chat and forum topic must be kept
    """

    ID: typing.Literal["targetChatCurrent"] = field(default="targetChatCurrent", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class TargetChatInternalLink(BaseObject):
    """
    The chat needs to be open with the provided internal link

    :param link: An internal link pointing to the chat
    :type link: :class:`InternalLinkType`
    """

    ID: typing.Literal["targetChatInternalLink"] = field(default="targetChatInternalLink", metadata={"alias": "@type"})
    link: InternalLinkType


TargetChat = typing.Union[
    TargetChatChosen,
    TargetChatCurrent,
    TargetChatInternalLink,
]


@dataclass(slots=True, kw_only=True)
class TargetChatTypes(BaseObject):
    """
    Describes allowed types for the target chat

    :param allow_user_chats: True, if private chats with ordinary users are allowed
    :type allow_user_chats: :class:`Bool`
    :param allow_bot_chats: True, if private chats with other bots are allowed
    :type allow_bot_chats: :class:`Bool`
    :param allow_group_chats: True, if basic group and supergroup chats are allowed
    :type allow_group_chats: :class:`Bool`
    :param allow_channel_chats: True, if channel chats are allowed
    :type allow_channel_chats: :class:`Bool`
    """

    ID: typing.Literal["targetChatTypes"] = field(default="targetChatTypes", metadata={"alias": "@type"})
    allow_user_chats: Bool = field(default=False)
    allow_bot_chats: Bool = field(default=False)
    allow_group_chats: Bool = field(default=False)
    allow_channel_chats: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class TelegramPaymentPurposeGiftedStars(BaseObject):
    """
    The user buying Telegram Stars for other users

    :param user_id: Identifier of the user to which Telegram Stars are gifted
    :type user_id: :class:`Int53`
    :param currency: ISO 4217 currency code of the payment currency
    :type currency: :class:`String`
    :param amount: Paid amount, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param star_count: Number of bought Telegram Stars
    :type star_count: :class:`Int53`
    """

    ID: typing.Literal["telegramPaymentPurposeGiftedStars"] = field(
        default="telegramPaymentPurposeGiftedStars", metadata={"alias": "@type"}
    )
    user_id: Int53
    currency: String
    amount: Int53
    star_count: Int53


@dataclass(slots=True, kw_only=True)
class TelegramPaymentPurposeJoinChat(BaseObject):
    """
    The user joins a chat and subscribes to regular payments in Telegram Stars

    :param invite_link: Invite link to use
    :type invite_link: :class:`String`
    """

    ID: typing.Literal["telegramPaymentPurposeJoinChat"] = field(
        default="telegramPaymentPurposeJoinChat", metadata={"alias": "@type"}
    )
    invite_link: String


@dataclass(slots=True, kw_only=True)
class TelegramPaymentPurposePremiumGiftCodes(BaseObject):
    """
    The user creating Telegram Premium gift codes for other users

    :param currency: ISO 4217 currency code of the payment currency
    :type currency: :class:`String`
    :param amount: Paid amount, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param user_ids: Identifiers of the users which can activate the gift codes
    :type user_ids: :class:`Vector[Int53]`
    :param month_count: Number of months the Telegram Premium subscription will be active for the users
    :type month_count: :class:`Int32`
    :param text: Text to show along with the gift codes; 0-getOption("gift_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed
    :type text: :class:`FormattedText`
    :param boosted_chat_id: Identifier of the supergroup or channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user; 0 if none, defaults to None
    :type boosted_chat_id: :class:`Int53`, optional
    """

    ID: typing.Literal["telegramPaymentPurposePremiumGiftCodes"] = field(
        default="telegramPaymentPurposePremiumGiftCodes", metadata={"alias": "@type"}
    )
    currency: String
    amount: Int53
    user_ids: Vector[Int53]
    month_count: Int32
    text: FormattedText
    boosted_chat_id: typing.Optional[Int53] = field(default=0)


@dataclass(slots=True, kw_only=True)
class TelegramPaymentPurposePremiumGiveaway(BaseObject):
    """
    The user creating a Telegram Premium giveaway

    :param parameters: Giveaway parameters
    :type parameters: :class:`GiveawayParameters`
    :param currency: ISO 4217 currency code of the payment currency
    :type currency: :class:`String`
    :param amount: Paid amount, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param winner_count: Number of users which will be able to activate the gift codes
    :type winner_count: :class:`Int32`
    :param month_count: Number of months the Telegram Premium subscription will be active for the users
    :type month_count: :class:`Int32`
    """

    ID: typing.Literal["telegramPaymentPurposePremiumGiveaway"] = field(
        default="telegramPaymentPurposePremiumGiveaway", metadata={"alias": "@type"}
    )
    parameters: GiveawayParameters
    currency: String
    amount: Int53
    winner_count: Int32
    month_count: Int32


@dataclass(slots=True, kw_only=True)
class TelegramPaymentPurposeStarGiveaway(BaseObject):
    """
    The user creating a Telegram Star giveaway

    :param parameters: Giveaway parameters
    :type parameters: :class:`GiveawayParameters`
    :param currency: ISO 4217 currency code of the payment currency
    :type currency: :class:`String`
    :param amount: Paid amount, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param winner_count: The number of users to receive Telegram Stars
    :type winner_count: :class:`Int32`
    :param star_count: The number of Telegram Stars to be distributed through the giveaway
    :type star_count: :class:`Int53`
    """

    ID: typing.Literal["telegramPaymentPurposeStarGiveaway"] = field(
        default="telegramPaymentPurposeStarGiveaway", metadata={"alias": "@type"}
    )
    parameters: GiveawayParameters
    currency: String
    amount: Int53
    winner_count: Int32
    star_count: Int53


@dataclass(slots=True, kw_only=True)
class TelegramPaymentPurposeStars(BaseObject):
    """
    The user buying Telegram Stars

    :param currency: ISO 4217 currency code of the payment currency
    :type currency: :class:`String`
    :param amount: Paid amount, in the smallest units of the currency
    :type amount: :class:`Int53`
    :param star_count: Number of bought Telegram Stars
    :type star_count: :class:`Int53`
    """

    ID: typing.Literal["telegramPaymentPurposeStars"] = field(
        default="telegramPaymentPurposeStars", metadata={"alias": "@type"}
    )
    currency: String
    amount: Int53
    star_count: Int53


TelegramPaymentPurpose = typing.Union[
    TelegramPaymentPurposeGiftedStars,
    TelegramPaymentPurposeJoinChat,
    TelegramPaymentPurposePremiumGiftCodes,
    TelegramPaymentPurposePremiumGiveaway,
    TelegramPaymentPurposeStarGiveaway,
    TelegramPaymentPurposeStars,
]


@dataclass(slots=True, kw_only=True)
class TemporaryPasswordState(BaseObject):
    """
    Returns information about the availability of a temporary password, which can be used for payments

    :param valid_for: Time left before the temporary password expires, in seconds
    :type valid_for: :class:`Int32`
    :param has_password: True, if a temporary password is available
    :type has_password: :class:`Bool`
    """

    ID: typing.Literal["temporaryPasswordState"] = field(default="temporaryPasswordState", metadata={"alias": "@type"})
    valid_for: Int32
    has_password: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class TermsOfService(BaseObject):
    """
    Contains Telegram terms of service

    :param text: Text of the terms of service
    :type text: :class:`FormattedText`
    :param min_user_age: The minimum age of a user to be able to accept the terms; 0 if age isn't restricted
    :type min_user_age: :class:`Int32`
    :param show_popup: True, if a blocking popup with terms of service must be shown to the user
    :type show_popup: :class:`Bool`
    """

    ID: typing.Literal["termsOfService"] = field(default="termsOfService", metadata={"alias": "@type"})
    text: FormattedText
    min_user_age: Int32 = field(default=0)
    show_popup: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class TestBytes(BaseObject):
    """
    A simple object containing a sequence of bytes; for testing only

    :param value: Bytes
    :type value: :class:`Bytes`
    """

    ID: typing.Literal["testBytes"] = field(default="testBytes", metadata={"alias": "@type"})
    value: Bytes


@dataclass(slots=True, kw_only=True)
class TestInt(BaseObject):
    """
    A simple object containing a number; for testing only

    :param value: Number
    :type value: :class:`Int32`
    """

    ID: typing.Literal["testInt"] = field(default="testInt", metadata={"alias": "@type"})
    value: Int32


@dataclass(slots=True, kw_only=True)
class TestString(BaseObject):
    """
    A simple object containing a string; for testing only

    :param value: String
    :type value: :class:`String`
    """

    ID: typing.Literal["testString"] = field(default="testString", metadata={"alias": "@type"})
    value: String


@dataclass(slots=True, kw_only=True)
class TestVectorInt(BaseObject):
    """
    A simple object containing a vector of numbers; for testing only

    :param value: Vector of numbers
    :type value: :class:`Vector[Int32]`
    """

    ID: typing.Literal["testVectorInt"] = field(default="testVectorInt", metadata={"alias": "@type"})
    value: Vector[Int32]


@dataclass(slots=True, kw_only=True)
class TestVectorIntObject(BaseObject):
    """
    A simple object containing a vector of objects that hold a number; for testing only

    :param value: Vector of objects
    :type value: :class:`Vector[TestInt]`
    """

    ID: typing.Literal["testVectorIntObject"] = field(default="testVectorIntObject", metadata={"alias": "@type"})
    value: Vector[TestInt]


@dataclass(slots=True, kw_only=True)
class TestVectorString(BaseObject):
    """
    A simple object containing a vector of strings; for testing only

    :param value: Vector of strings
    :type value: :class:`Vector[String]`
    """

    ID: typing.Literal["testVectorString"] = field(default="testVectorString", metadata={"alias": "@type"})
    value: Vector[String]


@dataclass(slots=True, kw_only=True)
class TestVectorStringObject(BaseObject):
    """
    A simple object containing a vector of objects that hold a string; for testing only

    :param value: Vector of objects
    :type value: :class:`Vector[TestString]`
    """

    ID: typing.Literal["testVectorStringObject"] = field(default="testVectorStringObject", metadata={"alias": "@type"})
    value: Vector[TestString]


@dataclass(slots=True, kw_only=True)
class Text(BaseObject):
    """
    Contains some text

    :param text: Text
    :type text: :class:`String`
    """

    ID: typing.Literal["text"] = field(default="text", metadata={"alias": "@type"})
    text: String


@dataclass(slots=True, kw_only=True)
class TextEntities(BaseObject):
    """
    Contains a list of text entities

    :param entities: List of text entities
    :type entities: :class:`Vector[TextEntity]`
    """

    ID: typing.Literal["textEntities"] = field(default="textEntities", metadata={"alias": "@type"})
    entities: Vector[TextEntity]


@dataclass(slots=True, kw_only=True)
class TextEntity(BaseObject):
    """
    Represents a part of the text that needs to be formatted in some unusual way

    :param offset: Offset of the entity, in UTF-16 code units
    :type offset: :class:`Int32`
    :param length: Length of the entity, in UTF-16 code units
    :type length: :class:`Int32`
    :param type_: Type of the entity
    :type type_: :class:`TextEntityType`
    """

    ID: typing.Literal["textEntity"] = field(default="textEntity", metadata={"alias": "@type"})
    offset: Int32
    length: Int32
    type_: TextEntityType = field(default=MISSING, metadata={"alias": "type"})


@dataclass(slots=True, kw_only=True)
class TextEntityTypeBankCardNumber(BaseObject):
    """
    A bank card number. The getBankCardInfo method can be used to get information about the bank card
    """

    ID: typing.Literal["textEntityTypeBankCardNumber"] = field(
        default="textEntityTypeBankCardNumber", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class TextEntityTypeBlockQuote(BaseObject):
    """
    Text that must be formatted as if inside a blockquote HTML tag; not supported in secret chats
    """

    ID: typing.Literal["textEntityTypeBlockQuote"] = field(
        default="textEntityTypeBlockQuote", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class TextEntityTypeBold(BaseObject):
    """
    A bold text
    """

    ID: typing.Literal["textEntityTypeBold"] = field(default="textEntityTypeBold", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class TextEntityTypeBotCommand(BaseObject):
    """
    A bot command, beginning with "/"
    """

    ID: typing.Literal["textEntityTypeBotCommand"] = field(
        default="textEntityTypeBotCommand", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class TextEntityTypeCashtag(BaseObject):
    """
    A cashtag text, beginning with "$", consisting of capital English letters (e.g., "$USD"), and optionally containing a chat username at the end
    """

    ID: typing.Literal["textEntityTypeCashtag"] = field(default="textEntityTypeCashtag", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class TextEntityTypeCode(BaseObject):
    """
    Text that must be formatted as if inside a code HTML tag
    """

    ID: typing.Literal["textEntityTypeCode"] = field(default="textEntityTypeCode", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class TextEntityTypeCustomEmoji(BaseObject):
    """
    A custom emoji. The text behind a custom emoji must be an emoji. Only premium users can use premium custom emoji

    :param custom_emoji_id: Unique identifier of the custom emoji
    :type custom_emoji_id: :class:`Int64`
    """

    ID: typing.Literal["textEntityTypeCustomEmoji"] = field(
        default="textEntityTypeCustomEmoji", metadata={"alias": "@type"}
    )
    custom_emoji_id: Int64


@dataclass(slots=True, kw_only=True)
class TextEntityTypeEmailAddress(BaseObject):
    """
    An email address
    """

    ID: typing.Literal["textEntityTypeEmailAddress"] = field(
        default="textEntityTypeEmailAddress", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class TextEntityTypeExpandableBlockQuote(BaseObject):
    """
    Text that must be formatted as if inside a blockquote HTML tag and collapsed by default to 3 lines with the ability to show full text; not supported in secret chats
    """

    ID: typing.Literal["textEntityTypeExpandableBlockQuote"] = field(
        default="textEntityTypeExpandableBlockQuote", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class TextEntityTypeHashtag(BaseObject):
    """
    A hashtag text, beginning with "#" and optionally containing a chat username at the end
    """

    ID: typing.Literal["textEntityTypeHashtag"] = field(default="textEntityTypeHashtag", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class TextEntityTypeItalic(BaseObject):
    """
    An italic text
    """

    ID: typing.Literal["textEntityTypeItalic"] = field(default="textEntityTypeItalic", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class TextEntityTypeMediaTimestamp(BaseObject):
    """
    A media timestamp

    :param media_timestamp: Timestamp from which a video/audio/video note/voice note/story playing must start, in seconds. The media can be in the content or the link preview of the current message, or in the same places in the replied message
    :type media_timestamp: :class:`Int32`
    """

    ID: typing.Literal["textEntityTypeMediaTimestamp"] = field(
        default="textEntityTypeMediaTimestamp", metadata={"alias": "@type"}
    )
    media_timestamp: Int32


@dataclass(slots=True, kw_only=True)
class TextEntityTypeMention(BaseObject):
    """
    A mention of a user, a supergroup, or a channel by their username
    """

    ID: typing.Literal["textEntityTypeMention"] = field(default="textEntityTypeMention", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class TextEntityTypeMentionName(BaseObject):
    """
    A text shows instead of a raw mention of the user (e.g., when the user has no username)

    :param user_id: Identifier of the mentioned user
    :type user_id: :class:`Int53`
    """

    ID: typing.Literal["textEntityTypeMentionName"] = field(
        default="textEntityTypeMentionName", metadata={"alias": "@type"}
    )
    user_id: Int53


@dataclass(slots=True, kw_only=True)
class TextEntityTypePhoneNumber(BaseObject):
    """
    A phone number
    """

    ID: typing.Literal["textEntityTypePhoneNumber"] = field(
        default="textEntityTypePhoneNumber", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class TextEntityTypePre(BaseObject):
    """
    Text that must be formatted as if inside a pre HTML tag
    """

    ID: typing.Literal["textEntityTypePre"] = field(default="textEntityTypePre", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class TextEntityTypePreCode(BaseObject):
    """
    Text that must be formatted as if inside pre, and code HTML tags

    :param language: Programming language of the code; as defined by the sender
    :type language: :class:`String`
    """

    ID: typing.Literal["textEntityTypePreCode"] = field(default="textEntityTypePreCode", metadata={"alias": "@type"})
    language: String


@dataclass(slots=True, kw_only=True)
class TextEntityTypeSpoiler(BaseObject):
    """
    A spoiler text
    """

    ID: typing.Literal["textEntityTypeSpoiler"] = field(default="textEntityTypeSpoiler", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class TextEntityTypeStrikethrough(BaseObject):
    """
    A strikethrough text
    """

    ID: typing.Literal["textEntityTypeStrikethrough"] = field(
        default="textEntityTypeStrikethrough", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class TextEntityTypeTextUrl(BaseObject):
    """
    A text description shown instead of a raw URL

    :param url: HTTP or tg:// URL to be opened when the link is clicked
    :type url: :class:`String`
    """

    ID: typing.Literal["textEntityTypeTextUrl"] = field(default="textEntityTypeTextUrl", metadata={"alias": "@type"})
    url: String


@dataclass(slots=True, kw_only=True)
class TextEntityTypeUnderline(BaseObject):
    """
    An underlined text
    """

    ID: typing.Literal["textEntityTypeUnderline"] = field(
        default="textEntityTypeUnderline", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class TextEntityTypeUrl(BaseObject):
    """
    An HTTP URL
    """

    ID: typing.Literal["textEntityTypeUrl"] = field(default="textEntityTypeUrl", metadata={"alias": "@type"})


TextEntityType = typing.Union[
    TextEntityTypeBankCardNumber,
    TextEntityTypeBlockQuote,
    TextEntityTypeBold,
    TextEntityTypeBotCommand,
    TextEntityTypeCashtag,
    TextEntityTypeCode,
    TextEntityTypeCustomEmoji,
    TextEntityTypeEmailAddress,
    TextEntityTypeExpandableBlockQuote,
    TextEntityTypeHashtag,
    TextEntityTypeItalic,
    TextEntityTypeMediaTimestamp,
    TextEntityTypeMention,
    TextEntityTypeMentionName,
    TextEntityTypePhoneNumber,
    TextEntityTypePre,
    TextEntityTypePreCode,
    TextEntityTypeSpoiler,
    TextEntityTypeStrikethrough,
    TextEntityTypeTextUrl,
    TextEntityTypeUnderline,
    TextEntityTypeUrl,
]


@dataclass(slots=True, kw_only=True)
class TextParseModeHTML(BaseObject):
    """
    The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse mode
    """

    ID: typing.Literal["textParseModeHTML"] = field(default="textParseModeHTML", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class TextParseModeMarkdown(BaseObject):
    """
    The text uses Markdown-style formatting

    :param version: Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram Bot API "MarkdownV2" parse mode
    :type version: :class:`Int32`
    """

    ID: typing.Literal["textParseModeMarkdown"] = field(default="textParseModeMarkdown", metadata={"alias": "@type"})
    version: Int32


TextParseMode = typing.Union[
    TextParseModeHTML,
    TextParseModeMarkdown,
]


@dataclass(slots=True, kw_only=True)
class TextQuote(BaseObject):
    """
    Describes manually or automatically chosen quote from another message

    :param text: Text of the quote. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities can be present in the text
    :type text: :class:`FormattedText`
    :param position: Approximate quote position in the original message in UTF-16 code units as specified by the message sender
    :type position: :class:`Int32`
    :param is_manual: True, if the quote was manually chosen by the message sender
    :type is_manual: :class:`Bool`
    """

    ID: typing.Literal["textQuote"] = field(default="textQuote", metadata={"alias": "@type"})
    text: FormattedText
    position: Int32
    is_manual: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class ThemeParameters(BaseObject):
    """
    Contains parameters of the application theme

    :param background_color: A color of the background in the RGB format
    :type background_color: :class:`Int32`
    :param secondary_background_color: A secondary color for the background in the RGB format
    :type secondary_background_color: :class:`Int32`
    :param header_background_color: A color of the header background in the RGB format
    :type header_background_color: :class:`Int32`
    :param bottom_bar_background_color: A color of the bottom bar background in the RGB format
    :type bottom_bar_background_color: :class:`Int32`
    :param section_background_color: A color of the section background in the RGB format
    :type section_background_color: :class:`Int32`
    :param section_separator_color: A color of the section separator in the RGB format
    :type section_separator_color: :class:`Int32`
    :param text_color: A color of text in the RGB format
    :type text_color: :class:`Int32`
    :param accent_text_color: An accent color of the text in the RGB format
    :type accent_text_color: :class:`Int32`
    :param section_header_text_color: A color of text on the section headers in the RGB format
    :type section_header_text_color: :class:`Int32`
    :param subtitle_text_color: A color of the subtitle text in the RGB format
    :type subtitle_text_color: :class:`Int32`
    :param destructive_text_color: A color of the text for destructive actions in the RGB format
    :type destructive_text_color: :class:`Int32`
    :param hint_color: A color of hints in the RGB format
    :type hint_color: :class:`Int32`
    :param link_color: A color of links in the RGB format
    :type link_color: :class:`Int32`
    :param button_color: A color of the buttons in the RGB format
    :type button_color: :class:`Int32`
    :param button_text_color: A color of text on the buttons in the RGB format
    :type button_text_color: :class:`Int32`
    """

    ID: typing.Literal["themeParameters"] = field(default="themeParameters", metadata={"alias": "@type"})
    background_color: Int32
    secondary_background_color: Int32
    header_background_color: Int32
    bottom_bar_background_color: Int32
    section_background_color: Int32
    section_separator_color: Int32
    text_color: Int32
    accent_text_color: Int32
    section_header_text_color: Int32
    subtitle_text_color: Int32
    destructive_text_color: Int32
    hint_color: Int32
    link_color: Int32
    button_color: Int32
    button_text_color: Int32


@dataclass(slots=True, kw_only=True)
class ThemeSettings(BaseObject):
    """
    Describes theme settings

    :param accent_color: Theme accent color in ARGB format
    :type accent_color: :class:`Int32`
    :param outgoing_message_fill: The fill to be used as a background for outgoing messages
    :type outgoing_message_fill: :class:`BackgroundFill`
    :param outgoing_message_accent_color: Accent color of outgoing messages in ARGB format
    :type outgoing_message_accent_color: :class:`Int32`
    :param background: The background to be used in chats; may be null, defaults to None
    :type background: :class:`Background`, optional
    :param animate_outgoing_message_fill: If true, the freeform gradient fill needs to be animated on every sent message
    :type animate_outgoing_message_fill: :class:`Bool`
    """

    ID: typing.Literal["themeSettings"] = field(default="themeSettings", metadata={"alias": "@type"})
    accent_color: Int32
    outgoing_message_fill: BackgroundFill
    outgoing_message_accent_color: Int32
    background: typing.Optional[Background] = field(default=None)
    animate_outgoing_message_fill: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class Thumbnail(BaseObject):
    """
    Represents a thumbnail

    :param format_: Thumbnail format
    :type format_: :class:`ThumbnailFormat`
    :param width: Thumbnail width
    :type width: :class:`Int32`
    :param height: Thumbnail height
    :type height: :class:`Int32`
    :param file: The thumbnail
    :type file: :class:`File`
    """

    ID: typing.Literal["thumbnail"] = field(default="thumbnail", metadata={"alias": "@type"})
    format_: ThumbnailFormat = field(default=MISSING, metadata={"alias": "format"})
    width: Int32
    height: Int32
    file: File


@dataclass(slots=True, kw_only=True)
class ThumbnailFormatGif(BaseObject):
    """
    The thumbnail is in static GIF format. It will be used only for some bot inline query results
    """

    ID: typing.Literal["thumbnailFormatGif"] = field(default="thumbnailFormatGif", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ThumbnailFormatJpeg(BaseObject):
    """
    The thumbnail is in JPEG format
    """

    ID: typing.Literal["thumbnailFormatJpeg"] = field(default="thumbnailFormatJpeg", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ThumbnailFormatMpeg4(BaseObject):
    """
    The thumbnail is in MPEG4 format. It will be used only for some animations and videos
    """

    ID: typing.Literal["thumbnailFormatMpeg4"] = field(default="thumbnailFormatMpeg4", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ThumbnailFormatPng(BaseObject):
    """
    The thumbnail is in PNG format. It will be used only for background patterns
    """

    ID: typing.Literal["thumbnailFormatPng"] = field(default="thumbnailFormatPng", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ThumbnailFormatTgs(BaseObject):
    """
    The thumbnail is in TGS format. It will be used only for sticker sets
    """

    ID: typing.Literal["thumbnailFormatTgs"] = field(default="thumbnailFormatTgs", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ThumbnailFormatWebm(BaseObject):
    """
    The thumbnail is in WEBM format. It will be used only for sticker sets
    """

    ID: typing.Literal["thumbnailFormatWebm"] = field(default="thumbnailFormatWebm", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class ThumbnailFormatWebp(BaseObject):
    """
    The thumbnail is in WEBP format. It will be used only for some stickers and sticker sets
    """

    ID: typing.Literal["thumbnailFormatWebp"] = field(default="thumbnailFormatWebp", metadata={"alias": "@type"})


ThumbnailFormat = typing.Union[
    ThumbnailFormatGif,
    ThumbnailFormatJpeg,
    ThumbnailFormatMpeg4,
    ThumbnailFormatPng,
    ThumbnailFormatTgs,
    ThumbnailFormatWebm,
    ThumbnailFormatWebp,
]


@dataclass(slots=True, kw_only=True)
class TimeZone(BaseObject):
    """
    Describes a time zone

    :param id: Unique time zone identifier
    :type id: :class:`String`
    :param name: Time zone name
    :type name: :class:`String`
    :param utc_time_offset: Current UTC time offset for the time zone
    :type utc_time_offset: :class:`Int32`
    """

    ID: typing.Literal["timeZone"] = field(default="timeZone", metadata={"alias": "@type"})
    id: String
    name: String
    utc_time_offset: Int32


@dataclass(slots=True, kw_only=True)
class TimeZones(BaseObject):
    """
    Contains a list of time zones

    :param time_zones: A list of time zones
    :type time_zones: :class:`Vector[TimeZone]`
    """

    ID: typing.Literal["timeZones"] = field(default="timeZones", metadata={"alias": "@type"})
    time_zones: Vector[TimeZone]


@dataclass(slots=True, kw_only=True)
class TopChatCategoryBots(BaseObject):
    """
    A category containing frequently used private chats with bot users
    """

    ID: typing.Literal["topChatCategoryBots"] = field(default="topChatCategoryBots", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class TopChatCategoryCalls(BaseObject):
    """
    A category containing frequently used chats used for calls
    """

    ID: typing.Literal["topChatCategoryCalls"] = field(default="topChatCategoryCalls", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class TopChatCategoryChannels(BaseObject):
    """
    A category containing frequently used channels
    """

    ID: typing.Literal["topChatCategoryChannels"] = field(
        default="topChatCategoryChannels", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class TopChatCategoryForwardChats(BaseObject):
    """
    A category containing frequently used chats used to forward messages
    """

    ID: typing.Literal["topChatCategoryForwardChats"] = field(
        default="topChatCategoryForwardChats", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class TopChatCategoryGroups(BaseObject):
    """
    A category containing frequently used basic groups and supergroups
    """

    ID: typing.Literal["topChatCategoryGroups"] = field(default="topChatCategoryGroups", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class TopChatCategoryInlineBots(BaseObject):
    """
    A category containing frequently used chats with inline bots sorted by their usage in inline mode
    """

    ID: typing.Literal["topChatCategoryInlineBots"] = field(
        default="topChatCategoryInlineBots", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class TopChatCategoryUsers(BaseObject):
    """
    A category containing frequently used private chats with non-bot users
    """

    ID: typing.Literal["topChatCategoryUsers"] = field(default="topChatCategoryUsers", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class TopChatCategoryWebAppBots(BaseObject):
    """
    A category containing frequently used chats with bots, which Web Apps were opened
    """

    ID: typing.Literal["topChatCategoryWebAppBots"] = field(
        default="topChatCategoryWebAppBots", metadata={"alias": "@type"}
    )


TopChatCategory = typing.Union[
    TopChatCategoryBots,
    TopChatCategoryCalls,
    TopChatCategoryChannels,
    TopChatCategoryForwardChats,
    TopChatCategoryGroups,
    TopChatCategoryInlineBots,
    TopChatCategoryUsers,
    TopChatCategoryWebAppBots,
]


@dataclass(slots=True, kw_only=True)
class TrendingStickerSets(BaseObject):
    """
    Represents a list of trending sticker sets

    :param total_count: Approximate total number of trending sticker sets
    :type total_count: :class:`Int32`
    :param sets: List of trending sticker sets
    :type sets: :class:`Vector[StickerSetInfo]`
    :param is_premium: True, if the list contains sticker sets with premium stickers
    :type is_premium: :class:`Bool`
    """

    ID: typing.Literal["trendingStickerSets"] = field(default="trendingStickerSets", metadata={"alias": "@type"})
    total_count: Int32
    sets: Vector[StickerSetInfo]
    is_premium: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class UnconfirmedSession(BaseObject):
    """
    Contains information about an unconfirmed session

    :param id: Session identifier
    :type id: :class:`Int64`
    :param log_in_date: Point in time (Unix timestamp) when the user has logged in
    :type log_in_date: :class:`Int32`
    :param device_model: Model of the device that was used for the session creation, as provided by the application
    :type device_model: :class:`String`
    :param location: A human-readable description of the location from which the session was created, based on the IP address
    :type location: :class:`String`
    """

    ID: typing.Literal["unconfirmedSession"] = field(default="unconfirmedSession", metadata={"alias": "@type"})
    id: Int64
    log_in_date: Int32
    device_model: String
    location: String


@dataclass(slots=True, kw_only=True)
class UnreadReaction(BaseObject):
    """
    Contains information about an unread reaction to a message

    :param type_: Type of the reaction
    :type type_: :class:`ReactionType`
    :param sender_id: Identifier of the sender, added the reaction
    :type sender_id: :class:`MessageSender`
    :param is_big: True, if the reaction was added with a big animation
    :type is_big: :class:`Bool`
    """

    ID: typing.Literal["unreadReaction"] = field(default="unreadReaction", metadata={"alias": "@type"})
    type_: ReactionType = field(default=MISSING, metadata={"alias": "type"})
    sender_id: MessageSender
    is_big: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class UpdateAccentColors(BaseObject):
    """
    The list of supported accent colors has changed

    :param colors: Information about supported colors; colors with identifiers 0 (red), 1 (orange), 2 (purple/violet), 3 (green), 4 (cyan), 5 (blue), 6 (pink) must always be supported and aren't included in the list. The exact colors for the accent colors with identifiers 0-6 must be taken from the app theme
    :type colors: :class:`Vector[AccentColor]`
    :param available_accent_color_ids: The list of accent color identifiers, which can be set through setAccentColor and setChatAccentColor. The colors must be shown in the specified order
    :type available_accent_color_ids: :class:`Vector[Int32]`
    """

    ID: typing.Literal["updateAccentColors"] = field(default="updateAccentColors", metadata={"alias": "@type"})
    colors: Vector[AccentColor]
    available_accent_color_ids: Vector[Int32]


@dataclass(slots=True, kw_only=True)
class UpdateActiveEmojiReactions(BaseObject):
    """
    The list of active emoji reactions has changed

    :param emojis: The new list of active emoji reactions
    :type emojis: :class:`Vector[String]`
    """

    ID: typing.Literal["updateActiveEmojiReactions"] = field(
        default="updateActiveEmojiReactions", metadata={"alias": "@type"}
    )
    emojis: Vector[String]


@dataclass(slots=True, kw_only=True)
class UpdateActiveLiveLocationMessages(BaseObject):
    """
    The list of messages with active live location that need to be updated by the application has changed. The list is persistent across application restarts only if the message database is used

    :param messages: The list of messages with active live locations
    :type messages: :class:`Vector[Message]`
    """

    ID: typing.Literal["updateActiveLiveLocationMessages"] = field(
        default="updateActiveLiveLocationMessages", metadata={"alias": "@type"}
    )
    messages: Vector[Message]


@dataclass(slots=True, kw_only=True)
class UpdateActiveNotifications(BaseObject):
    """
    Contains active notifications that were shown on previous application launches. This update is sent only if the message database is used. In that case it comes once before any updateNotification and updateNotificationGroup update

    :param groups: Lists of active notification groups
    :type groups: :class:`Vector[NotificationGroup]`
    """

    ID: typing.Literal["updateActiveNotifications"] = field(
        default="updateActiveNotifications", metadata={"alias": "@type"}
    )
    groups: Vector[NotificationGroup]


@dataclass(slots=True, kw_only=True)
class UpdateAnimatedEmojiMessageClicked(BaseObject):
    """
    Some animated emoji message was clicked and a big animated sticker must be played if the message is visible on the screen. chatActionWatchingAnimations with the text of the message needs to be sent if the sticker is played

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param message_id: Message identifier
    :type message_id: :class:`Int53`
    :param sticker: The animated sticker to be played
    :type sticker: :class:`Sticker`
    """

    ID: typing.Literal["updateAnimatedEmojiMessageClicked"] = field(
        default="updateAnimatedEmojiMessageClicked", metadata={"alias": "@type"}
    )
    chat_id: Int53
    message_id: Int53
    sticker: Sticker


@dataclass(slots=True, kw_only=True)
class UpdateAnimationSearchParameters(BaseObject):
    """
    The parameters of animation search through getOption("animation_search_bot_username") bot has changed

    :param provider: Name of the animation search provider
    :type provider: :class:`String`
    :param emojis: The new list of emojis suggested for searching
    :type emojis: :class:`Vector[String]`
    """

    ID: typing.Literal["updateAnimationSearchParameters"] = field(
        default="updateAnimationSearchParameters", metadata={"alias": "@type"}
    )
    provider: String
    emojis: Vector[String]


@dataclass(slots=True, kw_only=True)
class UpdateApplicationRecaptchaVerificationRequired(BaseObject):
    """
    A request can't be completed unless reCAPTCHA verification is performed; for official mobile applications only. The method setApplicationVerificationToken must be called once the verification is completed or failed

    :param verification_id: Unique identifier for the verification process
    :type verification_id: :class:`Int53`
    :param action: The action for the check
    :type action: :class:`String`
    :param recaptcha_key_id: Identifier of the reCAPTCHA key
    :type recaptcha_key_id: :class:`String`
    """

    ID: typing.Literal["updateApplicationRecaptchaVerificationRequired"] = field(
        default="updateApplicationRecaptchaVerificationRequired", metadata={"alias": "@type"}
    )
    verification_id: Int53
    action: String
    recaptcha_key_id: String


@dataclass(slots=True, kw_only=True)
class UpdateApplicationVerificationRequired(BaseObject):
    """
    A request can't be completed unless application verification is performed; for official mobile applications only. The method setApplicationVerificationToken must be called once the verification is completed or failed

    :param verification_id: Unique identifier for the verification process
    :type verification_id: :class:`Int53`
    :param nonce: Unique base64url-encoded nonce for the classic Play Integrity verification (https://developer.android.com/google/play/integrity/classic) for Android, or a unique string to compare with verify_nonce field from a push notification for iOS
    :type nonce: :class:`String`
    :param cloud_project_number: Cloud project number to pass to the Play Integrity API on Android
    :type cloud_project_number: :class:`Int64`
    """

    ID: typing.Literal["updateApplicationVerificationRequired"] = field(
        default="updateApplicationVerificationRequired", metadata={"alias": "@type"}
    )
    verification_id: Int53
    nonce: String
    cloud_project_number: Int64


@dataclass(slots=True, kw_only=True)
class UpdateAttachmentMenuBots(BaseObject):
    """
    The list of bots added to attachment or side menu has changed

    :param bots: The new list of bots. The bots must not be shown on scheduled messages screen
    :type bots: :class:`Vector[AttachmentMenuBot]`
    """

    ID: typing.Literal["updateAttachmentMenuBots"] = field(
        default="updateAttachmentMenuBots", metadata={"alias": "@type"}
    )
    bots: Vector[AttachmentMenuBot]


@dataclass(slots=True, kw_only=True)
class UpdateAuthorizationState(BaseObject):
    """
    The user authorization state has changed

    :param authorization_state: New authorization state
    :type authorization_state: :class:`AuthorizationState`
    """

    ID: typing.Literal["updateAuthorizationState"] = field(
        default="updateAuthorizationState", metadata={"alias": "@type"}
    )
    authorization_state: AuthorizationState


@dataclass(slots=True, kw_only=True)
class UpdateAutosaveSettings(BaseObject):
    """
    Autosave settings for some type of chats were updated

    :param scope: Type of chats for which autosave settings were updated
    :type scope: :class:`AutosaveSettingsScope`
    :param settings: The new autosave settings; may be null if the settings are reset to default, defaults to None
    :type settings: :class:`ScopeAutosaveSettings`, optional
    """

    ID: typing.Literal["updateAutosaveSettings"] = field(default="updateAutosaveSettings", metadata={"alias": "@type"})
    scope: AutosaveSettingsScope
    settings: typing.Optional[ScopeAutosaveSettings] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateAvailableMessageEffects(BaseObject):
    """
    The list of available message effects has changed

    :param reaction_effect_ids: The new list of available message effects from emoji reactions
    :type reaction_effect_ids: :class:`Vector[Int64]`
    :param sticker_effect_ids: The new list of available message effects from Premium stickers
    :type sticker_effect_ids: :class:`Vector[Int64]`
    """

    ID: typing.Literal["updateAvailableMessageEffects"] = field(
        default="updateAvailableMessageEffects", metadata={"alias": "@type"}
    )
    reaction_effect_ids: Vector[Int64]
    sticker_effect_ids: Vector[Int64]


@dataclass(slots=True, kw_only=True)
class UpdateBasicGroup(BaseObject):
    """
    Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the application

    :param basic_group: New data about the group
    :type basic_group: :class:`BasicGroup`
    """

    ID: typing.Literal["updateBasicGroup"] = field(default="updateBasicGroup", metadata={"alias": "@type"})
    basic_group: BasicGroup


@dataclass(slots=True, kw_only=True)
class UpdateBasicGroupFullInfo(BaseObject):
    """
    Some data in basicGroupFullInfo has been changed

    :param basic_group_id: Identifier of a basic group
    :type basic_group_id: :class:`Int53`
    :param basic_group_full_info: New full information about the group
    :type basic_group_full_info: :class:`BasicGroupFullInfo`
    """

    ID: typing.Literal["updateBasicGroupFullInfo"] = field(
        default="updateBasicGroupFullInfo", metadata={"alias": "@type"}
    )
    basic_group_id: Int53
    basic_group_full_info: BasicGroupFullInfo


@dataclass(slots=True, kw_only=True)
class UpdateBusinessConnection(BaseObject):
    """
    A business connection has changed; for bots only

    :param connection: New data about the connection
    :type connection: :class:`BusinessConnection`
    """

    ID: typing.Literal["updateBusinessConnection"] = field(
        default="updateBusinessConnection", metadata={"alias": "@type"}
    )
    connection: BusinessConnection


@dataclass(slots=True, kw_only=True)
class UpdateBusinessMessageEdited(BaseObject):
    """
    A message in a business account was edited; for bots only

    :param connection_id: Unique identifier of the business connection
    :type connection_id: :class:`String`
    :param message: The edited message
    :type message: :class:`BusinessMessage`
    """

    ID: typing.Literal["updateBusinessMessageEdited"] = field(
        default="updateBusinessMessageEdited", metadata={"alias": "@type"}
    )
    connection_id: String
    message: BusinessMessage


@dataclass(slots=True, kw_only=True)
class UpdateBusinessMessagesDeleted(BaseObject):
    """
    Messages in a business account were deleted; for bots only

    :param connection_id: Unique identifier of the business connection
    :type connection_id: :class:`String`
    :param chat_id: Identifier of a chat in the business account in which messages were deleted
    :type chat_id: :class:`Int53`
    :param message_ids: Unique message identifiers of the deleted messages
    :type message_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["updateBusinessMessagesDeleted"] = field(
        default="updateBusinessMessagesDeleted", metadata={"alias": "@type"}
    )
    connection_id: String
    chat_id: Int53
    message_ids: Vector[Int53]


@dataclass(slots=True, kw_only=True)
class UpdateCall(BaseObject):
    """
    New call was created or information about a call was updated

    :param call: New data about a call
    :type call: :class:`Call`
    """

    ID: typing.Literal["updateCall"] = field(default="updateCall", metadata={"alias": "@type"})
    call: Call


@dataclass(slots=True, kw_only=True)
class UpdateChatAccentColors(BaseObject):
    """
    Chat accent colors have changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param accent_color_id: The new chat accent color identifier
    :type accent_color_id: :class:`Int32`
    :param profile_accent_color_id: The new chat profile accent color identifier; -1 if none
    :type profile_accent_color_id: :class:`Int32`
    :param background_custom_emoji_id: The new identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none, defaults to None
    :type background_custom_emoji_id: :class:`Int64`, optional
    :param profile_background_custom_emoji_id: The new identifier of a custom emoji to be shown on the profile background; 0 if none, defaults to None
    :type profile_background_custom_emoji_id: :class:`Int64`, optional
    """

    ID: typing.Literal["updateChatAccentColors"] = field(default="updateChatAccentColors", metadata={"alias": "@type"})
    chat_id: Int53
    accent_color_id: Int32
    profile_accent_color_id: Int32
    background_custom_emoji_id: typing.Optional[Int64] = field(default=0)
    profile_background_custom_emoji_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class UpdateChatAction(BaseObject):
    """
    A message sender activity in the chat has changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param sender_id: Identifier of a message sender performing the action
    :type sender_id: :class:`MessageSender`
    :param action: The action
    :type action: :class:`ChatAction`
    :param message_thread_id: If not 0, the message thread identifier in which the action was performed
    :type message_thread_id: :class:`Int53`
    """

    ID: typing.Literal["updateChatAction"] = field(default="updateChatAction", metadata={"alias": "@type"})
    chat_id: Int53
    sender_id: MessageSender
    action: ChatAction
    message_thread_id: Int53 = field(default=0)


@dataclass(slots=True, kw_only=True)
class UpdateChatActionBar(BaseObject):
    """
    The chat action bar was changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param action_bar: The new value of the action bar; may be null, defaults to None
    :type action_bar: :class:`ChatActionBar`, optional
    """

    ID: typing.Literal["updateChatActionBar"] = field(default="updateChatActionBar", metadata={"alias": "@type"})
    chat_id: Int53
    action_bar: typing.Optional[ChatActionBar] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateChatActiveStories(BaseObject):
    """
    The list of active stories posted by a specific chat has changed

    :param active_stories: The new list of active stories
    :type active_stories: :class:`ChatActiveStories`
    """

    ID: typing.Literal["updateChatActiveStories"] = field(
        default="updateChatActiveStories", metadata={"alias": "@type"}
    )
    active_stories: ChatActiveStories


@dataclass(slots=True, kw_only=True)
class UpdateChatAddedToList(BaseObject):
    """
    A chat was added to a chat list

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param chat_list: The chat list to which the chat was added
    :type chat_list: :class:`ChatList`
    """

    ID: typing.Literal["updateChatAddedToList"] = field(default="updateChatAddedToList", metadata={"alias": "@type"})
    chat_id: Int53
    chat_list: ChatList


@dataclass(slots=True, kw_only=True)
class UpdateChatAvailableReactions(BaseObject):
    """
    The chat available reactions were changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param available_reactions: The new reactions, available in the chat
    :type available_reactions: :class:`ChatAvailableReactions`
    """

    ID: typing.Literal["updateChatAvailableReactions"] = field(
        default="updateChatAvailableReactions", metadata={"alias": "@type"}
    )
    chat_id: Int53
    available_reactions: ChatAvailableReactions


@dataclass(slots=True, kw_only=True)
class UpdateChatBackground(BaseObject):
    """
    The chat background was changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param background: The new chat background; may be null if background was reset to default, defaults to None
    :type background: :class:`ChatBackground`, optional
    """

    ID: typing.Literal["updateChatBackground"] = field(default="updateChatBackground", metadata={"alias": "@type"})
    chat_id: Int53
    background: typing.Optional[ChatBackground] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateChatBlockList(BaseObject):
    """
    A chat was blocked or unblocked

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param block_list: Block list to which the chat is added; may be null if none, defaults to None
    :type block_list: :class:`BlockList`, optional
    """

    ID: typing.Literal["updateChatBlockList"] = field(default="updateChatBlockList", metadata={"alias": "@type"})
    chat_id: Int53
    block_list: typing.Optional[BlockList] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateChatBoost(BaseObject):
    """
    A chat boost has changed; for bots only

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param boost: New information about the boost
    :type boost: :class:`ChatBoost`
    """

    ID: typing.Literal["updateChatBoost"] = field(default="updateChatBoost", metadata={"alias": "@type"})
    chat_id: Int53
    boost: ChatBoost


@dataclass(slots=True, kw_only=True)
class UpdateChatBusinessBotManageBar(BaseObject):
    """
    The bar for managing business bot was changed in a chat

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param business_bot_manage_bar: The new value of the business bot manage bar; may be null, defaults to None
    :type business_bot_manage_bar: :class:`BusinessBotManageBar`, optional
    """

    ID: typing.Literal["updateChatBusinessBotManageBar"] = field(
        default="updateChatBusinessBotManageBar", metadata={"alias": "@type"}
    )
    chat_id: Int53
    business_bot_manage_bar: typing.Optional[BusinessBotManageBar] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateChatDefaultDisableNotification(BaseObject):
    """
    The value of the default disable_notification parameter, used when a message is sent to the chat, was changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param default_disable_notification: The new default_disable_notification value
    :type default_disable_notification: :class:`Bool`
    """

    ID: typing.Literal["updateChatDefaultDisableNotification"] = field(
        default="updateChatDefaultDisableNotification", metadata={"alias": "@type"}
    )
    chat_id: Int53
    default_disable_notification: Bool


@dataclass(slots=True, kw_only=True)
class UpdateChatDraftMessage(BaseObject):
    """
    A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update mustn't be applied

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param positions: The new chat positions in the chat lists
    :type positions: :class:`Vector[ChatPosition]`
    :param draft_message: The new draft message; may be null if none, defaults to None
    :type draft_message: :class:`DraftMessage`, optional
    """

    ID: typing.Literal["updateChatDraftMessage"] = field(default="updateChatDraftMessage", metadata={"alias": "@type"})
    chat_id: Int53
    positions: Vector[ChatPosition]
    draft_message: typing.Optional[DraftMessage] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateChatEmojiStatus(BaseObject):
    """
    Chat emoji status has changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param emoji_status: The new chat emoji status; may be null, defaults to None
    :type emoji_status: :class:`EmojiStatus`, optional
    """

    ID: typing.Literal["updateChatEmojiStatus"] = field(default="updateChatEmojiStatus", metadata={"alias": "@type"})
    chat_id: Int53
    emoji_status: typing.Optional[EmojiStatus] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateChatFolders(BaseObject):
    """
    The list of chat folders or a chat folder has changed

    :param chat_folders: The new list of chat folders
    :type chat_folders: :class:`Vector[ChatFolderInfo]`
    :param main_chat_list_position: Position of the main chat list among chat folders, 0-based
    :type main_chat_list_position: :class:`Int32`
    :param are_tags_enabled: True, if folder tags are enabled
    :type are_tags_enabled: :class:`Bool`
    """

    ID: typing.Literal["updateChatFolders"] = field(default="updateChatFolders", metadata={"alias": "@type"})
    chat_folders: Vector[ChatFolderInfo]
    main_chat_list_position: Int32
    are_tags_enabled: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class UpdateChatHasProtectedContent(BaseObject):
    """
    A chat content was allowed or restricted for saving

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param has_protected_content: New value of has_protected_content
    :type has_protected_content: :class:`Bool`
    """

    ID: typing.Literal["updateChatHasProtectedContent"] = field(
        default="updateChatHasProtectedContent", metadata={"alias": "@type"}
    )
    chat_id: Int53
    has_protected_content: Bool


@dataclass(slots=True, kw_only=True)
class UpdateChatHasScheduledMessages(BaseObject):
    """
    A chat's has_scheduled_messages field has changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param has_scheduled_messages: New value of has_scheduled_messages
    :type has_scheduled_messages: :class:`Bool`
    """

    ID: typing.Literal["updateChatHasScheduledMessages"] = field(
        default="updateChatHasScheduledMessages", metadata={"alias": "@type"}
    )
    chat_id: Int53
    has_scheduled_messages: Bool


@dataclass(slots=True, kw_only=True)
class UpdateChatIsMarkedAsUnread(BaseObject):
    """
    A chat was marked as unread or was read

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param is_marked_as_unread: New value of is_marked_as_unread
    :type is_marked_as_unread: :class:`Bool`
    """

    ID: typing.Literal["updateChatIsMarkedAsUnread"] = field(
        default="updateChatIsMarkedAsUnread", metadata={"alias": "@type"}
    )
    chat_id: Int53
    is_marked_as_unread: Bool


@dataclass(slots=True, kw_only=True)
class UpdateChatIsTranslatable(BaseObject):
    """
    Translation of chat messages was enabled or disabled

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param is_translatable: New value of is_translatable
    :type is_translatable: :class:`Bool`
    """

    ID: typing.Literal["updateChatIsTranslatable"] = field(
        default="updateChatIsTranslatable", metadata={"alias": "@type"}
    )
    chat_id: Int53
    is_translatable: Bool


@dataclass(slots=True, kw_only=True)
class UpdateChatLastMessage(BaseObject):
    """
    The last message of a chat was changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param positions: The new chat positions in the chat lists
    :type positions: :class:`Vector[ChatPosition]`
    :param last_message: The new last message in the chat; may be null if the last message became unknown. While the last message is unknown, new messages can be added to the chat without corresponding updateNewMessage update, defaults to None
    :type last_message: :class:`Message`, optional
    """

    ID: typing.Literal["updateChatLastMessage"] = field(default="updateChatLastMessage", metadata={"alias": "@type"})
    chat_id: Int53
    positions: Vector[ChatPosition]
    last_message: typing.Optional[Message] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateChatMember(BaseObject):
    """
    User rights changed in a chat; for bots only

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param actor_user_id: Identifier of the user, changing the rights
    :type actor_user_id: :class:`Int53`
    :param date: Point in time (Unix timestamp) when the user rights were changed
    :type date: :class:`Int32`
    :param old_chat_member: Previous chat member
    :type old_chat_member: :class:`ChatMember`
    :param new_chat_member: New chat member
    :type new_chat_member: :class:`ChatMember`
    :param invite_link: If user has joined the chat using an invite link, the invite link; may be null, defaults to None
    :type invite_link: :class:`ChatInviteLink`, optional
    :param via_join_request: True, if the user has joined the chat after sending a join request and being approved by an administrator
    :type via_join_request: :class:`Bool`
    :param via_chat_folder_invite_link: True, if the user has joined the chat using an invite link for a chat folder
    :type via_chat_folder_invite_link: :class:`Bool`
    """

    ID: typing.Literal["updateChatMember"] = field(default="updateChatMember", metadata={"alias": "@type"})
    chat_id: Int53
    actor_user_id: Int53
    date: Int32
    old_chat_member: ChatMember
    new_chat_member: ChatMember
    invite_link: typing.Optional[ChatInviteLink] = field(default=None)
    via_join_request: Bool = field(default=False)
    via_chat_folder_invite_link: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class UpdateChatMessageAutoDeleteTime(BaseObject):
    """
    The message auto-delete or self-destruct timer setting for a chat was changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param message_auto_delete_time: New value of message_auto_delete_time
    :type message_auto_delete_time: :class:`Int32`
    """

    ID: typing.Literal["updateChatMessageAutoDeleteTime"] = field(
        default="updateChatMessageAutoDeleteTime", metadata={"alias": "@type"}
    )
    chat_id: Int53
    message_auto_delete_time: Int32


@dataclass(slots=True, kw_only=True)
class UpdateChatMessageSender(BaseObject):
    """
    The message sender that is selected to send messages in a chat has changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param message_sender_id: New value of message_sender_id; may be null if the user can't change message sender, defaults to None
    :type message_sender_id: :class:`MessageSender`, optional
    """

    ID: typing.Literal["updateChatMessageSender"] = field(
        default="updateChatMessageSender", metadata={"alias": "@type"}
    )
    chat_id: Int53
    message_sender_id: typing.Optional[MessageSender] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateChatNotificationSettings(BaseObject):
    """
    Notification settings for a chat were changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param notification_settings: The new notification settings
    :type notification_settings: :class:`ChatNotificationSettings`
    """

    ID: typing.Literal["updateChatNotificationSettings"] = field(
        default="updateChatNotificationSettings", metadata={"alias": "@type"}
    )
    chat_id: Int53
    notification_settings: ChatNotificationSettings


@dataclass(slots=True, kw_only=True)
class UpdateChatOnlineMemberCount(BaseObject):
    """
    The number of online group members has changed. This update with non-zero number of online group members is sent only for currently opened chats. There is no guarantee that it is sent just after the number of online users has changed

    :param chat_id: Identifier of the chat
    :type chat_id: :class:`Int53`
    :param online_member_count: New number of online members in the chat, or 0 if unknown
    :type online_member_count: :class:`Int32`
    """

    ID: typing.Literal["updateChatOnlineMemberCount"] = field(
        default="updateChatOnlineMemberCount", metadata={"alias": "@type"}
    )
    chat_id: Int53
    online_member_count: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class UpdateChatPendingJoinRequests(BaseObject):
    """
    The chat pending join requests were changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param pending_join_requests: The new data about pending join requests; may be null, defaults to None
    :type pending_join_requests: :class:`ChatJoinRequestsInfo`, optional
    """

    ID: typing.Literal["updateChatPendingJoinRequests"] = field(
        default="updateChatPendingJoinRequests", metadata={"alias": "@type"}
    )
    chat_id: Int53
    pending_join_requests: typing.Optional[ChatJoinRequestsInfo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateChatPermissions(BaseObject):
    """
    Chat permissions were changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param permissions: The new chat permissions
    :type permissions: :class:`ChatPermissions`
    """

    ID: typing.Literal["updateChatPermissions"] = field(default="updateChatPermissions", metadata={"alias": "@type"})
    chat_id: Int53
    permissions: ChatPermissions


@dataclass(slots=True, kw_only=True)
class UpdateChatPhoto(BaseObject):
    """
    A chat photo was changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param photo: The new chat photo; may be null, defaults to None
    :type photo: :class:`ChatPhotoInfo`, optional
    """

    ID: typing.Literal["updateChatPhoto"] = field(default="updateChatPhoto", metadata={"alias": "@type"})
    chat_id: Int53
    photo: typing.Optional[ChatPhotoInfo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateChatPosition(BaseObject):
    """
    The position of a chat in a chat list has changed. An updateChatLastMessage or updateChatDraftMessage update might be sent instead of the update

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param position: New chat position. If new order is 0, then the chat needs to be removed from the list
    :type position: :class:`ChatPosition`
    """

    ID: typing.Literal["updateChatPosition"] = field(default="updateChatPosition", metadata={"alias": "@type"})
    chat_id: Int53
    position: ChatPosition


@dataclass(slots=True, kw_only=True)
class UpdateChatReadInbox(BaseObject):
    """
    Incoming messages were read or the number of unread messages has been changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param last_read_inbox_message_id: Identifier of the last read incoming message
    :type last_read_inbox_message_id: :class:`Int53`
    :param unread_count: The number of unread messages left in the chat
    :type unread_count: :class:`Int32`
    """

    ID: typing.Literal["updateChatReadInbox"] = field(default="updateChatReadInbox", metadata={"alias": "@type"})
    chat_id: Int53
    last_read_inbox_message_id: Int53
    unread_count: Int32


@dataclass(slots=True, kw_only=True)
class UpdateChatReadOutbox(BaseObject):
    """
    Outgoing messages were read

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param last_read_outbox_message_id: Identifier of last read outgoing message
    :type last_read_outbox_message_id: :class:`Int53`
    """

    ID: typing.Literal["updateChatReadOutbox"] = field(default="updateChatReadOutbox", metadata={"alias": "@type"})
    chat_id: Int53
    last_read_outbox_message_id: Int53


@dataclass(slots=True, kw_only=True)
class UpdateChatRemovedFromList(BaseObject):
    """
    A chat was removed from a chat list

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param chat_list: The chat list from which the chat was removed
    :type chat_list: :class:`ChatList`
    """

    ID: typing.Literal["updateChatRemovedFromList"] = field(
        default="updateChatRemovedFromList", metadata={"alias": "@type"}
    )
    chat_id: Int53
    chat_list: ChatList


@dataclass(slots=True, kw_only=True)
class UpdateChatReplyMarkup(BaseObject):
    """
    The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param reply_markup_message_id: Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
    :type reply_markup_message_id: :class:`Int53`
    """

    ID: typing.Literal["updateChatReplyMarkup"] = field(default="updateChatReplyMarkup", metadata={"alias": "@type"})
    chat_id: Int53
    reply_markup_message_id: Int53 = field(default=0)


@dataclass(slots=True, kw_only=True)
class UpdateChatRevenueAmount(BaseObject):
    """
    The revenue earned from sponsored messages in a chat has changed. If chat revenue screen is opened, then getChatRevenueTransactions may be called to fetch new transactions

    :param chat_id: Identifier of the chat
    :type chat_id: :class:`Int53`
    :param revenue_amount: New amount of earned revenue
    :type revenue_amount: :class:`ChatRevenueAmount`
    """

    ID: typing.Literal["updateChatRevenueAmount"] = field(
        default="updateChatRevenueAmount", metadata={"alias": "@type"}
    )
    chat_id: Int53
    revenue_amount: ChatRevenueAmount


@dataclass(slots=True, kw_only=True)
class UpdateChatTheme(BaseObject):
    """
    The chat theme was changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param theme_name: The new name of the chat theme; may be empty if theme was reset to default
    :type theme_name: :class:`String`
    """

    ID: typing.Literal["updateChatTheme"] = field(default="updateChatTheme", metadata={"alias": "@type"})
    chat_id: Int53
    theme_name: String = field(default="")


@dataclass(slots=True, kw_only=True)
class UpdateChatThemes(BaseObject):
    """
    The list of available chat themes has changed

    :param chat_themes: The new list of chat themes
    :type chat_themes: :class:`Vector[ChatTheme]`
    """

    ID: typing.Literal["updateChatThemes"] = field(default="updateChatThemes", metadata={"alias": "@type"})
    chat_themes: Vector[ChatTheme]


@dataclass(slots=True, kw_only=True)
class UpdateChatTitle(BaseObject):
    """
    The title of a chat was changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param title: The new chat title
    :type title: :class:`String`
    """

    ID: typing.Literal["updateChatTitle"] = field(default="updateChatTitle", metadata={"alias": "@type"})
    chat_id: Int53
    title: String


@dataclass(slots=True, kw_only=True)
class UpdateChatUnreadMentionCount(BaseObject):
    """
    The chat unread_mention_count has changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param unread_mention_count: The number of unread mention messages left in the chat
    :type unread_mention_count: :class:`Int32`
    """

    ID: typing.Literal["updateChatUnreadMentionCount"] = field(
        default="updateChatUnreadMentionCount", metadata={"alias": "@type"}
    )
    chat_id: Int53
    unread_mention_count: Int32


@dataclass(slots=True, kw_only=True)
class UpdateChatUnreadReactionCount(BaseObject):
    """
    The chat unread_reaction_count has changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param unread_reaction_count: The number of messages with unread reactions left in the chat
    :type unread_reaction_count: :class:`Int32`
    """

    ID: typing.Literal["updateChatUnreadReactionCount"] = field(
        default="updateChatUnreadReactionCount", metadata={"alias": "@type"}
    )
    chat_id: Int53
    unread_reaction_count: Int32


@dataclass(slots=True, kw_only=True)
class UpdateChatVideoChat(BaseObject):
    """
    A chat video chat state has changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param video_chat: New value of video_chat
    :type video_chat: :class:`VideoChat`
    """

    ID: typing.Literal["updateChatVideoChat"] = field(default="updateChatVideoChat", metadata={"alias": "@type"})
    chat_id: Int53
    video_chat: VideoChat


@dataclass(slots=True, kw_only=True)
class UpdateChatViewAsTopics(BaseObject):
    """
    A chat default appearance has changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param view_as_topics: New value of view_as_topics
    :type view_as_topics: :class:`Bool`
    """

    ID: typing.Literal["updateChatViewAsTopics"] = field(default="updateChatViewAsTopics", metadata={"alias": "@type"})
    chat_id: Int53
    view_as_topics: Bool


@dataclass(slots=True, kw_only=True)
class UpdateConnectionState(BaseObject):
    """
    The connection state has changed. This update must be used only to show a human-readable description of the connection state

    :param state: The new connection state
    :type state: :class:`ConnectionState`
    """

    ID: typing.Literal["updateConnectionState"] = field(default="updateConnectionState", metadata={"alias": "@type"})
    state: ConnectionState


@dataclass(slots=True, kw_only=True)
class UpdateContactCloseBirthdays(BaseObject):
    """
    The list of contacts that had birthdays recently or will have birthday soon has changed

    :param close_birthday_users: List of contact users with close birthday
    :type close_birthday_users: :class:`Vector[CloseBirthdayUser]`
    """

    ID: typing.Literal["updateContactCloseBirthdays"] = field(
        default="updateContactCloseBirthdays", metadata={"alias": "@type"}
    )
    close_birthday_users: Vector[CloseBirthdayUser]


@dataclass(slots=True, kw_only=True)
class UpdateDefaultBackground(BaseObject):
    """
    The default background has changed

    :param background: The new default background; may be null, defaults to None
    :type background: :class:`Background`, optional
    :param for_dark_theme: True, if default background for dark theme has changed
    :type for_dark_theme: :class:`Bool`
    """

    ID: typing.Literal["updateDefaultBackground"] = field(
        default="updateDefaultBackground", metadata={"alias": "@type"}
    )
    background: typing.Optional[Background] = field(default=None)
    for_dark_theme: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class UpdateDefaultPaidReactionType(BaseObject):
    """
    The type of default paid reaction has changed

    :param type_: The new type of the default paid reaction
    :type type_: :class:`PaidReactionType`
    """

    ID: typing.Literal["updateDefaultPaidReactionType"] = field(
        default="updateDefaultPaidReactionType", metadata={"alias": "@type"}
    )
    type_: PaidReactionType = field(default=MISSING, metadata={"alias": "type"})


@dataclass(slots=True, kw_only=True)
class UpdateDefaultReactionType(BaseObject):
    """
    The type of default reaction has changed

    :param reaction_type: The new type of the default reaction
    :type reaction_type: :class:`ReactionType`
    """

    ID: typing.Literal["updateDefaultReactionType"] = field(
        default="updateDefaultReactionType", metadata={"alias": "@type"}
    )
    reaction_type: ReactionType


@dataclass(slots=True, kw_only=True)
class UpdateDeleteMessages(BaseObject):
    """
    Some messages were deleted

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param message_ids: Identifiers of the deleted messages
    :type message_ids: :class:`Vector[Int53]`
    :param is_permanent: True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible)
    :type is_permanent: :class:`Bool`
    :param from_cache: True, if the messages are deleted only from the cache and can possibly be retrieved again in the future
    :type from_cache: :class:`Bool`
    """

    ID: typing.Literal["updateDeleteMessages"] = field(default="updateDeleteMessages", metadata={"alias": "@type"})
    chat_id: Int53
    message_ids: Vector[Int53]
    is_permanent: Bool = field(default=False)
    from_cache: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class UpdateDiceEmojis(BaseObject):
    """
    The list of supported dice emojis has changed

    :param emojis: The new list of supported dice emojis
    :type emojis: :class:`Vector[String]`
    """

    ID: typing.Literal["updateDiceEmojis"] = field(default="updateDiceEmojis", metadata={"alias": "@type"})
    emojis: Vector[String]


@dataclass(slots=True, kw_only=True)
class UpdateFavoriteStickers(BaseObject):
    """
    The list of favorite stickers was updated

    :param sticker_ids: The new list of file identifiers of favorite stickers
    :type sticker_ids: :class:`Vector[Int32]`
    """

    ID: typing.Literal["updateFavoriteStickers"] = field(default="updateFavoriteStickers", metadata={"alias": "@type"})
    sticker_ids: Vector[Int32]


@dataclass(slots=True, kw_only=True)
class UpdateFile(BaseObject):
    """
    Information about a file was updated

    :param file: New data about the file
    :type file: :class:`File`
    """

    ID: typing.Literal["updateFile"] = field(default="updateFile", metadata={"alias": "@type"})
    file: File


@dataclass(slots=True, kw_only=True)
class UpdateFileAddedToDownloads(BaseObject):
    """
    A file was added to the file download list. This update is sent only after file download list is loaded for the first time

    :param file_download: The added file download
    :type file_download: :class:`FileDownload`
    :param counts: New number of being downloaded and recently downloaded files found
    :type counts: :class:`DownloadedFileCounts`
    """

    ID: typing.Literal["updateFileAddedToDownloads"] = field(
        default="updateFileAddedToDownloads", metadata={"alias": "@type"}
    )
    file_download: FileDownload
    counts: DownloadedFileCounts


@dataclass(slots=True, kw_only=True)
class UpdateFileDownload(BaseObject):
    """
    A file download was changed. This update is sent only after file download list is loaded for the first time

    :param file_id: File identifier
    :type file_id: :class:`Int32`
    :param counts: New number of being downloaded and recently downloaded files found
    :type counts: :class:`DownloadedFileCounts`
    :param complete_date: Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
    :type complete_date: :class:`Int32`
    :param is_paused: True, if downloading of the file is paused
    :type is_paused: :class:`Bool`
    """

    ID: typing.Literal["updateFileDownload"] = field(default="updateFileDownload", metadata={"alias": "@type"})
    file_id: Int32
    counts: DownloadedFileCounts
    complete_date: Int32 = field(default=0)
    is_paused: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class UpdateFileDownloads(BaseObject):
    """
    The state of the file download list has changed

    :param total_size: Total size of files in the file download list, in bytes
    :type total_size: :class:`Int53`
    :param total_count: Total number of files in the file download list
    :type total_count: :class:`Int32`
    :param downloaded_size: Total downloaded size of files in the file download list, in bytes
    :type downloaded_size: :class:`Int53`
    """

    ID: typing.Literal["updateFileDownloads"] = field(default="updateFileDownloads", metadata={"alias": "@type"})
    total_size: Int53
    total_count: Int32
    downloaded_size: Int53


@dataclass(slots=True, kw_only=True)
class UpdateFileGenerationStart(BaseObject):
    """
    The file generation process needs to be started by the application. Use setFileGenerationProgress and finishFileGeneration to generate the file

    :param generation_id: Unique identifier for the generation process
    :type generation_id: :class:`Int64`
    :param original_path: The original path specified by the application in inputFileGenerated
    :type original_path: :class:`String`
    :param destination_path: The path to a file that must be created and where the new file must be generated by the application. If the application has no access to the path, it can use writeGeneratedFilePart to generate the file
    :type destination_path: :class:`String`
    :param conversion: If the conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file that must be downloaded by the application. Otherwise, this is the conversion specified by the application in inputFileGenerated
    :type conversion: :class:`String`
    """

    ID: typing.Literal["updateFileGenerationStart"] = field(
        default="updateFileGenerationStart", metadata={"alias": "@type"}
    )
    generation_id: Int64
    original_path: String
    destination_path: String
    conversion: String


@dataclass(slots=True, kw_only=True)
class UpdateFileGenerationStop(BaseObject):
    """
    File generation is no longer needed

    :param generation_id: Unique identifier for the generation process
    :type generation_id: :class:`Int64`
    """

    ID: typing.Literal["updateFileGenerationStop"] = field(
        default="updateFileGenerationStop", metadata={"alias": "@type"}
    )
    generation_id: Int64


@dataclass(slots=True, kw_only=True)
class UpdateFileRemovedFromDownloads(BaseObject):
    """
    A file was removed from the file download list. This update is sent only after file download list is loaded for the first time

    :param file_id: File identifier
    :type file_id: :class:`Int32`
    :param counts: New number of being downloaded and recently downloaded files found
    :type counts: :class:`DownloadedFileCounts`
    """

    ID: typing.Literal["updateFileRemovedFromDownloads"] = field(
        default="updateFileRemovedFromDownloads", metadata={"alias": "@type"}
    )
    file_id: Int32
    counts: DownloadedFileCounts


@dataclass(slots=True, kw_only=True)
class UpdateForumTopicInfo(BaseObject):
    """
    Basic information about a topic in a forum chat was changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param info: New information about the topic
    :type info: :class:`ForumTopicInfo`
    """

    ID: typing.Literal["updateForumTopicInfo"] = field(default="updateForumTopicInfo", metadata={"alias": "@type"})
    chat_id: Int53
    info: ForumTopicInfo


@dataclass(slots=True, kw_only=True)
class UpdateGroupCall(BaseObject):
    """
    Information about a group call was updated

    :param group_call: New data about a group call
    :type group_call: :class:`GroupCall`
    """

    ID: typing.Literal["updateGroupCall"] = field(default="updateGroupCall", metadata={"alias": "@type"})
    group_call: GroupCall


@dataclass(slots=True, kw_only=True)
class UpdateGroupCallParticipant(BaseObject):
    """
    Information about a group call participant was changed. The updates are sent only after the group call is received through getGroupCall and only if the call is joined or being joined

    :param group_call_id: Identifier of group call
    :type group_call_id: :class:`Int32`
    :param participant: New data about a participant
    :type participant: :class:`GroupCallParticipant`
    """

    ID: typing.Literal["updateGroupCallParticipant"] = field(
        default="updateGroupCallParticipant", metadata={"alias": "@type"}
    )
    group_call_id: Int32
    participant: GroupCallParticipant


@dataclass(slots=True, kw_only=True)
class UpdateHavePendingNotifications(BaseObject):
    """
    Describes whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications

    :param have_delayed_notifications: True, if there are some delayed notification updates, which will be sent soon
    :type have_delayed_notifications: :class:`Bool`
    :param have_unreceived_notifications: True, if there can be some yet unreceived notifications, which are being fetched from the server
    :type have_unreceived_notifications: :class:`Bool`
    """

    ID: typing.Literal["updateHavePendingNotifications"] = field(
        default="updateHavePendingNotifications", metadata={"alias": "@type"}
    )
    have_delayed_notifications: Bool = field(default=False)
    have_unreceived_notifications: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class UpdateInstalledStickerSets(BaseObject):
    """
    The list of installed sticker sets was updated

    :param sticker_type: Type of the affected stickers
    :type sticker_type: :class:`StickerType`
    :param sticker_set_ids: The new list of installed ordinary sticker sets
    :type sticker_set_ids: :class:`Vector[Int64]`
    """

    ID: typing.Literal["updateInstalledStickerSets"] = field(
        default="updateInstalledStickerSets", metadata={"alias": "@type"}
    )
    sticker_type: StickerType
    sticker_set_ids: Vector[Int64]


@dataclass(slots=True, kw_only=True)
class UpdateLanguagePackStrings(BaseObject):
    """
    Some language pack strings have been updated

    :param localization_target: Localization target to which the language pack belongs
    :type localization_target: :class:`String`
    :param language_pack_id: Identifier of the updated language pack
    :type language_pack_id: :class:`String`
    :param strings: List of changed language pack strings; empty if all strings have changed
    :type strings: :class:`Vector[LanguagePackString]`
    """

    ID: typing.Literal["updateLanguagePackStrings"] = field(
        default="updateLanguagePackStrings", metadata={"alias": "@type"}
    )
    localization_target: String
    language_pack_id: String
    strings: Vector[LanguagePackString]


@dataclass(slots=True, kw_only=True)
class UpdateMessageContent(BaseObject):
    """
    The message content has changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param message_id: Message identifier
    :type message_id: :class:`Int53`
    :param new_content: New message content
    :type new_content: :class:`MessageContent`
    """

    ID: typing.Literal["updateMessageContent"] = field(default="updateMessageContent", metadata={"alias": "@type"})
    chat_id: Int53
    message_id: Int53
    new_content: MessageContent


@dataclass(slots=True, kw_only=True)
class UpdateMessageContentOpened(BaseObject):
    """
    The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the self-destruct timer

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param message_id: Message identifier
    :type message_id: :class:`Int53`
    """

    ID: typing.Literal["updateMessageContentOpened"] = field(
        default="updateMessageContentOpened", metadata={"alias": "@type"}
    )
    chat_id: Int53
    message_id: Int53


@dataclass(slots=True, kw_only=True)
class UpdateMessageEdited(BaseObject):
    """
    A message was edited. Changes in the message content will come in a separate updateMessageContent

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param message_id: Message identifier
    :type message_id: :class:`Int53`
    :param edit_date: Point in time (Unix timestamp) when the message was edited
    :type edit_date: :class:`Int32`
    :param reply_markup: New message reply markup; may be null, defaults to None
    :type reply_markup: :class:`ReplyMarkup`, optional
    """

    ID: typing.Literal["updateMessageEdited"] = field(default="updateMessageEdited", metadata={"alias": "@type"})
    chat_id: Int53
    message_id: Int53
    edit_date: Int32
    reply_markup: typing.Optional[ReplyMarkup] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateMessageFactCheck(BaseObject):
    """
    A fact-check added to a message was changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param message_id: Message identifier
    :type message_id: :class:`Int53`
    :param fact_check: The new fact-check
    :type fact_check: :class:`FactCheck`
    """

    ID: typing.Literal["updateMessageFactCheck"] = field(default="updateMessageFactCheck", metadata={"alias": "@type"})
    chat_id: Int53
    message_id: Int53
    fact_check: FactCheck


@dataclass(slots=True, kw_only=True)
class UpdateMessageInteractionInfo(BaseObject):
    """
    The information about interactions with a message has changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param message_id: Message identifier
    :type message_id: :class:`Int53`
    :param interaction_info: New information about interactions with the message; may be null, defaults to None
    :type interaction_info: :class:`MessageInteractionInfo`, optional
    """

    ID: typing.Literal["updateMessageInteractionInfo"] = field(
        default="updateMessageInteractionInfo", metadata={"alias": "@type"}
    )
    chat_id: Int53
    message_id: Int53
    interaction_info: typing.Optional[MessageInteractionInfo] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateMessageIsPinned(BaseObject):
    """
    The message pinned state was changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param message_id: The message identifier
    :type message_id: :class:`Int53`
    :param is_pinned: True, if the message is pinned
    :type is_pinned: :class:`Bool`
    """

    ID: typing.Literal["updateMessageIsPinned"] = field(default="updateMessageIsPinned", metadata={"alias": "@type"})
    chat_id: Int53
    message_id: Int53
    is_pinned: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class UpdateMessageLiveLocationViewed(BaseObject):
    """
    A message with a live location was viewed. When the update is received, the application is expected to update the live location

    :param chat_id: Identifier of the chat with the live location message
    :type chat_id: :class:`Int53`
    :param message_id: Identifier of the message with live location
    :type message_id: :class:`Int53`
    """

    ID: typing.Literal["updateMessageLiveLocationViewed"] = field(
        default="updateMessageLiveLocationViewed", metadata={"alias": "@type"}
    )
    chat_id: Int53
    message_id: Int53


@dataclass(slots=True, kw_only=True)
class UpdateMessageMentionRead(BaseObject):
    """
    A message with an unread mention was read

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param message_id: Message identifier
    :type message_id: :class:`Int53`
    :param unread_mention_count: The new number of unread mention messages left in the chat
    :type unread_mention_count: :class:`Int32`
    """

    ID: typing.Literal["updateMessageMentionRead"] = field(
        default="updateMessageMentionRead", metadata={"alias": "@type"}
    )
    chat_id: Int53
    message_id: Int53
    unread_mention_count: Int32


@dataclass(slots=True, kw_only=True)
class UpdateMessageReaction(BaseObject):
    """
    User changed its reactions on a message with public reactions; for bots only

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param message_id: Message identifier
    :type message_id: :class:`Int53`
    :param actor_id: Identifier of the user or chat that changed reactions
    :type actor_id: :class:`MessageSender`
    :param date: Point in time (Unix timestamp) when the reactions were changed
    :type date: :class:`Int32`
    :param old_reaction_types: Old list of chosen reactions
    :type old_reaction_types: :class:`Vector[ReactionType]`
    :param new_reaction_types: New list of chosen reactions
    :type new_reaction_types: :class:`Vector[ReactionType]`
    """

    ID: typing.Literal["updateMessageReaction"] = field(default="updateMessageReaction", metadata={"alias": "@type"})
    chat_id: Int53
    message_id: Int53
    actor_id: MessageSender
    date: Int32
    old_reaction_types: Vector[ReactionType]
    new_reaction_types: Vector[ReactionType]


@dataclass(slots=True, kw_only=True)
class UpdateMessageReactions(BaseObject):
    """
    Reactions added to a message with anonymous reactions have changed; for bots only

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param message_id: Message identifier
    :type message_id: :class:`Int53`
    :param date: Point in time (Unix timestamp) when the reactions were changed
    :type date: :class:`Int32`
    :param reactions: The list of reactions added to the message
    :type reactions: :class:`Vector[MessageReaction]`
    """

    ID: typing.Literal["updateMessageReactions"] = field(default="updateMessageReactions", metadata={"alias": "@type"})
    chat_id: Int53
    message_id: Int53
    date: Int32
    reactions: Vector[MessageReaction]


@dataclass(slots=True, kw_only=True)
class UpdateMessageSendAcknowledged(BaseObject):
    """
    A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully. This update is sent only if the option "use_quick_ack" is set to true. This update may be sent multiple times for the same message

    :param chat_id: The chat identifier of the sent message
    :type chat_id: :class:`Int53`
    :param message_id: A temporary message identifier
    :type message_id: :class:`Int53`
    """

    ID: typing.Literal["updateMessageSendAcknowledged"] = field(
        default="updateMessageSendAcknowledged", metadata={"alias": "@type"}
    )
    chat_id: Int53
    message_id: Int53


@dataclass(slots=True, kw_only=True)
class UpdateMessageSendFailed(BaseObject):
    """
    A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case updateDeleteMessages will be received instead of this update

    :param message: The failed to send message
    :type message: :class:`Message`
    :param old_message_id: The previous temporary message identifier
    :type old_message_id: :class:`Int53`
    :param error: The cause of the message sending failure
    :type error: :class:`Error`
    """

    ID: typing.Literal["updateMessageSendFailed"] = field(
        default="updateMessageSendFailed", metadata={"alias": "@type"}
    )
    message: Message
    old_message_id: Int53
    error: Error


@dataclass(slots=True, kw_only=True)
class UpdateMessageSendSucceeded(BaseObject):
    """
    A message has been successfully sent

    :param message: The sent message. Almost any field of the new message can be different from the corresponding field of the original message. For example, the field scheduling_state may change, making the message scheduled, or non-scheduled
    :type message: :class:`Message`
    :param old_message_id: The previous temporary message identifier
    :type old_message_id: :class:`Int53`
    """

    ID: typing.Literal["updateMessageSendSucceeded"] = field(
        default="updateMessageSendSucceeded", metadata={"alias": "@type"}
    )
    message: Message
    old_message_id: Int53


@dataclass(slots=True, kw_only=True)
class UpdateMessageUnreadReactions(BaseObject):
    """
    The list of unread reactions added to a message was changed

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param message_id: Message identifier
    :type message_id: :class:`Int53`
    :param unread_reactions: The new list of unread reactions
    :type unread_reactions: :class:`Vector[UnreadReaction]`
    :param unread_reaction_count: The new number of messages with unread reactions left in the chat
    :type unread_reaction_count: :class:`Int32`
    """

    ID: typing.Literal["updateMessageUnreadReactions"] = field(
        default="updateMessageUnreadReactions", metadata={"alias": "@type"}
    )
    chat_id: Int53
    message_id: Int53
    unread_reactions: Vector[UnreadReaction]
    unread_reaction_count: Int32


@dataclass(slots=True, kw_only=True)
class UpdateNewBusinessCallbackQuery(BaseObject):
    """
    A new incoming callback query from a business message; for bots only

    :param id: Unique query identifier
    :type id: :class:`Int64`
    :param sender_user_id: Identifier of the user who sent the query
    :type sender_user_id: :class:`Int53`
    :param connection_id: Unique identifier of the business connection
    :type connection_id: :class:`String`
    :param message: The message from the business account from which the query originated
    :type message: :class:`BusinessMessage`
    :param chat_instance: An identifier uniquely corresponding to the chat a message was sent to
    :type chat_instance: :class:`Int64`
    :param payload: Query payload
    :type payload: :class:`CallbackQueryPayload`
    """

    ID: typing.Literal["updateNewBusinessCallbackQuery"] = field(
        default="updateNewBusinessCallbackQuery", metadata={"alias": "@type"}
    )
    id: Int64
    sender_user_id: Int53
    connection_id: String
    message: BusinessMessage
    chat_instance: Int64
    payload: CallbackQueryPayload


@dataclass(slots=True, kw_only=True)
class UpdateNewBusinessMessage(BaseObject):
    """
    A new message was added to a business account; for bots only

    :param connection_id: Unique identifier of the business connection
    :type connection_id: :class:`String`
    :param message: The new message
    :type message: :class:`BusinessMessage`
    """

    ID: typing.Literal["updateNewBusinessMessage"] = field(
        default="updateNewBusinessMessage", metadata={"alias": "@type"}
    )
    connection_id: String
    message: BusinessMessage


@dataclass(slots=True, kw_only=True)
class UpdateNewCallSignalingData(BaseObject):
    """
    New call signaling data arrived

    :param call_id: The call identifier
    :type call_id: :class:`Int32`
    :param data: The data
    :type data: :class:`Bytes`
    """

    ID: typing.Literal["updateNewCallSignalingData"] = field(
        default="updateNewCallSignalingData", metadata={"alias": "@type"}
    )
    call_id: Int32
    data: Bytes


@dataclass(slots=True, kw_only=True)
class UpdateNewCallbackQuery(BaseObject):
    """
    A new incoming callback query; for bots only

    :param id: Unique query identifier
    :type id: :class:`Int64`
    :param sender_user_id: Identifier of the user who sent the query
    :type sender_user_id: :class:`Int53`
    :param chat_id: Identifier of the chat where the query was sent
    :type chat_id: :class:`Int53`
    :param message_id: Identifier of the message from which the query originated
    :type message_id: :class:`Int53`
    :param chat_instance: Identifier that uniquely corresponds to the chat to which the message was sent
    :type chat_instance: :class:`Int64`
    :param payload: Query payload
    :type payload: :class:`CallbackQueryPayload`
    """

    ID: typing.Literal["updateNewCallbackQuery"] = field(default="updateNewCallbackQuery", metadata={"alias": "@type"})
    id: Int64
    sender_user_id: Int53
    chat_id: Int53
    message_id: Int53
    chat_instance: Int64
    payload: CallbackQueryPayload


@dataclass(slots=True, kw_only=True)
class UpdateNewChat(BaseObject):
    """
    A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the application. The chat field changes will be reported through separate updates

    :param chat: The chat
    :type chat: :class:`Chat`
    """

    ID: typing.Literal["updateNewChat"] = field(default="updateNewChat", metadata={"alias": "@type"})
    chat: Chat


@dataclass(slots=True, kw_only=True)
class UpdateNewChatJoinRequest(BaseObject):
    """
    A user sent a join request to a chat; for bots only

    :param chat_id: Chat identifier
    :type chat_id: :class:`Int53`
    :param request: Join request
    :type request: :class:`ChatJoinRequest`
    :param user_chat_id: Chat identifier of the private chat with the user
    :type user_chat_id: :class:`Int53`
    :param invite_link: The invite link, which was used to send join request; may be null, defaults to None
    :type invite_link: :class:`ChatInviteLink`, optional
    """

    ID: typing.Literal["updateNewChatJoinRequest"] = field(
        default="updateNewChatJoinRequest", metadata={"alias": "@type"}
    )
    chat_id: Int53
    request: ChatJoinRequest
    user_chat_id: Int53
    invite_link: typing.Optional[ChatInviteLink] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateNewChosenInlineResult(BaseObject):
    """
    The user has chosen a result of an inline query; for bots only

    :param sender_user_id: Identifier of the user who sent the query
    :type sender_user_id: :class:`Int53`
    :param query: Text of the query
    :type query: :class:`String`
    :param result_id: Identifier of the chosen result
    :type result_id: :class:`String`
    :param inline_message_id: Identifier of the sent inline message, if known
    :type inline_message_id: :class:`String`
    :param user_location: User location; may be null, defaults to None
    :type user_location: :class:`Location`, optional
    """

    ID: typing.Literal["updateNewChosenInlineResult"] = field(
        default="updateNewChosenInlineResult", metadata={"alias": "@type"}
    )
    sender_user_id: Int53
    query: String
    result_id: String
    inline_message_id: String
    user_location: typing.Optional[Location] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateNewCustomEvent(BaseObject):
    """
    A new incoming event; for bots only

    :param event: A JSON-serialized event
    :type event: :class:`String`
    """

    ID: typing.Literal["updateNewCustomEvent"] = field(default="updateNewCustomEvent", metadata={"alias": "@type"})
    event: String


@dataclass(slots=True, kw_only=True)
class UpdateNewCustomQuery(BaseObject):
    """
    A new incoming query; for bots only

    :param id: The query identifier
    :type id: :class:`Int64`
    :param data: JSON-serialized query data
    :type data: :class:`String`
    :param timeout: Query timeout
    :type timeout: :class:`Int32`
    """

    ID: typing.Literal["updateNewCustomQuery"] = field(default="updateNewCustomQuery", metadata={"alias": "@type"})
    id: Int64
    data: String
    timeout: Int32


@dataclass(slots=True, kw_only=True)
class UpdateNewInlineCallbackQuery(BaseObject):
    """
    A new incoming callback query from a message sent via a bot; for bots only

    :param id: Unique query identifier
    :type id: :class:`Int64`
    :param sender_user_id: Identifier of the user who sent the query
    :type sender_user_id: :class:`Int53`
    :param inline_message_id: Identifier of the inline message from which the query originated
    :type inline_message_id: :class:`String`
    :param chat_instance: An identifier uniquely corresponding to the chat a message was sent to
    :type chat_instance: :class:`Int64`
    :param payload: Query payload
    :type payload: :class:`CallbackQueryPayload`
    """

    ID: typing.Literal["updateNewInlineCallbackQuery"] = field(
        default="updateNewInlineCallbackQuery", metadata={"alias": "@type"}
    )
    id: Int64
    sender_user_id: Int53
    inline_message_id: String
    chat_instance: Int64
    payload: CallbackQueryPayload


@dataclass(slots=True, kw_only=True)
class UpdateNewInlineQuery(BaseObject):
    """
    A new incoming inline query; for bots only

    :param id: Unique query identifier
    :type id: :class:`Int64`
    :param sender_user_id: Identifier of the user who sent the query
    :type sender_user_id: :class:`Int53`
    :param query: Text of the query
    :type query: :class:`String`
    :param offset: Offset of the first entry to return
    :type offset: :class:`String`
    :param user_location: User location; may be null, defaults to None
    :type user_location: :class:`Location`, optional
    :param chat_type: The type of the chat from which the query originated; may be null if unknown, defaults to None
    :type chat_type: :class:`ChatType`, optional
    """

    ID: typing.Literal["updateNewInlineQuery"] = field(default="updateNewInlineQuery", metadata={"alias": "@type"})
    id: Int64
    sender_user_id: Int53
    query: String
    offset: String
    user_location: typing.Optional[Location] = field(default=None)
    chat_type: typing.Optional[ChatType] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateNewMessage(BaseObject):
    """
    A new message was received; can also be an outgoing message

    :param message: The new message
    :type message: :class:`Message`
    """

    ID: typing.Literal["updateNewMessage"] = field(default="updateNewMessage", metadata={"alias": "@type"})
    message: Message


@dataclass(slots=True, kw_only=True)
class UpdateNewPreCheckoutQuery(BaseObject):
    """
    A new incoming pre-checkout query; for bots only. Contains full information about a checkout

    :param id: Unique query identifier
    :type id: :class:`Int64`
    :param sender_user_id: Identifier of the user who sent the query
    :type sender_user_id: :class:`Int53`
    :param currency: Currency for the product price
    :type currency: :class:`String`
    :param total_amount: Total price for the product, in the smallest units of the currency
    :type total_amount: :class:`Int53`
    :param invoice_payload: Invoice payload
    :type invoice_payload: :class:`Bytes`
    :param order_info: Information about the order; may be null, defaults to None
    :type order_info: :class:`OrderInfo`, optional
    :param shipping_option_id: Identifier of a shipping option chosen by the user; may be empty if not applicable
    :type shipping_option_id: :class:`String`
    """

    ID: typing.Literal["updateNewPreCheckoutQuery"] = field(
        default="updateNewPreCheckoutQuery", metadata={"alias": "@type"}
    )
    id: Int64
    sender_user_id: Int53
    currency: String
    total_amount: Int53
    invoice_payload: Bytes
    order_info: typing.Optional[OrderInfo] = field(default=None)
    shipping_option_id: String = field(default="")


@dataclass(slots=True, kw_only=True)
class UpdateNewShippingQuery(BaseObject):
    """
    A new incoming shipping query; for bots only. Only for invoices with flexible price

    :param id: Unique query identifier
    :type id: :class:`Int64`
    :param sender_user_id: Identifier of the user who sent the query
    :type sender_user_id: :class:`Int53`
    :param invoice_payload: Invoice payload
    :type invoice_payload: :class:`String`
    :param shipping_address: User shipping address
    :type shipping_address: :class:`Address`
    """

    ID: typing.Literal["updateNewShippingQuery"] = field(default="updateNewShippingQuery", metadata={"alias": "@type"})
    id: Int64
    sender_user_id: Int53
    invoice_payload: String
    shipping_address: Address


@dataclass(slots=True, kw_only=True)
class UpdateNotification(BaseObject):
    """
    A notification was changed

    :param notification_group_id: Unique notification group identifier
    :type notification_group_id: :class:`Int32`
    :param notification: Changed notification
    :type notification: :class:`Notification`
    """

    ID: typing.Literal["updateNotification"] = field(default="updateNotification", metadata={"alias": "@type"})
    notification_group_id: Int32
    notification: Notification


@dataclass(slots=True, kw_only=True)
class UpdateNotificationGroup(BaseObject):
    """
    A list of active notifications in a notification group has changed

    :param notification_group_id: Unique notification group identifier
    :type notification_group_id: :class:`Int32`
    :param type_: New type of the notification group
    :type type_: :class:`NotificationGroupType`
    :param chat_id: Identifier of a chat to which all notifications in the group belong
    :type chat_id: :class:`Int53`
    :param notification_settings_chat_id: Chat identifier, which notification settings must be applied to the added notifications
    :type notification_settings_chat_id: :class:`Int53`
    :param total_count: Total number of unread notifications in the group, can be bigger than number of active notifications
    :type total_count: :class:`Int32`
    :param added_notifications: List of added group notifications, sorted by notification identifier
    :type added_notifications: :class:`Vector[Notification]`
    :param removed_notification_ids: Identifiers of removed group notifications, sorted by notification identifier
    :type removed_notification_ids: :class:`Vector[Int32]`
    :param notification_sound_id: Identifier of the notification sound to be played; 0 if sound is disabled
    :type notification_sound_id: :class:`Int64`
    """

    ID: typing.Literal["updateNotificationGroup"] = field(
        default="updateNotificationGroup", metadata={"alias": "@type"}
    )
    notification_group_id: Int32
    type_: NotificationGroupType = field(default=MISSING, metadata={"alias": "type"})
    chat_id: Int53
    notification_settings_chat_id: Int53
    total_count: Int32
    added_notifications: Vector[Notification]
    removed_notification_ids: Vector[Int32]
    notification_sound_id: Int64 = field(default=0)


@dataclass(slots=True, kw_only=True)
class UpdateOption(BaseObject):
    """
    An option changed its value

    :param name: The option name
    :type name: :class:`String`
    :param value: The new option value
    :type value: :class:`OptionValue`
    """

    ID: typing.Literal["updateOption"] = field(default="updateOption", metadata={"alias": "@type"})
    name: String
    value: OptionValue


@dataclass(slots=True, kw_only=True)
class UpdateOwnedStarCount(BaseObject):
    """
    The number of Telegram Stars owned by the current user has changed

    :param star_amount: The new amount of owned Telegram Stars
    :type star_amount: :class:`StarAmount`
    """

    ID: typing.Literal["updateOwnedStarCount"] = field(default="updateOwnedStarCount", metadata={"alias": "@type"})
    star_amount: StarAmount


@dataclass(slots=True, kw_only=True)
class UpdatePaidMediaPurchased(BaseObject):
    """
    Paid media were purchased by a user; for bots only

    :param user_id: User identifier
    :type user_id: :class:`Int53`
    :param payload: Bot-specified payload for the paid media
    :type payload: :class:`String`
    """

    ID: typing.Literal["updatePaidMediaPurchased"] = field(
        default="updatePaidMediaPurchased", metadata={"alias": "@type"}
    )
    user_id: Int53
    payload: String


@dataclass(slots=True, kw_only=True)
class UpdatePoll(BaseObject):
    """
    A poll was updated; for bots only

    :param poll: New data about the poll
    :type poll: :class:`Poll`
    """

    ID: typing.Literal["updatePoll"] = field(default="updatePoll", metadata={"alias": "@type"})
    poll: Poll


@dataclass(slots=True, kw_only=True)
class UpdatePollAnswer(BaseObject):
    """
    A user changed the answer to a poll; for bots only

    :param poll_id: Unique poll identifier
    :type poll_id: :class:`Int64`
    :param voter_id: Identifier of the message sender that changed the answer to the poll
    :type voter_id: :class:`MessageSender`
    :param option_ids: 0-based identifiers of answer options, chosen by the user
    :type option_ids: :class:`Vector[Int32]`
    """

    ID: typing.Literal["updatePollAnswer"] = field(default="updatePollAnswer", metadata={"alias": "@type"})
    poll_id: Int64
    voter_id: MessageSender
    option_ids: Vector[Int32]


@dataclass(slots=True, kw_only=True)
class UpdateProfileAccentColors(BaseObject):
    """
    The list of supported accent colors for user profiles has changed

    :param colors: Information about supported colors
    :type colors: :class:`Vector[ProfileAccentColor]`
    :param available_accent_color_ids: The list of accent color identifiers, which can be set through setProfileAccentColor and setChatProfileAccentColor. The colors must be shown in the specified order
    :type available_accent_color_ids: :class:`Vector[Int32]`
    """

    ID: typing.Literal["updateProfileAccentColors"] = field(
        default="updateProfileAccentColors", metadata={"alias": "@type"}
    )
    colors: Vector[ProfileAccentColor]
    available_accent_color_ids: Vector[Int32]


@dataclass(slots=True, kw_only=True)
class UpdateQuickReplyShortcut(BaseObject):
    """
    Basic information about a quick reply shortcut has changed. This update is guaranteed to come before the quick shortcut name is returned to the application

    :param shortcut: New data about the shortcut
    :type shortcut: :class:`QuickReplyShortcut`
    """

    ID: typing.Literal["updateQuickReplyShortcut"] = field(
        default="updateQuickReplyShortcut", metadata={"alias": "@type"}
    )
    shortcut: QuickReplyShortcut


@dataclass(slots=True, kw_only=True)
class UpdateQuickReplyShortcutDeleted(BaseObject):
    """
    A quick reply shortcut and all its messages were deleted

    :param shortcut_id: The identifier of the deleted shortcut
    :type shortcut_id: :class:`Int32`
    """

    ID: typing.Literal["updateQuickReplyShortcutDeleted"] = field(
        default="updateQuickReplyShortcutDeleted", metadata={"alias": "@type"}
    )
    shortcut_id: Int32


@dataclass(slots=True, kw_only=True)
class UpdateQuickReplyShortcutMessages(BaseObject):
    """
    The list of quick reply shortcut messages has changed

    :param shortcut_id: The identifier of the shortcut
    :type shortcut_id: :class:`Int32`
    :param messages: The new list of quick reply messages for the shortcut in order from the first to the last sent
    :type messages: :class:`Vector[QuickReplyMessage]`
    """

    ID: typing.Literal["updateQuickReplyShortcutMessages"] = field(
        default="updateQuickReplyShortcutMessages", metadata={"alias": "@type"}
    )
    shortcut_id: Int32
    messages: Vector[QuickReplyMessage]


@dataclass(slots=True, kw_only=True)
class UpdateQuickReplyShortcuts(BaseObject):
    """
    The list of quick reply shortcuts has changed

    :param shortcut_ids: The new list of identifiers of quick reply shortcuts
    :type shortcut_ids: :class:`Vector[Int32]`
    """

    ID: typing.Literal["updateQuickReplyShortcuts"] = field(
        default="updateQuickReplyShortcuts", metadata={"alias": "@type"}
    )
    shortcut_ids: Vector[Int32]


@dataclass(slots=True, kw_only=True)
class UpdateReactionNotificationSettings(BaseObject):
    """
    Notification settings for reactions were updated

    :param notification_settings: The new notification settings
    :type notification_settings: :class:`ReactionNotificationSettings`
    """

    ID: typing.Literal["updateReactionNotificationSettings"] = field(
        default="updateReactionNotificationSettings", metadata={"alias": "@type"}
    )
    notification_settings: ReactionNotificationSettings


@dataclass(slots=True, kw_only=True)
class UpdateRecentStickers(BaseObject):
    """
    The list of recently used stickers was updated

    :param sticker_ids: The new list of file identifiers of recently used stickers
    :type sticker_ids: :class:`Vector[Int32]`
    :param is_attached: True, if the list of stickers attached to photo or video files was updated; otherwise, the list of sent stickers is updated
    :type is_attached: :class:`Bool`
    """

    ID: typing.Literal["updateRecentStickers"] = field(default="updateRecentStickers", metadata={"alias": "@type"})
    sticker_ids: Vector[Int32]
    is_attached: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class UpdateSavedAnimations(BaseObject):
    """
    The list of saved animations was updated

    :param animation_ids: The new list of file identifiers of saved animations
    :type animation_ids: :class:`Vector[Int32]`
    """

    ID: typing.Literal["updateSavedAnimations"] = field(default="updateSavedAnimations", metadata={"alias": "@type"})
    animation_ids: Vector[Int32]


@dataclass(slots=True, kw_only=True)
class UpdateSavedMessagesTags(BaseObject):
    """
    Tags used in Saved Messages or a Saved Messages topic have changed

    :param tags: The new tags
    :type tags: :class:`SavedMessagesTags`
    :param saved_messages_topic_id: Identifier of Saved Messages topic which tags were changed; 0 if tags for the whole chat has changed
    :type saved_messages_topic_id: :class:`Int53`
    """

    ID: typing.Literal["updateSavedMessagesTags"] = field(
        default="updateSavedMessagesTags", metadata={"alias": "@type"}
    )
    tags: SavedMessagesTags
    saved_messages_topic_id: Int53 = field(default=0)


@dataclass(slots=True, kw_only=True)
class UpdateSavedMessagesTopic(BaseObject):
    """
    Basic information about a Saved Messages topic has changed. This update is guaranteed to come before the topic identifier is returned to the application

    :param topic: New data about the topic
    :type topic: :class:`SavedMessagesTopic`
    """

    ID: typing.Literal["updateSavedMessagesTopic"] = field(
        default="updateSavedMessagesTopic", metadata={"alias": "@type"}
    )
    topic: SavedMessagesTopic


@dataclass(slots=True, kw_only=True)
class UpdateSavedMessagesTopicCount(BaseObject):
    """
    Number of Saved Messages topics has changed

    :param topic_count: Approximate total number of Saved Messages topics
    :type topic_count: :class:`Int32`
    """

    ID: typing.Literal["updateSavedMessagesTopicCount"] = field(
        default="updateSavedMessagesTopicCount", metadata={"alias": "@type"}
    )
    topic_count: Int32


@dataclass(slots=True, kw_only=True)
class UpdateSavedNotificationSounds(BaseObject):
    """
    The list of saved notification sounds was updated. This update may not be sent until information about a notification sound was requested for the first time

    :param notification_sound_ids: The new list of identifiers of saved notification sounds
    :type notification_sound_ids: :class:`Vector[Int64]`
    """

    ID: typing.Literal["updateSavedNotificationSounds"] = field(
        default="updateSavedNotificationSounds", metadata={"alias": "@type"}
    )
    notification_sound_ids: Vector[Int64]


@dataclass(slots=True, kw_only=True)
class UpdateScopeNotificationSettings(BaseObject):
    """
    Notification settings for some type of chats were updated

    :param scope: Types of chats for which notification settings were updated
    :type scope: :class:`NotificationSettingsScope`
    :param notification_settings: The new notification settings
    :type notification_settings: :class:`ScopeNotificationSettings`
    """

    ID: typing.Literal["updateScopeNotificationSettings"] = field(
        default="updateScopeNotificationSettings", metadata={"alias": "@type"}
    )
    scope: NotificationSettingsScope
    notification_settings: ScopeNotificationSettings


@dataclass(slots=True, kw_only=True)
class UpdateSecretChat(BaseObject):
    """
    Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the application

    :param secret_chat: New data about the secret chat
    :type secret_chat: :class:`SecretChat`
    """

    ID: typing.Literal["updateSecretChat"] = field(default="updateSecretChat", metadata={"alias": "@type"})
    secret_chat: SecretChat


@dataclass(slots=True, kw_only=True)
class UpdateServiceNotification(BaseObject):
    """
    A service notification from the server was received. Upon receiving this the application must show a popup with the content of the notification

    :param type_: Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" must be shown under notification; if user presses the second, all local data must be destroyed using Destroy method
    :type type_: :class:`String`
    :param content: Notification content
    :type content: :class:`MessageContent`
    """

    ID: typing.Literal["updateServiceNotification"] = field(
        default="updateServiceNotification", metadata={"alias": "@type"}
    )
    type_: String = field(default=MISSING, metadata={"alias": "type"})
    content: MessageContent


@dataclass(slots=True, kw_only=True)
class UpdateSpeechRecognitionTrial(BaseObject):
    """
    The parameters of speech recognition without Telegram Premium subscription has changed

    :param max_media_duration: The maximum allowed duration of media for speech recognition without Telegram Premium subscription, in seconds
    :type max_media_duration: :class:`Int32`
    :param left_count: Number of left speech recognition attempts this week
    :type left_count: :class:`Int32`
    :param weekly_count: The total number of allowed speech recognitions per week; 0 if none, defaults to None
    :type weekly_count: :class:`Int32`, optional
    :param next_reset_date: Point in time (Unix timestamp) when the weekly number of tries will reset; 0 if unknown, defaults to None
    :type next_reset_date: :class:`Int32`, optional
    """

    ID: typing.Literal["updateSpeechRecognitionTrial"] = field(
        default="updateSpeechRecognitionTrial", metadata={"alias": "@type"}
    )
    max_media_duration: Int32
    left_count: Int32
    weekly_count: typing.Optional[Int32] = field(default=0)
    next_reset_date: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class UpdateSpeedLimitNotification(BaseObject):
    """
    Download or upload file speed for the user was limited, but it can be restored by subscription to Telegram Premium. The notification can be postponed until a being downloaded or uploaded file is visible to the user. Use getOption("premium_download_speedup") or getOption("premium_upload_speedup") to get expected speedup after subscription to Telegram Premium

    :param is_upload: True, if upload speed was limited; false, if download speed was limited
    :type is_upload: :class:`Bool`
    """

    ID: typing.Literal["updateSpeedLimitNotification"] = field(
        default="updateSpeedLimitNotification", metadata={"alias": "@type"}
    )
    is_upload: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class UpdateStarRevenueStatus(BaseObject):
    """
    The Telegram Star revenue earned by a bot or a chat has changed. If Telegram Star transaction screen of the chat is opened, then getStarTransactions may be called to fetch new transactions

    :param owner_id: Identifier of the owner of the Telegram Stars
    :type owner_id: :class:`MessageSender`
    :param status: New Telegram Star revenue status
    :type status: :class:`StarRevenueStatus`
    """

    ID: typing.Literal["updateStarRevenueStatus"] = field(
        default="updateStarRevenueStatus", metadata={"alias": "@type"}
    )
    owner_id: MessageSender
    status: StarRevenueStatus


@dataclass(slots=True, kw_only=True)
class UpdateStickerSet(BaseObject):
    """
    A sticker set has changed

    :param sticker_set: The sticker set
    :type sticker_set: :class:`StickerSet`
    """

    ID: typing.Literal["updateStickerSet"] = field(default="updateStickerSet", metadata={"alias": "@type"})
    sticker_set: StickerSet


@dataclass(slots=True, kw_only=True)
class UpdateStory(BaseObject):
    """
    A story was changed

    :param story: The new information about the story
    :type story: :class:`Story`
    """

    ID: typing.Literal["updateStory"] = field(default="updateStory", metadata={"alias": "@type"})
    story: Story


@dataclass(slots=True, kw_only=True)
class UpdateStoryDeleted(BaseObject):
    """
    A story became inaccessible

    :param story_sender_chat_id: Identifier of the chat that posted the story
    :type story_sender_chat_id: :class:`Int53`
    :param story_id: Story identifier
    :type story_id: :class:`Int32`
    """

    ID: typing.Literal["updateStoryDeleted"] = field(default="updateStoryDeleted", metadata={"alias": "@type"})
    story_sender_chat_id: Int53
    story_id: Int32


@dataclass(slots=True, kw_only=True)
class UpdateStoryListChatCount(BaseObject):
    """
    Number of chats in a story list has changed

    :param story_list: The story list
    :type story_list: :class:`StoryList`
    :param chat_count: Approximate total number of chats with active stories in the list
    :type chat_count: :class:`Int32`
    """

    ID: typing.Literal["updateStoryListChatCount"] = field(
        default="updateStoryListChatCount", metadata={"alias": "@type"}
    )
    story_list: StoryList
    chat_count: Int32


@dataclass(slots=True, kw_only=True)
class UpdateStorySendFailed(BaseObject):
    """
    A story failed to send. If the story sending is canceled, then updateStoryDeleted will be received instead of this update

    :param story: The failed to send story
    :type story: :class:`Story`
    :param error: The cause of the story sending failure
    :type error: :class:`Error`
    :param error_type: Type of the error; may be null if unknown, defaults to None
    :type error_type: :class:`CanSendStoryResult`, optional
    """

    ID: typing.Literal["updateStorySendFailed"] = field(default="updateStorySendFailed", metadata={"alias": "@type"})
    story: Story
    error: Error
    error_type: typing.Optional[CanSendStoryResult] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateStorySendSucceeded(BaseObject):
    """
    A story has been successfully sent

    :param story: The sent story
    :type story: :class:`Story`
    :param old_story_id: The previous temporary story identifier
    :type old_story_id: :class:`Int32`
    """

    ID: typing.Literal["updateStorySendSucceeded"] = field(
        default="updateStorySendSucceeded", metadata={"alias": "@type"}
    )
    story: Story
    old_story_id: Int32


@dataclass(slots=True, kw_only=True)
class UpdateStoryStealthMode(BaseObject):
    """
    Story stealth mode settings have changed

    :param active_until_date: Point in time (Unix timestamp) until stealth mode is active; 0 if it is disabled
    :type active_until_date: :class:`Int32`
    :param cooldown_until_date: Point in time (Unix timestamp) when stealth mode can be enabled again; 0 if there is no active cooldown
    :type cooldown_until_date: :class:`Int32`
    """

    ID: typing.Literal["updateStoryStealthMode"] = field(default="updateStoryStealthMode", metadata={"alias": "@type"})
    active_until_date: Int32 = field(default=0)
    cooldown_until_date: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class UpdateSuggestedActions(BaseObject):
    """
    The list of suggested to the user actions has changed

    :param added_actions: Added suggested actions
    :type added_actions: :class:`Vector[SuggestedAction]`
    :param removed_actions: Removed suggested actions
    :type removed_actions: :class:`Vector[SuggestedAction]`
    """

    ID: typing.Literal["updateSuggestedActions"] = field(default="updateSuggestedActions", metadata={"alias": "@type"})
    added_actions: Vector[SuggestedAction]
    removed_actions: Vector[SuggestedAction]


@dataclass(slots=True, kw_only=True)
class UpdateSupergroup(BaseObject):
    """
    Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the application

    :param supergroup: New data about the supergroup
    :type supergroup: :class:`Supergroup`
    """

    ID: typing.Literal["updateSupergroup"] = field(default="updateSupergroup", metadata={"alias": "@type"})
    supergroup: Supergroup


@dataclass(slots=True, kw_only=True)
class UpdateSupergroupFullInfo(BaseObject):
    """
    Some data in supergroupFullInfo has been changed

    :param supergroup_id: Identifier of the supergroup or channel
    :type supergroup_id: :class:`Int53`
    :param supergroup_full_info: New full information about the supergroup
    :type supergroup_full_info: :class:`SupergroupFullInfo`
    """

    ID: typing.Literal["updateSupergroupFullInfo"] = field(
        default="updateSupergroupFullInfo", metadata={"alias": "@type"}
    )
    supergroup_id: Int53
    supergroup_full_info: SupergroupFullInfo


@dataclass(slots=True, kw_only=True)
class UpdateTermsOfService(BaseObject):
    """
    New terms of service must be accepted by the user. If the terms of service are declined, then the deleteAccount method must be called with the reason "Decline ToS update"

    :param terms_of_service_id: Identifier of the terms of service
    :type terms_of_service_id: :class:`String`
    :param terms_of_service: The new terms of service
    :type terms_of_service: :class:`TermsOfService`
    """

    ID: typing.Literal["updateTermsOfService"] = field(default="updateTermsOfService", metadata={"alias": "@type"})
    terms_of_service_id: String
    terms_of_service: TermsOfService


@dataclass(slots=True, kw_only=True)
class UpdateTrendingStickerSets(BaseObject):
    """
    The list of trending sticker sets was updated or some of them were viewed

    :param sticker_type: Type of the affected stickers
    :type sticker_type: :class:`StickerType`
    :param sticker_sets: The prefix of the list of trending sticker sets with the newest trending sticker sets
    :type sticker_sets: :class:`TrendingStickerSets`
    """

    ID: typing.Literal["updateTrendingStickerSets"] = field(
        default="updateTrendingStickerSets", metadata={"alias": "@type"}
    )
    sticker_type: StickerType
    sticker_sets: TrendingStickerSets


@dataclass(slots=True, kw_only=True)
class UpdateUnconfirmedSession(BaseObject):
    """
    The first unconfirmed session has changed

    :param session: The unconfirmed session; may be null if none, defaults to None
    :type session: :class:`UnconfirmedSession`, optional
    """

    ID: typing.Literal["updateUnconfirmedSession"] = field(
        default="updateUnconfirmedSession", metadata={"alias": "@type"}
    )
    session: typing.Optional[UnconfirmedSession] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpdateUnreadChatCount(BaseObject):
    """
    Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if the message database is used

    :param chat_list: The chat list with changed number of unread messages
    :type chat_list: :class:`ChatList`
    :param total_count: Approximate total number of chats in the chat list
    :type total_count: :class:`Int32`
    :param unread_count: Total number of unread chats
    :type unread_count: :class:`Int32`
    :param unread_unmuted_count: Total number of unread unmuted chats
    :type unread_unmuted_count: :class:`Int32`
    :param marked_as_unread_count: Total number of chats marked as unread
    :type marked_as_unread_count: :class:`Int32`
    :param marked_as_unread_unmuted_count: Total number of unmuted chats marked as unread
    :type marked_as_unread_unmuted_count: :class:`Int32`
    """

    ID: typing.Literal["updateUnreadChatCount"] = field(default="updateUnreadChatCount", metadata={"alias": "@type"})
    chat_list: ChatList
    total_count: Int32
    unread_count: Int32
    unread_unmuted_count: Int32
    marked_as_unread_count: Int32
    marked_as_unread_unmuted_count: Int32


@dataclass(slots=True, kw_only=True)
class UpdateUnreadMessageCount(BaseObject):
    """
    Number of unread messages in a chat list has changed. This update is sent only if the message database is used

    :param chat_list: The chat list with changed number of unread messages
    :type chat_list: :class:`ChatList`
    :param unread_count: Total number of unread messages
    :type unread_count: :class:`Int32`
    :param unread_unmuted_count: Total number of unread messages in unmuted chats
    :type unread_unmuted_count: :class:`Int32`
    """

    ID: typing.Literal["updateUnreadMessageCount"] = field(
        default="updateUnreadMessageCount", metadata={"alias": "@type"}
    )
    chat_list: ChatList
    unread_count: Int32
    unread_unmuted_count: Int32


@dataclass(slots=True, kw_only=True)
class UpdateUser(BaseObject):
    """
    Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the application

    :param user: New data about the user
    :type user: :class:`User`
    """

    ID: typing.Literal["updateUser"] = field(default="updateUser", metadata={"alias": "@type"})
    user: User


@dataclass(slots=True, kw_only=True)
class UpdateUserFullInfo(BaseObject):
    """
    Some data in userFullInfo has been changed

    :param user_id: User identifier
    :type user_id: :class:`Int53`
    :param user_full_info: New full information about the user
    :type user_full_info: :class:`UserFullInfo`
    """

    ID: typing.Literal["updateUserFullInfo"] = field(default="updateUserFullInfo", metadata={"alias": "@type"})
    user_id: Int53
    user_full_info: UserFullInfo


@dataclass(slots=True, kw_only=True)
class UpdateUserPrivacySettingRules(BaseObject):
    """
    Some privacy setting rules have been changed

    :param setting: The privacy setting
    :type setting: :class:`UserPrivacySetting`
    :param rules: New privacy rules
    :type rules: :class:`UserPrivacySettingRules`
    """

    ID: typing.Literal["updateUserPrivacySettingRules"] = field(
        default="updateUserPrivacySettingRules", metadata={"alias": "@type"}
    )
    setting: UserPrivacySetting
    rules: UserPrivacySettingRules


@dataclass(slots=True, kw_only=True)
class UpdateUserStatus(BaseObject):
    """
    The user went online or offline

    :param user_id: User identifier
    :type user_id: :class:`Int53`
    :param status: New status of the user
    :type status: :class:`UserStatus`
    """

    ID: typing.Literal["updateUserStatus"] = field(default="updateUserStatus", metadata={"alias": "@type"})
    user_id: Int53
    status: UserStatus


@dataclass(slots=True, kw_only=True)
class UpdateVideoPublished(BaseObject):
    """
    An automatically scheduled message with video has been successfully sent after conversion

    :param chat_id: Identifier of the chat with the message
    :type chat_id: :class:`Int53`
    :param message_id: Identifier of the sent message
    :type message_id: :class:`Int53`
    """

    ID: typing.Literal["updateVideoPublished"] = field(default="updateVideoPublished", metadata={"alias": "@type"})
    chat_id: Int53
    message_id: Int53


@dataclass(slots=True, kw_only=True)
class UpdateWebAppMessageSent(BaseObject):
    """
    A message was sent by an opened Web App, so the Web App needs to be closed

    :param web_app_launch_id: Identifier of Web App launch
    :type web_app_launch_id: :class:`Int64`
    """

    ID: typing.Literal["updateWebAppMessageSent"] = field(
        default="updateWebAppMessageSent", metadata={"alias": "@type"}
    )
    web_app_launch_id: Int64


Update = typing.Union[
    UpdateAccentColors,
    UpdateActiveEmojiReactions,
    UpdateActiveLiveLocationMessages,
    UpdateActiveNotifications,
    UpdateAnimatedEmojiMessageClicked,
    UpdateAnimationSearchParameters,
    UpdateApplicationRecaptchaVerificationRequired,
    UpdateApplicationVerificationRequired,
    UpdateAttachmentMenuBots,
    UpdateAuthorizationState,
    UpdateAutosaveSettings,
    UpdateAvailableMessageEffects,
    UpdateBasicGroup,
    UpdateBasicGroupFullInfo,
    UpdateBusinessConnection,
    UpdateBusinessMessageEdited,
    UpdateBusinessMessagesDeleted,
    UpdateCall,
    UpdateChatAccentColors,
    UpdateChatAction,
    UpdateChatActionBar,
    UpdateChatActiveStories,
    UpdateChatAddedToList,
    UpdateChatAvailableReactions,
    UpdateChatBackground,
    UpdateChatBlockList,
    UpdateChatBoost,
    UpdateChatBusinessBotManageBar,
    UpdateChatDefaultDisableNotification,
    UpdateChatDraftMessage,
    UpdateChatEmojiStatus,
    UpdateChatFolders,
    UpdateChatHasProtectedContent,
    UpdateChatHasScheduledMessages,
    UpdateChatIsMarkedAsUnread,
    UpdateChatIsTranslatable,
    UpdateChatLastMessage,
    UpdateChatMember,
    UpdateChatMessageAutoDeleteTime,
    UpdateChatMessageSender,
    UpdateChatNotificationSettings,
    UpdateChatOnlineMemberCount,
    UpdateChatPendingJoinRequests,
    UpdateChatPermissions,
    UpdateChatPhoto,
    UpdateChatPosition,
    UpdateChatReadInbox,
    UpdateChatReadOutbox,
    UpdateChatRemovedFromList,
    UpdateChatReplyMarkup,
    UpdateChatRevenueAmount,
    UpdateChatTheme,
    UpdateChatThemes,
    UpdateChatTitle,
    UpdateChatUnreadMentionCount,
    UpdateChatUnreadReactionCount,
    UpdateChatVideoChat,
    UpdateChatViewAsTopics,
    UpdateConnectionState,
    UpdateContactCloseBirthdays,
    UpdateDefaultBackground,
    UpdateDefaultPaidReactionType,
    UpdateDefaultReactionType,
    UpdateDeleteMessages,
    UpdateDiceEmojis,
    UpdateFavoriteStickers,
    UpdateFile,
    UpdateFileAddedToDownloads,
    UpdateFileDownload,
    UpdateFileDownloads,
    UpdateFileGenerationStart,
    UpdateFileGenerationStop,
    UpdateFileRemovedFromDownloads,
    UpdateForumTopicInfo,
    UpdateGroupCall,
    UpdateGroupCallParticipant,
    UpdateHavePendingNotifications,
    UpdateInstalledStickerSets,
    UpdateLanguagePackStrings,
    UpdateMessageContent,
    UpdateMessageContentOpened,
    UpdateMessageEdited,
    UpdateMessageFactCheck,
    UpdateMessageInteractionInfo,
    UpdateMessageIsPinned,
    UpdateMessageLiveLocationViewed,
    UpdateMessageMentionRead,
    UpdateMessageReaction,
    UpdateMessageReactions,
    UpdateMessageSendAcknowledged,
    UpdateMessageSendFailed,
    UpdateMessageSendSucceeded,
    UpdateMessageUnreadReactions,
    UpdateNewBusinessCallbackQuery,
    UpdateNewBusinessMessage,
    UpdateNewCallSignalingData,
    UpdateNewCallbackQuery,
    UpdateNewChat,
    UpdateNewChatJoinRequest,
    UpdateNewChosenInlineResult,
    UpdateNewCustomEvent,
    UpdateNewCustomQuery,
    UpdateNewInlineCallbackQuery,
    UpdateNewInlineQuery,
    UpdateNewMessage,
    UpdateNewPreCheckoutQuery,
    UpdateNewShippingQuery,
    UpdateNotification,
    UpdateNotificationGroup,
    UpdateOption,
    UpdateOwnedStarCount,
    UpdatePaidMediaPurchased,
    UpdatePoll,
    UpdatePollAnswer,
    UpdateProfileAccentColors,
    UpdateQuickReplyShortcut,
    UpdateQuickReplyShortcutDeleted,
    UpdateQuickReplyShortcutMessages,
    UpdateQuickReplyShortcuts,
    UpdateReactionNotificationSettings,
    UpdateRecentStickers,
    UpdateSavedAnimations,
    UpdateSavedMessagesTags,
    UpdateSavedMessagesTopic,
    UpdateSavedMessagesTopicCount,
    UpdateSavedNotificationSounds,
    UpdateScopeNotificationSettings,
    UpdateSecretChat,
    UpdateServiceNotification,
    UpdateSpeechRecognitionTrial,
    UpdateSpeedLimitNotification,
    UpdateStarRevenueStatus,
    UpdateStickerSet,
    UpdateStory,
    UpdateStoryDeleted,
    UpdateStoryListChatCount,
    UpdateStorySendFailed,
    UpdateStorySendSucceeded,
    UpdateStoryStealthMode,
    UpdateSuggestedActions,
    UpdateSupergroup,
    UpdateSupergroupFullInfo,
    UpdateTermsOfService,
    UpdateTrendingStickerSets,
    UpdateUnconfirmedSession,
    UpdateUnreadChatCount,
    UpdateUnreadMessageCount,
    UpdateUser,
    UpdateUserFullInfo,
    UpdateUserPrivacySettingRules,
    UpdateUserStatus,
    UpdateVideoPublished,
    UpdateWebAppMessageSent,
]


@dataclass(slots=True, kw_only=True)
class Updates(BaseObject):
    """
    Contains a list of updates

    :param updates: List of updates
    :type updates: :class:`Vector[Update]`
    """

    ID: typing.Literal["updates"] = field(default="updates", metadata={"alias": "@type"})
    updates: Vector[Update]


@dataclass(slots=True, kw_only=True)
class UpgradeGiftResult(BaseObject):
    """
    Contains result of gift upgrading

    :param gift: The upgraded gift
    :type gift: :class:`UpgradedGift`
    :param received_gift_id: Unique identifier of the received gift for the current user
    :type received_gift_id: :class:`String`
    :param transfer_star_count: Number of Telegram Stars that must be paid to transfer the upgraded gift
    :type transfer_star_count: :class:`Int53`
    :param export_date: Point in time (Unix timestamp) when the gift can be transferred to the TON blockchain as an NFT
    :type export_date: :class:`Int32`
    :param is_saved: True, if the gift is displayed on the user's or the channel's profile page
    :type is_saved: :class:`Bool`
    :param can_be_transferred: True, if the gift can be transferred to another owner
    :type can_be_transferred: :class:`Bool`
    """

    ID: typing.Literal["upgradeGiftResult"] = field(default="upgradeGiftResult", metadata={"alias": "@type"})
    gift: UpgradedGift
    received_gift_id: String
    transfer_star_count: Int53
    export_date: Int32
    is_saved: Bool = field(default=False)
    can_be_transferred: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class UpgradedGift(BaseObject):
    """
    Describes an upgraded gift that can be transferred to another owner or transferred to the TON blockchain as an NFT

    :param id: Unique identifier of the gift
    :type id: :class:`Int64`
    :param title: The title of the upgraded gift
    :type title: :class:`String`
    :param name: Unique name of the upgraded gift that can be used with internalLinkTypeUpgradedGift
    :type name: :class:`String`
    :param number: Unique number of the upgraded gift among gifts upgraded from the same gift
    :type number: :class:`Int32`
    :param total_upgraded_count: Total number of gifts that were upgraded from the same gift
    :type total_upgraded_count: :class:`Int32`
    :param max_upgraded_count: The maximum number of gifts that can be upgraded from the same gift
    :type max_upgraded_count: :class:`Int32`
    :param owner_name: Name of the owner for the case when owner identifier and address aren't known
    :type owner_name: :class:`String`
    :param model: Model of the upgraded gift
    :type model: :class:`UpgradedGiftModel`
    :param symbol: Symbol of the upgraded gift
    :type symbol: :class:`UpgradedGiftSymbol`
    :param backdrop: Backdrop of the upgraded gift
    :type backdrop: :class:`UpgradedGiftBackdrop`
    :param owner_id: Identifier of the user or the chat that owns the upgraded gift; may be null if none or unknown, defaults to None
    :type owner_id: :class:`MessageSender`, optional
    :param original_details: Information about the originally sent gift; may be null if unknown, defaults to None
    :type original_details: :class:`UpgradedGiftOriginalDetails`, optional
    :param owner_address: Address of the gift NFT owner in TON blockchain; may be empty if none
    :type owner_address: :class:`String`
    :param gift_address: Address of the gift NFT in TON blockchain; may be empty if none
    :type gift_address: :class:`String`
    """

    ID: typing.Literal["upgradedGift"] = field(default="upgradedGift", metadata={"alias": "@type"})
    id: Int64
    title: String
    name: String
    number: Int32
    total_upgraded_count: Int32
    max_upgraded_count: Int32
    owner_name: String
    model: UpgradedGiftModel
    symbol: UpgradedGiftSymbol
    backdrop: UpgradedGiftBackdrop
    owner_id: typing.Optional[MessageSender] = field(default=None)
    original_details: typing.Optional[UpgradedGiftOriginalDetails] = field(default=None)
    owner_address: String = field(default="")
    gift_address: String = field(default="")


@dataclass(slots=True, kw_only=True)
class UpgradedGiftBackdrop(BaseObject):
    """
    Describes a backdrop of an upgraded gift

    :param name: Name of the backdrop
    :type name: :class:`String`
    :param colors: Colors of the backdrop
    :type colors: :class:`UpgradedGiftBackdropColors`
    :param rarity_per_mille: The number of upgraded gift that receive this backdrop for each 1000 gifts upgraded
    :type rarity_per_mille: :class:`Int32`
    """

    ID: typing.Literal["upgradedGiftBackdrop"] = field(default="upgradedGiftBackdrop", metadata={"alias": "@type"})
    name: String
    colors: UpgradedGiftBackdropColors
    rarity_per_mille: Int32


@dataclass(slots=True, kw_only=True)
class UpgradedGiftBackdropColors(BaseObject):
    """
    Describes colors of a backdrop of an upgraded gift

    :param center_color: A color in the center of the backdrop in the RGB format
    :type center_color: :class:`Int32`
    :param edge_color: A color on the edges of the backdrop in the RGB format
    :type edge_color: :class:`Int32`
    :param symbol_color: A color to be applied for the symbol in the RGB format
    :type symbol_color: :class:`Int32`
    :param text_color: A color for the text on the backdrop in the RGB format
    :type text_color: :class:`Int32`
    """

    ID: typing.Literal["upgradedGiftBackdropColors"] = field(
        default="upgradedGiftBackdropColors", metadata={"alias": "@type"}
    )
    center_color: Int32
    edge_color: Int32
    symbol_color: Int32
    text_color: Int32


@dataclass(slots=True, kw_only=True)
class UpgradedGiftModel(BaseObject):
    """
    Describes a model of an upgraded gift

    :param name: Name of the model
    :type name: :class:`String`
    :param sticker: The sticker representing the upgraded gift
    :type sticker: :class:`Sticker`
    :param rarity_per_mille: The number of upgraded gift that receive this model for each 1000 gifts upgraded
    :type rarity_per_mille: :class:`Int32`
    """

    ID: typing.Literal["upgradedGiftModel"] = field(default="upgradedGiftModel", metadata={"alias": "@type"})
    name: String
    sticker: Sticker
    rarity_per_mille: Int32


@dataclass(slots=True, kw_only=True)
class UpgradedGiftOriginalDetails(BaseObject):
    """
    Describes the original details about the gift

    :param receiver_id: Identifier of the user or the chat that received the gift
    :type receiver_id: :class:`MessageSender`
    :param text: Message added to the gift
    :type text: :class:`FormattedText`
    :param date: Point in time (Unix timestamp) when the gift was sent
    :type date: :class:`Int32`
    :param sender_id: Identifier of the user or the chat that sent the gift; may be null if the gift was private, defaults to None
    :type sender_id: :class:`MessageSender`, optional
    """

    ID: typing.Literal["upgradedGiftOriginalDetails"] = field(
        default="upgradedGiftOriginalDetails", metadata={"alias": "@type"}
    )
    receiver_id: MessageSender
    text: FormattedText
    date: Int32
    sender_id: typing.Optional[MessageSender] = field(default=None)


@dataclass(slots=True, kw_only=True)
class UpgradedGiftSymbol(BaseObject):
    """
    Describes a symbol shown on the pattern of an upgraded gift

    :param name: Name of the symbol
    :type name: :class:`String`
    :param sticker: The sticker representing the upgraded gift
    :type sticker: :class:`Sticker`
    :param rarity_per_mille: The number of upgraded gift that receive this symbol for each 1000 gifts upgraded
    :type rarity_per_mille: :class:`Int32`
    """

    ID: typing.Literal["upgradedGiftSymbol"] = field(default="upgradedGiftSymbol", metadata={"alias": "@type"})
    name: String
    sticker: Sticker
    rarity_per_mille: Int32


@dataclass(slots=True, kw_only=True)
class User(BaseObject):
    """
    Represents a user

    :param id: User identifier
    :type id: :class:`Int53`
    :param first_name: First name of the user
    :type first_name: :class:`String`
    :param last_name: Last name of the user
    :type last_name: :class:`String`
    :param phone_number: Phone number of the user
    :type phone_number: :class:`String`
    :param status: Current online status of the user
    :type status: :class:`UserStatus`
    :param accent_color_id: Identifier of the accent color for name, and backgrounds of profile photo, reply header, and link preview
    :type accent_color_id: :class:`Int32`
    :param profile_accent_color_id: Identifier of the accent color for the user's profile; -1 if none
    :type profile_accent_color_id: :class:`Int32`
    :param is_contact: The user is a contact of the current user
    :type is_contact: :class:`Bool`
    :param is_mutual_contact: The user is a contact of the current user and the current user is a contact of the user
    :type is_mutual_contact: :class:`Bool`
    :param is_close_friend: The user is a close friend of the current user; implies that the user is a contact
    :type is_close_friend: :class:`Bool`
    :param type_: Type of the user
    :type type_: :class:`UserType`
    :param language_code: IETF language tag of the user's language; only available to bots
    :type language_code: :class:`String`
    :param usernames: Usernames of the user; may be null, defaults to None
    :type usernames: :class:`Usernames`, optional
    :param profile_photo: Profile photo of the user; may be null, defaults to None
    :type profile_photo: :class:`ProfilePhoto`, optional
    :param emoji_status: Emoji status to be shown instead of the default Telegram Premium badge; may be null, defaults to None
    :type emoji_status: :class:`EmojiStatus`, optional
    :param verification_status: Information about verification status of the user; may be null if none, defaults to None
    :type verification_status: :class:`VerificationStatus`, optional
    :param is_premium: True, if the user is a Telegram Premium user
    :type is_premium: :class:`Bool`
    :param is_support: True, if the user is Telegram support account
    :type is_support: :class:`Bool`
    :param restriction_reason: If non-empty, it contains a human-readable description of the reason why access to this user must be restricted
    :type restriction_reason: :class:`String`
    :param has_active_stories: True, if the user has non-expired stories available to the current user
    :type has_active_stories: :class:`Bool`
    :param has_unread_active_stories: True, if the user has unread non-expired stories available to the current user
    :type has_unread_active_stories: :class:`Bool`
    :param restricts_new_chats: True, if the user may restrict new chats with non-contacts. Use canSendMessageToUser to check whether the current user can message the user or try to create a chat with them
    :type restricts_new_chats: :class:`Bool`
    :param have_access: If false, the user is inaccessible, and the only information known about the user is inside this class. Identifier of the user can't be passed to any method
    :type have_access: :class:`Bool`
    :param added_to_attachment_menu: True, if the user added the current bot to attachment menu; only available to bots
    :type added_to_attachment_menu: :class:`Bool`
    :param background_custom_emoji_id: Identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none, defaults to None
    :type background_custom_emoji_id: :class:`Int64`, optional
    :param profile_background_custom_emoji_id: Identifier of a custom emoji to be shown on the background of the user's profile; 0 if none, defaults to None
    :type profile_background_custom_emoji_id: :class:`Int64`, optional
    """

    ID: typing.Literal["user"] = field(default="user", metadata={"alias": "@type"})
    id: Int53
    first_name: String
    last_name: String
    phone_number: String
    status: UserStatus
    accent_color_id: Int32
    profile_accent_color_id: Int32
    is_contact: Bool
    is_mutual_contact: Bool
    is_close_friend: Bool
    type_: UserType = field(default=MISSING, metadata={"alias": "type"})
    language_code: String
    usernames: typing.Optional[Usernames] = field(default=None)
    profile_photo: typing.Optional[ProfilePhoto] = field(default=None)
    emoji_status: typing.Optional[EmojiStatus] = field(default=None)
    verification_status: typing.Optional[VerificationStatus] = field(default=None)
    is_premium: Bool = field(default=False)
    is_support: Bool = field(default=False)
    restriction_reason: String = field(default="")
    has_active_stories: Bool = field(default=False)
    has_unread_active_stories: Bool = field(default=False)
    restricts_new_chats: Bool = field(default=False)
    have_access: Bool = field(default=True)
    added_to_attachment_menu: Bool = field(default=False)
    background_custom_emoji_id: typing.Optional[Int64] = field(default=0)
    profile_background_custom_emoji_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class UserFullInfo(BaseObject):
    """
    Contains full information about a user

    :param gift_count: Number of saved to profile gifts for other users or the total number of received gifts for the current user
    :type gift_count: :class:`Int32`
    :param personal_photo: User profile photo set by the current user for the contact; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos, defaults to None
    :type personal_photo: :class:`ChatPhoto`, optional
    :param photo: User profile photo; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null and personal_photo is null, then it is the same photo as in user.profile_photo and chat.photo, defaults to None
    :type photo: :class:`ChatPhoto`, optional
    :param public_photo: User profile photo visible if the main photo is hidden by privacy settings; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null and both photo and personal_photo are null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos, defaults to None
    :type public_photo: :class:`ChatPhoto`, optional
    :param block_list: Block list to which the user is added; may be null if none, defaults to None
    :type block_list: :class:`BlockList`, optional
    :param bio: A short user bio; may be null for bots, defaults to None
    :type bio: :class:`FormattedText`, optional
    :param birthdate: Birthdate of the user; may be null if unknown, defaults to None
    :type birthdate: :class:`Birthdate`, optional
    :param bot_verification: Information about verification status of the user provided by a bot; may be null if none or unknown, defaults to None
    :type bot_verification: :class:`BotVerification`, optional
    :param business_info: Information about business settings for Telegram Business accounts; may be null if none, defaults to None
    :type business_info: :class:`BusinessInfo`, optional
    :param bot_info: For bots, information about the bot; may be null if the user isn't a bot, defaults to None
    :type bot_info: :class:`BotInfo`, optional
    :param can_be_called: True, if the user can be called
    :type can_be_called: :class:`Bool`
    :param supports_video_calls: True, if a video call can be created with the user
    :type supports_video_calls: :class:`Bool`
    :param has_private_calls: True, if the user can't be called due to their privacy settings
    :type has_private_calls: :class:`Bool`
    :param has_private_forwards: True, if the user can't be linked in forwarded messages due to their privacy settings
    :type has_private_forwards: :class:`Bool`
    :param has_restricted_voice_and_video_note_messages: True, if voice and video notes can't be sent or forwarded to the user
    :type has_restricted_voice_and_video_note_messages: :class:`Bool`
    :param has_posted_to_profile_stories: True, if the user has posted to profile stories
    :type has_posted_to_profile_stories: :class:`Bool`
    :param has_sponsored_messages_enabled: True, if the user always enabled sponsored messages; known only for the current user
    :type has_sponsored_messages_enabled: :class:`Bool`
    :param need_phone_number_privacy_exception: True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used
    :type need_phone_number_privacy_exception: :class:`Bool`
    :param set_chat_background: True, if the user set chat background for both chat users and it wasn't reverted yet
    :type set_chat_background: :class:`Bool`
    :param group_in_common_count: Number of group chats where both the other user and the current user are a member; 0 for the current user
    :type group_in_common_count: :class:`Int32`
    :param personal_chat_id: Identifier of the personal chat of the user; 0 if none, defaults to None
    :type personal_chat_id: :class:`Int53`, optional
    """

    ID: typing.Literal["userFullInfo"] = field(default="userFullInfo", metadata={"alias": "@type"})
    gift_count: Int32
    personal_photo: typing.Optional[ChatPhoto] = field(default=None)
    photo: typing.Optional[ChatPhoto] = field(default=None)
    public_photo: typing.Optional[ChatPhoto] = field(default=None)
    block_list: typing.Optional[BlockList] = field(default=None)
    bio: typing.Optional[FormattedText] = field(default=None)
    birthdate: typing.Optional[Birthdate] = field(default=None)
    bot_verification: typing.Optional[BotVerification] = field(default=None)
    business_info: typing.Optional[BusinessInfo] = field(default=None)
    bot_info: typing.Optional[BotInfo] = field(default=None)
    can_be_called: Bool = field(default=False)
    supports_video_calls: Bool = field(default=False)
    has_private_calls: Bool = field(default=False)
    has_private_forwards: Bool = field(default=False)
    has_restricted_voice_and_video_note_messages: Bool = field(default=False)
    has_posted_to_profile_stories: Bool = field(default=False)
    has_sponsored_messages_enabled: Bool = field(default=False)
    need_phone_number_privacy_exception: Bool = field(default=False)
    set_chat_background: Bool = field(default=False)
    group_in_common_count: Int32 = field(default=0)
    personal_chat_id: typing.Optional[Int53] = field(default=0)


@dataclass(slots=True, kw_only=True)
class UserLink(BaseObject):
    """
    Contains an HTTPS URL, which can be used to get information about a user

    :param url: The URL
    :type url: :class:`String`
    :param expires_in: Left time for which the link is valid, in seconds; 0 if the link is a public username link
    :type expires_in: :class:`Int32`
    """

    ID: typing.Literal["userLink"] = field(default="userLink", metadata={"alias": "@type"})
    url: String
    expires_in: Int32 = field(default=0)


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingAllowCalls(BaseObject):
    """
    A privacy setting for managing whether the user can be called
    """

    ID: typing.Literal["userPrivacySettingAllowCalls"] = field(
        default="userPrivacySettingAllowCalls", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingAllowChatInvites(BaseObject):
    """
    A privacy setting for managing whether the user can be invited to chats
    """

    ID: typing.Literal["userPrivacySettingAllowChatInvites"] = field(
        default="userPrivacySettingAllowChatInvites", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingAllowFindingByPhoneNumber(BaseObject):
    """
    A privacy setting for managing whether the user can be found by their phone number. Checked only if the phone number is not known to the other user. Can be set only to "Allow contacts" or "Allow all"
    """

    ID: typing.Literal["userPrivacySettingAllowFindingByPhoneNumber"] = field(
        default="userPrivacySettingAllowFindingByPhoneNumber", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingAllowPeerToPeerCalls(BaseObject):
    """
    A privacy setting for managing whether peer-to-peer connections can be used for calls
    """

    ID: typing.Literal["userPrivacySettingAllowPeerToPeerCalls"] = field(
        default="userPrivacySettingAllowPeerToPeerCalls", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages(BaseObject):
    """
    A privacy setting for managing whether the user can receive voice and video messages in private chats; for Telegram Premium users only
    """

    ID: typing.Literal["userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages"] = field(
        default="userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingAutosaveGifts(BaseObject):
    """
    A privacy setting for managing whether received gifts are automatically shown on the user's profile page
    """

    ID: typing.Literal["userPrivacySettingAutosaveGifts"] = field(
        default="userPrivacySettingAutosaveGifts", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingShowBio(BaseObject):
    """
    A privacy setting for managing whether the user's bio is visible
    """

    ID: typing.Literal["userPrivacySettingShowBio"] = field(
        default="userPrivacySettingShowBio", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingShowBirthdate(BaseObject):
    """
    A privacy setting for managing whether the user's birthdate is visible
    """

    ID: typing.Literal["userPrivacySettingShowBirthdate"] = field(
        default="userPrivacySettingShowBirthdate", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingShowLinkInForwardedMessages(BaseObject):
    """
    A privacy setting for managing whether a link to the user's account is included in forwarded messages
    """

    ID: typing.Literal["userPrivacySettingShowLinkInForwardedMessages"] = field(
        default="userPrivacySettingShowLinkInForwardedMessages", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingShowPhoneNumber(BaseObject):
    """
    A privacy setting for managing whether the user's phone number is visible
    """

    ID: typing.Literal["userPrivacySettingShowPhoneNumber"] = field(
        default="userPrivacySettingShowPhoneNumber", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingShowProfilePhoto(BaseObject):
    """
    A privacy setting for managing whether the user's profile photo is visible
    """

    ID: typing.Literal["userPrivacySettingShowProfilePhoto"] = field(
        default="userPrivacySettingShowProfilePhoto", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingShowStatus(BaseObject):
    """
    A privacy setting for managing whether the user's online status is visible
    """

    ID: typing.Literal["userPrivacySettingShowStatus"] = field(
        default="userPrivacySettingShowStatus", metadata={"alias": "@type"}
    )


UserPrivacySetting = typing.Union[
    UserPrivacySettingAllowCalls,
    UserPrivacySettingAllowChatInvites,
    UserPrivacySettingAllowFindingByPhoneNumber,
    UserPrivacySettingAllowPeerToPeerCalls,
    UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages,
    UserPrivacySettingAutosaveGifts,
    UserPrivacySettingShowBio,
    UserPrivacySettingShowBirthdate,
    UserPrivacySettingShowLinkInForwardedMessages,
    UserPrivacySettingShowPhoneNumber,
    UserPrivacySettingShowProfilePhoto,
    UserPrivacySettingShowStatus,
]


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingRuleAllowAll(BaseObject):
    """
    A rule to allow all users to do something
    """

    ID: typing.Literal["userPrivacySettingRuleAllowAll"] = field(
        default="userPrivacySettingRuleAllowAll", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingRuleAllowBots(BaseObject):
    """
    A rule to allow all bots to do something
    """

    ID: typing.Literal["userPrivacySettingRuleAllowBots"] = field(
        default="userPrivacySettingRuleAllowBots", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingRuleAllowChatMembers(BaseObject):
    """
    A rule to allow all members of certain specified basic groups and supergroups to doing something

    :param chat_ids: The chat identifiers, total number of chats in all rules must not exceed 20
    :type chat_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["userPrivacySettingRuleAllowChatMembers"] = field(
        default="userPrivacySettingRuleAllowChatMembers", metadata={"alias": "@type"}
    )
    chat_ids: Vector[Int53]


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingRuleAllowContacts(BaseObject):
    """
    A rule to allow all contacts of the user to do something
    """

    ID: typing.Literal["userPrivacySettingRuleAllowContacts"] = field(
        default="userPrivacySettingRuleAllowContacts", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingRuleAllowPremiumUsers(BaseObject):
    """
    A rule to allow all Premium Users to do something; currently, allowed only for userPrivacySettingAllowChatInvites
    """

    ID: typing.Literal["userPrivacySettingRuleAllowPremiumUsers"] = field(
        default="userPrivacySettingRuleAllowPremiumUsers", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingRuleAllowUsers(BaseObject):
    """
    A rule to allow certain specified users to do something

    :param user_ids: The user identifiers, total number of users in all rules must not exceed 1000
    :type user_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["userPrivacySettingRuleAllowUsers"] = field(
        default="userPrivacySettingRuleAllowUsers", metadata={"alias": "@type"}
    )
    user_ids: Vector[Int53]


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingRuleRestrictAll(BaseObject):
    """
    A rule to restrict all users from doing something
    """

    ID: typing.Literal["userPrivacySettingRuleRestrictAll"] = field(
        default="userPrivacySettingRuleRestrictAll", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingRuleRestrictBots(BaseObject):
    """
    A rule to restrict all bots from doing something
    """

    ID: typing.Literal["userPrivacySettingRuleRestrictBots"] = field(
        default="userPrivacySettingRuleRestrictBots", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingRuleRestrictChatMembers(BaseObject):
    """
    A rule to restrict all members of specified basic groups and supergroups from doing something

    :param chat_ids: The chat identifiers, total number of chats in all rules must not exceed 20
    :type chat_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["userPrivacySettingRuleRestrictChatMembers"] = field(
        default="userPrivacySettingRuleRestrictChatMembers", metadata={"alias": "@type"}
    )
    chat_ids: Vector[Int53]


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingRuleRestrictContacts(BaseObject):
    """
    A rule to restrict all contacts of the user from doing something
    """

    ID: typing.Literal["userPrivacySettingRuleRestrictContacts"] = field(
        default="userPrivacySettingRuleRestrictContacts", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingRuleRestrictUsers(BaseObject):
    """
    A rule to restrict all specified users from doing something

    :param user_ids: The user identifiers, total number of users in all rules must not exceed 1000
    :type user_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["userPrivacySettingRuleRestrictUsers"] = field(
        default="userPrivacySettingRuleRestrictUsers", metadata={"alias": "@type"}
    )
    user_ids: Vector[Int53]


UserPrivacySettingRule = typing.Union[
    UserPrivacySettingRuleAllowAll,
    UserPrivacySettingRuleAllowBots,
    UserPrivacySettingRuleAllowChatMembers,
    UserPrivacySettingRuleAllowContacts,
    UserPrivacySettingRuleAllowPremiumUsers,
    UserPrivacySettingRuleAllowUsers,
    UserPrivacySettingRuleRestrictAll,
    UserPrivacySettingRuleRestrictBots,
    UserPrivacySettingRuleRestrictChatMembers,
    UserPrivacySettingRuleRestrictContacts,
    UserPrivacySettingRuleRestrictUsers,
]


@dataclass(slots=True, kw_only=True)
class UserPrivacySettingRules(BaseObject):
    """
    A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed

    :param rules: A list of rules
    :type rules: :class:`Vector[UserPrivacySettingRule]`
    """

    ID: typing.Literal["userPrivacySettingRules"] = field(
        default="userPrivacySettingRules", metadata={"alias": "@type"}
    )
    rules: Vector[UserPrivacySettingRule]


@dataclass(slots=True, kw_only=True)
class UserStatusEmpty(BaseObject):
    """
    The user's status has never been changed
    """

    ID: typing.Literal["userStatusEmpty"] = field(default="userStatusEmpty", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class UserStatusLastMonth(BaseObject):
    """
    The user is offline, but was online last month

    :param by_my_privacy_settings: Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
    :type by_my_privacy_settings: :class:`Bool`
    """

    ID: typing.Literal["userStatusLastMonth"] = field(default="userStatusLastMonth", metadata={"alias": "@type"})
    by_my_privacy_settings: Bool


@dataclass(slots=True, kw_only=True)
class UserStatusLastWeek(BaseObject):
    """
    The user is offline, but was online last week

    :param by_my_privacy_settings: Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
    :type by_my_privacy_settings: :class:`Bool`
    """

    ID: typing.Literal["userStatusLastWeek"] = field(default="userStatusLastWeek", metadata={"alias": "@type"})
    by_my_privacy_settings: Bool


@dataclass(slots=True, kw_only=True)
class UserStatusOffline(BaseObject):
    """
    The user is offline

    :param was_online: Point in time (Unix timestamp) when the user was last online
    :type was_online: :class:`Int32`
    """

    ID: typing.Literal["userStatusOffline"] = field(default="userStatusOffline", metadata={"alias": "@type"})
    was_online: Int32


@dataclass(slots=True, kw_only=True)
class UserStatusOnline(BaseObject):
    """
    The user is online

    :param expires: Point in time (Unix timestamp) when the user's online status will expire
    :type expires: :class:`Int32`
    """

    ID: typing.Literal["userStatusOnline"] = field(default="userStatusOnline", metadata={"alias": "@type"})
    expires: Int32


@dataclass(slots=True, kw_only=True)
class UserStatusRecently(BaseObject):
    """
    The user was online recently

    :param by_my_privacy_settings: Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
    :type by_my_privacy_settings: :class:`Bool`
    """

    ID: typing.Literal["userStatusRecently"] = field(default="userStatusRecently", metadata={"alias": "@type"})
    by_my_privacy_settings: Bool


UserStatus = typing.Union[
    UserStatusEmpty,
    UserStatusLastMonth,
    UserStatusLastWeek,
    UserStatusOffline,
    UserStatusOnline,
    UserStatusRecently,
]


@dataclass(slots=True, kw_only=True)
class UserSupportInfo(BaseObject):
    """
    Contains custom information about the user

    :param message: Information message
    :type message: :class:`FormattedText`
    :param author: Information author
    :type author: :class:`String`
    :param date: Information change date
    :type date: :class:`Int32`
    """

    ID: typing.Literal["userSupportInfo"] = field(default="userSupportInfo", metadata={"alias": "@type"})
    message: FormattedText
    author: String
    date: Int32


@dataclass(slots=True, kw_only=True)
class UserTypeBot(BaseObject):
    """
    A bot (see https://core.telegram.org/bots)

    :param inline_query_placeholder: Placeholder for inline queries (displayed on the application input field)
    :type inline_query_placeholder: :class:`String`
    :param active_user_count: The number of recently active users of the bot
    :type active_user_count: :class:`Int32`
    :param can_be_edited: True, if the bot is owned by the current user and can be edited using the methods toggleBotUsernameIsActive, reorderBotActiveUsernames, setBotProfilePhoto, setBotName, setBotInfoDescription, and setBotInfoShortDescription
    :type can_be_edited: :class:`Bool`
    :param can_join_groups: True, if the bot can be invited to basic group and supergroup chats
    :type can_join_groups: :class:`Bool`
    :param can_read_all_group_messages: True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages
    :type can_read_all_group_messages: :class:`Bool`
    :param has_main_web_app: True, if the bot has the main Web App
    :type has_main_web_app: :class:`Bool`
    :param is_inline: True, if the bot supports inline queries
    :type is_inline: :class:`Bool`
    :param need_location: True, if the location of the user is expected to be sent with every inline query to this bot
    :type need_location: :class:`Bool`
    :param can_connect_to_business: True, if the bot supports connection to Telegram Business accounts
    :type can_connect_to_business: :class:`Bool`
    :param can_be_added_to_attachment_menu: True, if the bot can be added to attachment or side menu
    :type can_be_added_to_attachment_menu: :class:`Bool`
    """

    ID: typing.Literal["userTypeBot"] = field(default="userTypeBot", metadata={"alias": "@type"})
    inline_query_placeholder: String
    active_user_count: Int32
    can_be_edited: Bool = field(default=False)
    can_join_groups: Bool = field(default=False)
    can_read_all_group_messages: Bool = field(default=False)
    has_main_web_app: Bool = field(default=False)
    is_inline: Bool = field(default=False)
    need_location: Bool = field(default=False)
    can_connect_to_business: Bool = field(default=False)
    can_be_added_to_attachment_menu: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class UserTypeDeleted(BaseObject):
    """
    A deleted user or deleted bot. No information on the user besides the user identifier is available. It is not possible to perform any active actions on this type of user
    """

    ID: typing.Literal["userTypeDeleted"] = field(default="userTypeDeleted", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class UserTypeRegular(BaseObject):
    """
    A regular user
    """

    ID: typing.Literal["userTypeRegular"] = field(default="userTypeRegular", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class UserTypeUnknown(BaseObject):
    """
    No information on the user besides the user identifier is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type
    """

    ID: typing.Literal["userTypeUnknown"] = field(default="userTypeUnknown", metadata={"alias": "@type"})


UserType = typing.Union[
    UserTypeBot,
    UserTypeDeleted,
    UserTypeRegular,
    UserTypeUnknown,
]


@dataclass(slots=True, kw_only=True)
class Usernames(BaseObject):
    """
    Describes usernames assigned to a user, a supergroup, or a channel

    :param active_usernames: List of active usernames; the first one must be shown as the primary username. The order of active usernames can be changed with reorderActiveUsernames, reorderBotActiveUsernames or reorderSupergroupActiveUsernames
    :type active_usernames: :class:`Vector[String]`
    :param disabled_usernames: List of currently disabled usernames; the username can be activated with toggleUsernameIsActive, toggleBotUsernameIsActive, or toggleSupergroupUsernameIsActive
    :type disabled_usernames: :class:`Vector[String]`
    :param editable_username: The active username, which can be changed with setUsername or setSupergroupUsername. Information about other active usernames can be received using getCollectibleItemInfo
    :type editable_username: :class:`String`
    """

    ID: typing.Literal["usernames"] = field(default="usernames", metadata={"alias": "@type"})
    active_usernames: Vector[String]
    disabled_usernames: Vector[String]
    editable_username: String


@dataclass(slots=True, kw_only=True)
class Users(BaseObject):
    """
    Represents a list of users

    :param total_count: Approximate total number of users found
    :type total_count: :class:`Int32`
    :param user_ids: A list of user identifiers
    :type user_ids: :class:`Vector[Int53]`
    """

    ID: typing.Literal["users"] = field(default="users", metadata={"alias": "@type"})
    total_count: Int32
    user_ids: Vector[Int53]


@dataclass(slots=True, kw_only=True)
class ValidatedOrderInfo(BaseObject):
    """
    Contains a temporary identifier of validated order information, which is stored for one hour, and the available shipping options

    :param order_info_id: Temporary identifier of the order information
    :type order_info_id: :class:`String`
    :param shipping_options: Available shipping options
    :type shipping_options: :class:`Vector[ShippingOption]`
    """

    ID: typing.Literal["validatedOrderInfo"] = field(default="validatedOrderInfo", metadata={"alias": "@type"})
    order_info_id: String
    shipping_options: Vector[ShippingOption]


@dataclass(slots=True, kw_only=True)
class VectorPathCommandCubicBezierCurve(BaseObject):
    """
    A cubic Bzier curve to a given point

    :param start_control_point: The start control point of the curve
    :type start_control_point: :class:`Point`
    :param end_control_point: The end control point of the curve
    :type end_control_point: :class:`Point`
    :param end_point: The end point of the curve
    :type end_point: :class:`Point`
    """

    ID: typing.Literal["vectorPathCommandCubicBezierCurve"] = field(
        default="vectorPathCommandCubicBezierCurve", metadata={"alias": "@type"}
    )
    start_control_point: Point
    end_control_point: Point
    end_point: Point


@dataclass(slots=True, kw_only=True)
class VectorPathCommandLine(BaseObject):
    """
    A straight line to a given point

    :param end_point: The end point of the straight line
    :type end_point: :class:`Point`
    """

    ID: typing.Literal["vectorPathCommandLine"] = field(default="vectorPathCommandLine", metadata={"alias": "@type"})
    end_point: Point


VectorPathCommand = typing.Union[
    VectorPathCommandCubicBezierCurve,
    VectorPathCommandLine,
]


@dataclass(slots=True, kw_only=True)
class Venue(BaseObject):
    """
    Describes a venue

    :param location: Venue location; as defined by the sender
    :type location: :class:`Location`
    :param title: Venue name; as defined by the sender
    :type title: :class:`String`
    :param address: Venue address; as defined by the sender
    :type address: :class:`String`
    :param provider: Provider of the venue database; as defined by the sender. Currently, only "foursquare" and "gplaces" (Google Places) need to be supported
    :type provider: :class:`String`
    :param id: Identifier of the venue in the provider database; as defined by the sender
    :type id: :class:`String`
    :param type_: Type of the venue in the provider database; as defined by the sender
    :type type_: :class:`String`
    """

    ID: typing.Literal["venue"] = field(default="venue", metadata={"alias": "@type"})
    location: Location
    title: String
    address: String
    provider: String
    id: String
    type_: String = field(default=MISSING, metadata={"alias": "type"})


@dataclass(slots=True, kw_only=True)
class VerificationStatus(BaseObject):
    """
    Contains information about verification status of a chat or a user

    :param is_verified: True, if the chat or the user is verified by Telegram
    :type is_verified: :class:`Bool`
    :param is_scam: True, if the chat or the user is marked as scam by Telegram
    :type is_scam: :class:`Bool`
    :param is_fake: True, if the chat or the user is marked as fake by Telegram
    :type is_fake: :class:`Bool`
    :param bot_verification_icon_custom_emoji_id: Identifier of the custom emoji to be shown as verification sign provided by a bot for the user; 0 if none, defaults to None
    :type bot_verification_icon_custom_emoji_id: :class:`Int64`, optional
    """

    ID: typing.Literal["verificationStatus"] = field(default="verificationStatus", metadata={"alias": "@type"})
    is_verified: Bool = field(default=False)
    is_scam: Bool = field(default=False)
    is_fake: Bool = field(default=False)
    bot_verification_icon_custom_emoji_id: typing.Optional[Int64] = field(default=0)


@dataclass(slots=True, kw_only=True)
class Video(BaseObject):
    """
    Describes a video file

    :param duration: Duration of the video, in seconds; as defined by the sender
    :type duration: :class:`Int32`
    :param width: Video width; as defined by the sender
    :type width: :class:`Int32`
    :param height: Video height; as defined by the sender
    :type height: :class:`Int32`
    :param file_name: Original name of the file; as defined by the sender
    :type file_name: :class:`String`
    :param mime_type: MIME type of the file; as defined by the sender
    :type mime_type: :class:`String`
    :param video: File containing the video
    :type video: :class:`File`
    :param minithumbnail: Video minithumbnail; may be null, defaults to None
    :type minithumbnail: :class:`Minithumbnail`, optional
    :param thumbnail: Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null, defaults to None
    :type thumbnail: :class:`Thumbnail`, optional
    :param has_stickers: True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
    :type has_stickers: :class:`Bool`
    :param supports_streaming: True, if the video is expected to be streamed
    :type supports_streaming: :class:`Bool`
    """

    ID: typing.Literal["video"] = field(default="video", metadata={"alias": "@type"})
    duration: Int32
    width: Int32
    height: Int32
    file_name: String
    mime_type: String
    video: File
    minithumbnail: typing.Optional[Minithumbnail] = field(default=None)
    thumbnail: typing.Optional[Thumbnail] = field(default=None)
    has_stickers: Bool = field(default=False)
    supports_streaming: Bool = field(default=False)


@dataclass(slots=True, kw_only=True)
class VideoChat(BaseObject):
    """
    Describes a video chat

    :param default_participant_id: Default group call participant identifier to join the video chat; may be null, defaults to None
    :type default_participant_id: :class:`MessageSender`, optional
    :param has_participants: True, if the video chat has participants
    :type has_participants: :class:`Bool`
    :param group_call_id: Group call identifier of an active video chat; 0 if none. Full information about the video chat can be received through the method getGroupCall, defaults to None
    :type group_call_id: :class:`Int32`, optional
    """

    ID: typing.Literal["videoChat"] = field(default="videoChat", metadata={"alias": "@type"})
    default_participant_id: typing.Optional[MessageSender] = field(default=None)
    has_participants: Bool = field(default=False)
    group_call_id: typing.Optional[Int32] = field(default=0)


@dataclass(slots=True, kw_only=True)
class VideoNote(BaseObject):
    """
    Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format

    :param duration: Duration of the video, in seconds; as defined by the sender
    :type duration: :class:`Int32`
    :param length: Video width and height; as defined by the sender
    :type length: :class:`Int32`
    :param video: File containing the video
    :type video: :class:`File`
    :param minithumbnail: Video minithumbnail; may be null, defaults to None
    :type minithumbnail: :class:`Minithumbnail`, optional
    :param thumbnail: Video thumbnail in JPEG format; as defined by the sender; may be null, defaults to None
    :type thumbnail: :class:`Thumbnail`, optional
    :param speech_recognition_result: Result of speech recognition in the video note; may be null, defaults to None
    :type speech_recognition_result: :class:`SpeechRecognitionResult`, optional
    :param waveform: A waveform representation of the video note's audio in 5-bit format; may be empty if unknown
    :type waveform: :class:`Bytes`
    """

    ID: typing.Literal["videoNote"] = field(default="videoNote", metadata={"alias": "@type"})
    duration: Int32
    length: Int32
    video: File
    minithumbnail: typing.Optional[Minithumbnail] = field(default=None)
    thumbnail: typing.Optional[Thumbnail] = field(default=None)
    speech_recognition_result: typing.Optional[SpeechRecognitionResult] = field(default=None)
    waveform: Bytes = field(default=b"")


@dataclass(slots=True, kw_only=True)
class VoiceNote(BaseObject):
    """
    Describes a voice note

    :param duration: Duration of the voice note, in seconds; as defined by the sender
    :type duration: :class:`Int32`
    :param waveform: A waveform representation of the voice note in 5-bit format
    :type waveform: :class:`Bytes`
    :param mime_type: MIME type of the file; as defined by the sender. Usually, one of "audio/ogg" for Opus in an OGG container, "audio/mpeg" for an MP3 audio, or "audio/mp4" for an M4A audio
    :type mime_type: :class:`String`
    :param voice: File containing the voice note
    :type voice: :class:`File`
    :param speech_recognition_result: Result of speech recognition in the voice note; may be null, defaults to None
    :type speech_recognition_result: :class:`SpeechRecognitionResult`, optional
    """

    ID: typing.Literal["voiceNote"] = field(default="voiceNote", metadata={"alias": "@type"})
    duration: Int32
    waveform: Bytes
    mime_type: String
    voice: File
    speech_recognition_result: typing.Optional[SpeechRecognitionResult] = field(default=None)


@dataclass(slots=True, kw_only=True)
class WebApp(BaseObject):
    """
    Describes a Web App. Use getInternalLink with internalLinkTypeWebApp to share the Web App

    :param short_name: Web App short name
    :type short_name: :class:`String`
    :param title: Web App title
    :type title: :class:`String`
    :param description: Web App description
    :type description: :class:`String`
    :param photo: Web App photo
    :type photo: :class:`Photo`
    :param animation: Web App animation; may be null, defaults to None
    :type animation: :class:`Animation`, optional
    """

    ID: typing.Literal["webApp"] = field(default="webApp", metadata={"alias": "@type"})
    short_name: String
    title: String
    description: String
    photo: Photo
    animation: typing.Optional[Animation] = field(default=None)


@dataclass(slots=True, kw_only=True)
class WebAppInfo(BaseObject):
    """
    Contains information about a Web App

    :param launch_id: Unique identifier for the Web App launch
    :type launch_id: :class:`Int64`
    :param url: A Web App URL to open in a web view
    :type url: :class:`String`
    """

    ID: typing.Literal["webAppInfo"] = field(default="webAppInfo", metadata={"alias": "@type"})
    launch_id: Int64
    url: String


@dataclass(slots=True, kw_only=True)
class WebAppOpenModeCompact(BaseObject):
    """
    The Web App is opened in the compact mode
    """

    ID: typing.Literal["webAppOpenModeCompact"] = field(default="webAppOpenModeCompact", metadata={"alias": "@type"})


@dataclass(slots=True, kw_only=True)
class WebAppOpenModeFullScreen(BaseObject):
    """
    The Web App is opened in the full-screen mode
    """

    ID: typing.Literal["webAppOpenModeFullScreen"] = field(
        default="webAppOpenModeFullScreen", metadata={"alias": "@type"}
    )


@dataclass(slots=True, kw_only=True)
class WebAppOpenModeFullSize(BaseObject):
    """
    The Web App is opened in the full-size mode
    """

    ID: typing.Literal["webAppOpenModeFullSize"] = field(default="webAppOpenModeFullSize", metadata={"alias": "@type"})


WebAppOpenMode = typing.Union[
    WebAppOpenModeCompact,
    WebAppOpenModeFullScreen,
    WebAppOpenModeFullSize,
]


@dataclass(slots=True, kw_only=True)
class WebAppOpenParameters(BaseObject):
    """
    Options to be used when a Web App is opened

    :param application_name: Short name of the current application; 0-64 English letters, digits, and underscores
    :type application_name: :class:`String`
    :param theme: Preferred Web App theme; pass null to use the default theme, defaults to None
    :type theme: :class:`ThemeParameters`, optional
    :param mode: The mode in which the Web App is opened; pass null to open in webAppOpenModeFullSize, defaults to None
    :type mode: :class:`WebAppOpenMode`, optional
    """

    ID: typing.Literal["webAppOpenParameters"] = field(default="webAppOpenParameters", metadata={"alias": "@type"})
    application_name: String
    theme: typing.Optional[ThemeParameters] = field(default=None)
    mode: typing.Optional[WebAppOpenMode] = field(default=None)


@dataclass(slots=True, kw_only=True)
class WebPageInstantView(BaseObject):
    """
    Describes an instant view page for a web page

    :param page_blocks: Content of the instant view page
    :type page_blocks: :class:`Vector[PageBlock]`
    :param version: Version of the instant view; currently, can be 1 or 2
    :type version: :class:`Int32`
    :param feedback_link: An internal link to be opened to leave feedback about the instant view
    :type feedback_link: :class:`InternalLinkType`
    :param is_rtl: True, if the instant view must be shown from right to left
    :type is_rtl: :class:`Bool`
    :param is_full: True, if the instant view contains the full page. A network request might be needed to get the full instant view
    :type is_full: :class:`Bool`
    :param view_count: Number of the instant view views; 0 if unknown, defaults to None
    :type view_count: :class:`Int32`, optional
    """

    ID: typing.Literal["webPageInstantView"] = field(default="webPageInstantView", metadata={"alias": "@type"})
    page_blocks: Vector[PageBlock]
    version: Int32
    feedback_link: InternalLinkType
    is_rtl: Bool = field(default=False)
    is_full: Bool = field(default=False)
    view_count: typing.Optional[Int32] = field(default=0)
